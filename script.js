var $r = Object.defineProperty; var Jr = (a, t, g) => t in a ? $r(a, t, { enumerable: !0, configurable: !0, writable: !0, value: g }) : a[t] = g; var me = (a, t, g) => (Jr(a, typeof t != "symbol" ? t + "" : t, g), g); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const _ of document.querySelectorAll('link[rel="modulepreload"]')) v(_); new MutationObserver(_ => { for (const C of _) if (C.type === "childList") for (const b of C.addedNodes) b.tagName === "LINK" && b.rel === "modulepreload" && v(b) }).observe(document, { childList: !0, subtree: !0 }); function g(_) { const C = {}; return _.integrity && (C.integrity = _.integrity), _.referrerPolicy && (C.referrerPolicy = _.referrerPolicy), _.crossOrigin === "use-credentials" ? C.credentials = "include" : _.crossOrigin === "anonymous" ? C.credentials = "omit" : C.credentials = "same-origin", C } function v(_) { if (_.ep) return; _.ep = !0; const C = g(_); fetch(_.href, C) } })(); function Hi(a, t) { const g = Object.create(null), v = a.split(","); for (let _ = 0; _ < v.length; _++)g[v[_]] = !0; return t ? _ => !!g[_.toLowerCase()] : _ => !!g[_] } function De(a) { if (ct(a)) { const t = {}; for (let g = 0; g < a.length; g++) { const v = a[g], _ = wt(v) ? es(v) : De(v); if (_) for (const C in _) t[C] = _[C] } return t } else { if (wt(a)) return a; if (yt(a)) return a } } const Zr = /;(?![^(]*\))/g, Qr = /:([^]+)/, ts = /\/\*.*?\*\//gs; function es(a) { const t = {}; return a.replace(ts, "").split(Zr).forEach(g => { if (g) { const v = g.split(Qr); v.length > 1 && (t[v[0].trim()] = v[1].trim()) } }), t } function we(a) { let t = ""; if (wt(a)) t = a; else if (ct(a)) for (let g = 0; g < a.length; g++) { const v = we(a[g]); v && (t += v + " ") } else if (yt(a)) for (const g in a) a[g] && (t += g + " "); return t.trim() } const is = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", ns = Hi(is); function Un(a) { return !!a || a === "" } function rs(a, t) { if (a.length !== t.length) return !1; let g = !0; for (let v = 0; g && v < a.length; v++)g = ri(a[v], t[v]); return g } function ri(a, t) { if (a === t) return !0; let g = cn(a), v = cn(t); if (g || v) return g && v ? a.getTime() === t.getTime() : !1; if (g = Fe(a), v = Fe(t), g || v) return a === t; if (g = ct(a), v = ct(t), g || v) return g && v ? rs(a, t) : !1; if (g = yt(a), v = yt(t), g || v) { if (!g || !v) return !1; const _ = Object.keys(a).length, C = Object.keys(t).length; if (_ !== C) return !1; for (const b in a) { const u = a.hasOwnProperty(b), n = t.hasOwnProperty(b); if (u && !n || !u && n || !ri(a[b], t[b])) return !1 } } return String(a) === String(t) } function ss(a, t) { return a.findIndex(g => ri(g, t)) } const Pe = a => wt(a) ? a : a == null ? "" : ct(a) || yt(a) && (a.toString === Kn || !gt(a.toString)) ? JSON.stringify(a, Vn, 2) : String(a), Vn = (a, t) => t && t.__v_isRef ? Vn(a, t.value) : _e(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((g, [v, _]) => (g[`${v} =>`] = _, g), {}) } : oi(t) ? { [`Set(${t.size})`]: [...t.values()] } : yt(t) && !ct(t) && !qn(t) ? String(t) : t, _t = {}, ve = [], Nt = () => { }, os = () => !1, as = /^on[^a-z]/, si = a => as.test(a), zi = a => a.startsWith("onUpdate:"), Et = Object.assign, Yi = (a, t) => { const g = a.indexOf(t); g > -1 && a.splice(g, 1) }, ls = Object.prototype.hasOwnProperty, pt = (a, t) => ls.call(a, t), ct = Array.isArray, _e = a => We(a) === "[object Map]", oi = a => We(a) === "[object Set]", cn = a => We(a) === "[object Date]", gt = a => typeof a == "function", wt = a => typeof a == "string", Fe = a => typeof a == "symbol", yt = a => a !== null && typeof a == "object", Gn = a => yt(a) && gt(a.then) && gt(a.catch), Kn = Object.prototype.toString, We = a => Kn.call(a), hs = a => We(a).slice(8, -1), qn = a => We(a) === "[object Object]", Ni = a => wt(a) && a !== "NaN" && a[0] !== "-" && "" + parseInt(a, 10) === a, Ve = Hi(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), ai = a => { const t = Object.create(null); return g => t[g] || (t[g] = a(g)) }, cs = /-(\w)/g, $t = ai(a => a.replace(cs, (t, g) => g ? g.toUpperCase() : "")), us = /\B([A-Z])/g, Se = ai(a => a.replace(us, "-$1").toLowerCase()), li = ai(a => a.charAt(0).toUpperCase() + a.slice(1)), _i = ai(a => a ? `on${li(a)}` : ""), Ze = (a, t) => !Object.is(a, t), Ge = (a, t) => { for (let g = 0; g < a.length; g++)a[g](t) }, Qe = (a, t, g) => { Object.defineProperty(a, t, { configurable: !0, enumerable: !1, value: g }) }, $n = a => { const t = parseFloat(a); return isNaN(t) ? a : t }; let un; const fs = () => un || (un = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); let Ht; class ds { constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Ht, !t && Ht && (this.index = (Ht.scopes || (Ht.scopes = [])).push(this) - 1) } get active() { return this._active } run(t) { if (this._active) { const g = Ht; try { return Ht = this, t() } finally { Ht = g } } } on() { Ht = this } off() { Ht = this.parent } stop(t) { if (this._active) { let g, v; for (g = 0, v = this.effects.length; g < v; g++)this.effects[g].stop(); for (g = 0, v = this.cleanups.length; g < v; g++)this.cleanups[g](); if (this.scopes) for (g = 0, v = this.scopes.length; g < v; g++)this.scopes[g].stop(!0); if (!this.detached && this.parent && !t) { const _ = this.parent.scopes.pop(); _ && _ !== this && (this.parent.scopes[this.index] = _, _.index = this.index) } this.parent = void 0, this._active = !1 } } } function gs(a, t = Ht) { t && t.active && t.effects.push(a) } function ps() { return Ht } const Ui = a => { const t = new Set(a); return t.w = 0, t.n = 0, t }, Jn = a => (a.w & re) > 0, Zn = a => (a.n & re) > 0, ms = ({ deps: a }) => { if (a.length) for (let t = 0; t < a.length; t++)a[t].w |= re }, vs = a => { const { deps: t } = a; if (t.length) { let g = 0; for (let v = 0; v < t.length; v++) { const _ = t[v]; Jn(_) && !Zn(_) ? _.delete(a) : t[g++] = _, _.w &= ~re, _.n &= ~re } t.length = g } }, Ei = new WeakMap; let Ae = 0, re = 1; const Pi = 30; let zt; const ge = Symbol(""), Ai = Symbol(""); class Vi { constructor(t, g = null, v) { this.fn = t, this.scheduler = g, this.active = !0, this.deps = [], this.parent = void 0, gs(this, v) } run() { if (!this.active) return this.fn(); let t = zt, g = ie; for (; t;) { if (t === this) return; t = t.parent } try { return this.parent = zt, zt = this, ie = !0, re = 1 << ++Ae, Ae <= Pi ? ms(this) : fn(this), this.fn() } finally { Ae <= Pi && vs(this), re = 1 << --Ae, zt = this.parent, ie = g, this.parent = void 0, this.deferStop && this.stop() } } stop() { zt === this ? this.deferStop = !0 : this.active && (fn(this), this.onStop && this.onStop(), this.active = !1) } } function fn(a) { const { deps: t } = a; if (t.length) { for (let g = 0; g < t.length; g++)t[g].delete(a); t.length = 0 } } let ie = !0; const Qn = []; function Te() { Qn.push(ie), ie = !1 } function Oe() { const a = Qn.pop(); ie = a === void 0 ? !0 : a } function Lt(a, t, g) { if (ie && zt) { let v = Ei.get(a); v || Ei.set(a, v = new Map); let _ = v.get(g); _ || v.set(g, _ = Ui()), tr(_) } } function tr(a, t) { let g = !1; Ae <= Pi ? Zn(a) || (a.n |= re, g = !Jn(a)) : g = !a.has(zt), g && (a.add(zt), zt.deps.push(a)) } function Zt(a, t, g, v, _, C) { const b = Ei.get(a); if (!b) return; let u = []; if (t === "clear") u = [...b.values()]; else if (g === "length" && ct(a)) { const n = Number(v); b.forEach((l, h) => { (h === "length" || h >= n) && u.push(l) }) } else switch (g !== void 0 && u.push(b.get(g)), t) { case "add": ct(a) ? Ni(g) && u.push(b.get("length")) : (u.push(b.get(ge)), _e(a) && u.push(b.get(Ai))); break; case "delete": ct(a) || (u.push(b.get(ge)), _e(a) && u.push(b.get(Ai))); break; case "set": _e(a) && u.push(b.get(ge)); break }if (u.length === 1) u[0] && Mi(u[0]); else { const n = []; for (const l of u) l && n.push(...l); Mi(Ui(n)) } } function Mi(a, t) { const g = ct(a) ? a : [...a]; for (const v of g) v.computed && dn(v); for (const v of g) v.computed || dn(v) } function dn(a, t) { (a !== zt || a.allowRecurse) && (a.scheduler ? a.scheduler() : a.run()) } const _s = Hi("__proto__,__v_isRef,__isVue"), er = new Set(Object.getOwnPropertyNames(Symbol).filter(a => a !== "arguments" && a !== "caller").map(a => Symbol[a]).filter(Fe)), ys = Gi(), Cs = Gi(!1, !0), bs = Gi(!0), gn = xs(); function xs() { const a = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(t => { a[t] = function (...g) { const v = mt(this); for (let C = 0, b = this.length; C < b; C++)Lt(v, "get", C + ""); const _ = v[t](...g); return _ === -1 || _ === !1 ? v[t](...g.map(mt)) : _ } }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => { a[t] = function (...g) { Te(); const v = mt(this)[t].apply(this, g); return Oe(), v } }), a } function ws(a) { const t = mt(this); return Lt(t, "has", a), t.hasOwnProperty(a) } function Gi(a = !1, t = !1) { return function (v, _, C) { if (_ === "__v_isReactive") return !a; if (_ === "__v_isReadonly") return a; if (_ === "__v_isShallow") return t; if (_ === "__v_raw" && C === (a ? t ? Ws : or : t ? sr : rr).get(v)) return v; const b = ct(v); if (!a) { if (b && pt(gn, _)) return Reflect.get(gn, _, C); if (_ === "hasOwnProperty") return ws } const u = Reflect.get(v, _, C); return (Fe(_) ? er.has(_) : _s(_)) || (a || Lt(v, "get", _), t) ? u : kt(u) ? b && Ni(_) ? u : u.value : yt(u) ? a ? ar(u) : $i(u) : u } } const Ss = ir(), Ts = ir(!0); function ir(a = !1) { return function (g, v, _, C) { let b = g[v]; if (Le(b) && kt(b) && !kt(_)) return !1; if (!a && (!ki(_) && !Le(_) && (b = mt(b), _ = mt(_)), !ct(g) && kt(b) && !kt(_))) return b.value = _, !0; const u = ct(g) && Ni(v) ? Number(v) < g.length : pt(g, v), n = Reflect.set(g, v, _, C); return g === mt(C) && (u ? Ze(_, b) && Zt(g, "set", v, _) : Zt(g, "add", v, _)), n } } function Os(a, t) { const g = pt(a, t); a[t]; const v = Reflect.deleteProperty(a, t); return v && g && Zt(a, "delete", t, void 0), v } function Es(a, t) { const g = Reflect.has(a, t); return (!Fe(t) || !er.has(t)) && Lt(a, "has", t), g } function Ps(a) { return Lt(a, "iterate", ct(a) ? "length" : ge), Reflect.ownKeys(a) } const nr = { get: ys, set: Ss, deleteProperty: Os, has: Es, ownKeys: Ps }, As = { get: bs, set(a, t) { return !0 }, deleteProperty(a, t) { return !0 } }, Ms = Et({}, nr, { get: Cs, set: Ts }), Ki = a => a, hi = a => Reflect.getPrototypeOf(a); function Xe(a, t, g = !1, v = !1) { a = a.__v_raw; const _ = mt(a), C = mt(t); g || (t !== C && Lt(_, "get", t), Lt(_, "get", C)); const { has: b } = hi(_), u = v ? Ki : g ? Qi : Zi; if (b.call(_, t)) return u(a.get(t)); if (b.call(_, C)) return u(a.get(C)); a !== _ && a.get(t) } function He(a, t = !1) { const g = this.__v_raw, v = mt(g), _ = mt(a); return t || (a !== _ && Lt(v, "has", a), Lt(v, "has", _)), a === _ ? g.has(a) : g.has(a) || g.has(_) } function ze(a, t = !1) { return a = a.__v_raw, !t && Lt(mt(a), "iterate", ge), Reflect.get(a, "size", a) } function pn(a) { a = mt(a); const t = mt(this); return hi(t).has.call(t, a) || (t.add(a), Zt(t, "add", a, a)), this } function mn(a, t) { t = mt(t); const g = mt(this), { has: v, get: _ } = hi(g); let C = v.call(g, a); C || (a = mt(a), C = v.call(g, a)); const b = _.call(g, a); return g.set(a, t), C ? Ze(t, b) && Zt(g, "set", a, t) : Zt(g, "add", a, t), this } function vn(a) { const t = mt(this), { has: g, get: v } = hi(t); let _ = g.call(t, a); _ || (a = mt(a), _ = g.call(t, a)), v && v.call(t, a); const C = t.delete(a); return _ && Zt(t, "delete", a, void 0), C } function _n() { const a = mt(this), t = a.size !== 0, g = a.clear(); return t && Zt(a, "clear", void 0, void 0), g } function Ye(a, t) { return function (v, _) { const C = this, b = C.__v_raw, u = mt(b), n = t ? Ki : a ? Qi : Zi; return !a && Lt(u, "iterate", ge), b.forEach((l, h) => v.call(_, n(l), n(h), C)) } } function Ne(a, t, g) { return function (...v) { const _ = this.__v_raw, C = mt(_), b = _e(C), u = a === "entries" || a === Symbol.iterator && b, n = a === "keys" && b, l = _[a](...v), h = g ? Ki : t ? Qi : Zi; return !t && Lt(C, "iterate", n ? Ai : ge), { next() { const { value: i, done: r } = l.next(); return r ? { value: i, done: r } : { value: u ? [h(i[0]), h(i[1])] : h(i), done: r } }, [Symbol.iterator]() { return this } } } } function te(a) { return function (...t) { return a === "delete" ? !1 : this } } function ks() { const a = { get(C) { return Xe(this, C) }, get size() { return ze(this) }, has: He, add: pn, set: mn, delete: vn, clear: _n, forEach: Ye(!1, !1) }, t = { get(C) { return Xe(this, C, !1, !0) }, get size() { return ze(this) }, has: He, add: pn, set: mn, delete: vn, clear: _n, forEach: Ye(!1, !0) }, g = { get(C) { return Xe(this, C, !0) }, get size() { return ze(this, !0) }, has(C) { return He.call(this, C, !0) }, add: te("add"), set: te("set"), delete: te("delete"), clear: te("clear"), forEach: Ye(!0, !1) }, v = { get(C) { return Xe(this, C, !0, !0) }, get size() { return ze(this, !0) }, has(C) { return He.call(this, C, !0) }, add: te("add"), set: te("set"), delete: te("delete"), clear: te("clear"), forEach: Ye(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(C => { a[C] = Ne(C, !1, !1), g[C] = Ne(C, !0, !1), t[C] = Ne(C, !1, !0), v[C] = Ne(C, !0, !0) }), [a, g, t, v] } const [Ds, Fs, Ls, Is] = ks(); function qi(a, t) { const g = t ? a ? Is : Ls : a ? Fs : Ds; return (v, _, C) => _ === "__v_isReactive" ? !a : _ === "__v_isReadonly" ? a : _ === "__v_raw" ? v : Reflect.get(pt(g, _) && _ in v ? g : v, _, C) } const js = { get: qi(!1, !1) }, Rs = { get: qi(!1, !0) }, Bs = { get: qi(!0, !1) }, rr = new WeakMap, sr = new WeakMap, or = new WeakMap, Ws = new WeakMap; function Xs(a) { switch (a) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function Hs(a) { return a.__v_skip || !Object.isExtensible(a) ? 0 : Xs(hs(a)) } function $i(a) { return Le(a) ? a : Ji(a, !1, nr, js, rr) } function zs(a) { return Ji(a, !1, Ms, Rs, sr) } function ar(a) { return Ji(a, !0, As, Bs, or) } function Ji(a, t, g, v, _) { if (!yt(a) || a.__v_raw && !(t && a.__v_isReactive)) return a; const C = _.get(a); if (C) return C; const b = Hs(a); if (b === 0) return a; const u = new Proxy(a, b === 2 ? v : g); return _.set(a, u), u } function ye(a) { return Le(a) ? ye(a.__v_raw) : !!(a && a.__v_isReactive) } function Le(a) { return !!(a && a.__v_isReadonly) } function ki(a) { return !!(a && a.__v_isShallow) } function lr(a) { return ye(a) || Le(a) } function mt(a) { const t = a && a.__v_raw; return t ? mt(t) : a } function hr(a) { return Qe(a, "__v_skip", !0), a } const Zi = a => yt(a) ? $i(a) : a, Qi = a => yt(a) ? ar(a) : a; function Ys(a) { ie && zt && (a = mt(a), tr(a.dep || (a.dep = Ui()))) } function Ns(a, t) { a = mt(a); const g = a.dep; g && Mi(g) } function kt(a) { return !!(a && a.__v_isRef === !0) } function Us(a) { return kt(a) ? a.value : a } const Vs = { get: (a, t, g) => Us(Reflect.get(a, t, g)), set: (a, t, g, v) => { const _ = a[t]; return kt(_) && !kt(g) ? (_.value = g, !0) : Reflect.set(a, t, g, v) } }; function cr(a) { return ye(a) ? a : new Proxy(a, Vs) } var ur; class Gs { constructor(t, g, v, _) { this._setter = g, this.dep = void 0, this.__v_isRef = !0, this[ur] = !1, this._dirty = !0, this.effect = new Vi(t, () => { this._dirty || (this._dirty = !0, Ns(this)) }), this.effect.computed = this, this.effect.active = this._cacheable = !_, this.__v_isReadonly = v } get value() { const t = mt(this); return Ys(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value } set value(t) { this._setter(t) } } ur = "__v_isReadonly"; function Ks(a, t, g = !1) { let v, _; const C = gt(a); return C ? (v = a, _ = Nt) : (v = a.get, _ = a.set), new Gs(v, _, C || !_, g) } function ne(a, t, g, v) { let _; try { _ = v ? a(...v) : a() } catch (C) { ci(C, t, g) } return _ } function Xt(a, t, g, v) { if (gt(a)) { const C = ne(a, t, g, v); return C && Gn(C) && C.catch(b => { ci(b, t, g) }), C } const _ = []; for (let C = 0; C < a.length; C++)_.push(Xt(a[C], t, g, v)); return _ } function ci(a, t, g, v = !0) { const _ = t ? t.vnode : null; if (t) { let C = t.parent; const b = t.proxy, u = g; for (; C;) { const l = C.ec; if (l) { for (let h = 0; h < l.length; h++)if (l[h](a, b, u) === !1) return } C = C.parent } const n = t.appContext.config.errorHandler; if (n) { ne(n, null, 10, [a, b, u]); return } } qs(a, g, _, v) } function qs(a, t, g, v = !0) { console.error(a) } let Ie = !1, Di = !1; const Ot = []; let qt = 0; const Ce = []; let Jt = null, ce = 0; const fr = Promise.resolve(); let tn = null; function $s(a) { const t = tn || fr; return a ? t.then(this ? a.bind(this) : a) : t } function Js(a) { let t = qt + 1, g = Ot.length; for (; t < g;) { const v = t + g >>> 1; je(Ot[v]) < a ? t = v + 1 : g = v } return t } function en(a) { (!Ot.length || !Ot.includes(a, Ie && a.allowRecurse ? qt + 1 : qt)) && (a.id == null ? Ot.push(a) : Ot.splice(Js(a.id), 0, a), dr()) } function dr() { !Ie && !Di && (Di = !0, tn = fr.then(pr)) } function Zs(a) { const t = Ot.indexOf(a); t > qt && Ot.splice(t, 1) } function Qs(a) { ct(a) ? Ce.push(...a) : (!Jt || !Jt.includes(a, a.allowRecurse ? ce + 1 : ce)) && Ce.push(a), dr() } function yn(a, t = Ie ? qt + 1 : 0) { for (; t < Ot.length; t++) { const g = Ot[t]; g && g.pre && (Ot.splice(t, 1), t--, g()) } } function gr(a) { if (Ce.length) { const t = [...new Set(Ce)]; if (Ce.length = 0, Jt) { Jt.push(...t); return } for (Jt = t, Jt.sort((g, v) => je(g) - je(v)), ce = 0; ce < Jt.length; ce++)Jt[ce](); Jt = null, ce = 0 } } const je = a => a.id == null ? 1 / 0 : a.id, to = (a, t) => { const g = je(a) - je(t); if (g === 0) { if (a.pre && !t.pre) return -1; if (t.pre && !a.pre) return 1 } return g }; function pr(a) { Di = !1, Ie = !0, Ot.sort(to); const t = Nt; try { for (qt = 0; qt < Ot.length; qt++) { const g = Ot[qt]; g && g.active !== !1 && ne(g, null, 14) } } finally { qt = 0, Ot.length = 0, gr(), Ie = !1, tn = null, (Ot.length || Ce.length) && pr() } } function eo(a, t, ...g) { if (a.isUnmounted) return; const v = a.vnode.props || _t; let _ = g; const C = t.startsWith("update:"), b = C && t.slice(7); if (b && b in v) { const h = `${b === "modelValue" ? "model" : b}Modifiers`, { number: i, trim: r } = v[h] || _t; r && (_ = g.map(e => wt(e) ? e.trim() : e)), i && (_ = g.map($n)) } let u, n = v[u = _i(t)] || v[u = _i($t(t))]; !n && C && (n = v[u = _i(Se(t))]), n && Xt(n, a, 6, _); const l = v[u + "Once"]; if (l) { if (!a.emitted) a.emitted = {}; else if (a.emitted[u]) return; a.emitted[u] = !0, Xt(l, a, 6, _) } } function mr(a, t, g = !1) { const v = t.emitsCache, _ = v.get(a); if (_ !== void 0) return _; const C = a.emits; let b = {}, u = !1; if (!gt(a)) { const n = l => { const h = mr(l, t, !0); h && (u = !0, Et(b, h)) }; !g && t.mixins.length && t.mixins.forEach(n), a.extends && n(a.extends), a.mixins && a.mixins.forEach(n) } return !C && !u ? (yt(a) && v.set(a, null), null) : (ct(C) ? C.forEach(n => b[n] = null) : Et(b, C), yt(a) && v.set(a, b), b) } function ui(a, t) { return !a || !si(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), pt(a, t[0].toLowerCase() + t.slice(1)) || pt(a, Se(t)) || pt(a, t)) } let jt = null, vr = null; function ti(a) { const t = jt; return jt = a, vr = a && a.type.__scopeId || null, t } function io(a, t = jt, g) { if (!t || a._n) return a; const v = (..._) => { v._d && Mn(-1); const C = ti(t); let b; try { b = a(..._) } finally { ti(C), v._d && Mn(1) } return b }; return v._n = !0, v._c = !0, v._d = !0, v } function yi(a) { const { type: t, vnode: g, proxy: v, withProxy: _, props: C, propsOptions: [b], slots: u, attrs: n, emit: l, render: h, renderCache: i, data: r, setupState: e, ctx: o, inheritAttrs: c } = a; let s, f; const d = ti(a); try { if (g.shapeFlag & 4) { const m = _ || v; s = Kt(h.call(m, m, i, C, e, r, o)), f = n } else { const m = t; s = Kt(m.length > 1 ? m(C, { attrs: n, slots: u, emit: l }) : m(C, null)), f = t.props ? n : no(n) } } catch (m) { ke.length = 0, ci(m, a, 1), s = Vt(Ut) } let p = s; if (f && c !== !1) { const m = Object.keys(f), { shapeFlag: y } = p; m.length && y & 7 && (b && m.some(zi) && (f = ro(f, b)), p = se(p, f)) } return g.dirs && (p = se(p), p.dirs = p.dirs ? p.dirs.concat(g.dirs) : g.dirs), g.transition && (p.transition = g.transition), s = p, ti(d), s } const no = a => { let t; for (const g in a) (g === "class" || g === "style" || si(g)) && ((t || (t = {}))[g] = a[g]); return t }, ro = (a, t) => { const g = {}; for (const v in a) (!zi(v) || !(v.slice(9) in t)) && (g[v] = a[v]); return g }; function so(a, t, g) { const { props: v, children: _, component: C } = a, { props: b, children: u, patchFlag: n } = t, l = C.emitsOptions; if (t.dirs || t.transition) return !0; if (g && n >= 0) { if (n & 1024) return !0; if (n & 16) return v ? Cn(v, b, l) : !!b; if (n & 8) { const h = t.dynamicProps; for (let i = 0; i < h.length; i++) { const r = h[i]; if (b[r] !== v[r] && !ui(l, r)) return !0 } } } else return (_ || u) && (!u || !u.$stable) ? !0 : v === b ? !1 : v ? b ? Cn(v, b, l) : !0 : !!b; return !1 } function Cn(a, t, g) { const v = Object.keys(t); if (v.length !== Object.keys(a).length) return !0; for (let _ = 0; _ < v.length; _++) { const C = v[_]; if (t[C] !== a[C] && !ui(g, C)) return !0 } return !1 } function oo({ vnode: a, parent: t }, g) { for (; t && t.subTree === a;)(a = t.vnode).el = g, t = t.parent } const ao = a => a.__isSuspense; function lo(a, t) { t && t.pendingBranch ? ct(a) ? t.effects.push(...a) : t.effects.push(a) : Qs(a) } function ho(a, t) { if (bt) { let g = bt.provides; const v = bt.parent && bt.parent.provides; v === g && (g = bt.provides = Object.create(v)), g[a] = t } } function Ke(a, t, g = !1) { const v = bt || jt; if (v) { const _ = v.parent == null ? v.vnode.appContext && v.vnode.appContext.provides : v.parent.provides; if (_ && a in _) return _[a]; if (arguments.length > 1) return g && gt(t) ? t.call(v.proxy) : t } } const Ue = {}; function Ci(a, t, g) { return _r(a, t, g) } function _r(a, t, { immediate: g, deep: v, flush: _, onTrack: C, onTrigger: b } = _t) { const u = ps() === (bt == null ? void 0 : bt.scope) ? bt : null; let n, l = !1, h = !1; if (kt(a) ? (n = () => a.value, l = ki(a)) : ye(a) ? (n = () => a, v = !0) : ct(a) ? (h = !0, l = a.some(p => ye(p) || ki(p)), n = () => a.map(p => { if (kt(p)) return p.value; if (ye(p)) return de(p); if (gt(p)) return ne(p, u, 2) })) : gt(a) ? t ? n = () => ne(a, u, 2) : n = () => { if (!(u && u.isUnmounted)) return i && i(), Xt(a, u, 3, [r]) } : n = Nt, t && v) { const p = n; n = () => de(p()) } let i, r = p => { i = f.onStop = () => { ne(p, u, 4) } }, e; if (Be) if (r = Nt, t ? g && Xt(t, u, 3, [n(), h ? [] : void 0, r]) : n(), _ === "sync") { const p = ha(); e = p.__watcherHandles || (p.__watcherHandles = []) } else return Nt; let o = h ? new Array(a.length).fill(Ue) : Ue; const c = () => { if (f.active) if (t) { const p = f.run(); (v || l || (h ? p.some((m, y) => Ze(m, o[y])) : Ze(p, o))) && (i && i(), Xt(t, u, 3, [p, o === Ue ? void 0 : h && o[0] === Ue ? [] : o, r]), o = p) } else f.run() }; c.allowRecurse = !!t; let s; _ === "sync" ? s = c : _ === "post" ? s = () => Dt(c, u && u.suspense) : (c.pre = !0, u && (c.id = u.uid), s = () => en(c)); const f = new Vi(n, s); t ? g ? c() : o = f.run() : _ === "post" ? Dt(f.run.bind(f), u && u.suspense) : f.run(); const d = () => { f.stop(), u && u.scope && Yi(u.scope.effects, f) }; return e && e.push(d), d } function co(a, t, g) { const v = this.proxy, _ = wt(a) ? a.includes(".") ? yr(v, a) : () => v[a] : a.bind(v, v); let C; gt(t) ? C = t : (C = t.handler, g = t); const b = bt; xe(this); const u = _r(_, C.bind(v), g); return b ? xe(b) : pe(), u } function yr(a, t) { const g = t.split("."); return () => { let v = a; for (let _ = 0; _ < g.length && v; _++)v = v[g[_]]; return v } } function de(a, t) { if (!yt(a) || a.__v_skip || (t = t || new Set, t.has(a))) return a; if (t.add(a), kt(a)) de(a.value, t); else if (ct(a)) for (let g = 0; g < a.length; g++)de(a[g], t); else if (oi(a) || _e(a)) a.forEach(g => { de(g, t) }); else if (qn(a)) for (const g in a) de(a[g], t); return a } function uo() { const a = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return wr(() => { a.isMounted = !0 }), Sr(() => { a.isUnmounting = !0 }), a } const Wt = [Function, Array], fo = { name: "BaseTransition", props: { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: Wt, onEnter: Wt, onAfterEnter: Wt, onEnterCancelled: Wt, onBeforeLeave: Wt, onLeave: Wt, onAfterLeave: Wt, onLeaveCancelled: Wt, onBeforeAppear: Wt, onAppear: Wt, onAfterAppear: Wt, onAppearCancelled: Wt }, setup(a, { slots: t }) { const g = ta(), v = uo(); let _; return () => { const C = t.default && br(t.default(), !0); if (!C || !C.length) return; let b = C[0]; if (C.length > 1) { for (const c of C) if (c.type !== Ut) { b = c; break } } const u = mt(a), { mode: n } = u; if (v.isLeaving) return bi(b); const l = bn(b); if (!l) return bi(b); const h = Fi(l, u, v, g); Li(l, h); const i = g.subTree, r = i && bn(i); let e = !1; const { getTransitionKey: o } = l.type; if (o) { const c = o(); _ === void 0 ? _ = c : c !== _ && (_ = c, e = !0) } if (r && r.type !== Ut && (!ue(l, r) || e)) { const c = Fi(r, u, v, g); if (Li(r, c), n === "out-in") return v.isLeaving = !0, c.afterLeave = () => { v.isLeaving = !1, g.update.active !== !1 && g.update() }, bi(b); n === "in-out" && l.type !== Ut && (c.delayLeave = (s, f, d) => { const p = Cr(v, r); p[String(r.key)] = r, s._leaveCb = () => { f(), s._leaveCb = void 0, delete h.delayedLeave }, h.delayedLeave = d }) } return b } } }, go = fo; function Cr(a, t) { const { leavingVNodes: g } = a; let v = g.get(t.type); return v || (v = Object.create(null), g.set(t.type, v)), v } function Fi(a, t, g, v) { const { appear: _, mode: C, persisted: b = !1, onBeforeEnter: u, onEnter: n, onAfterEnter: l, onEnterCancelled: h, onBeforeLeave: i, onLeave: r, onAfterLeave: e, onLeaveCancelled: o, onBeforeAppear: c, onAppear: s, onAfterAppear: f, onAppearCancelled: d } = t, p = String(a.key), m = Cr(g, a), y = (D, Y) => { D && Xt(D, v, 9, Y) }, x = (D, Y) => { const V = Y[1]; y(D, Y), ct(D) ? D.every(J => J.length <= 1) && V() : D.length <= 1 && V() }, P = { mode: C, persisted: b, beforeEnter(D) { let Y = u; if (!g.isMounted) if (_) Y = c || u; else return; D._leaveCb && D._leaveCb(!0); const V = m[p]; V && ue(a, V) && V.el._leaveCb && V.el._leaveCb(), y(Y, [D]) }, enter(D) { let Y = n, V = l, J = h; if (!g.isMounted) if (_) Y = s || n, V = f || l, J = d || h; else return; let Q = !1; const rt = D._enterCb = tt => { Q || (Q = !0, tt ? y(J, [D]) : y(V, [D]), P.delayedLeave && P.delayedLeave(), D._enterCb = void 0) }; Y ? x(Y, [D, rt]) : rt() }, leave(D, Y) { const V = String(a.key); if (D._enterCb && D._enterCb(!0), g.isUnmounting) return Y(); y(i, [D]); let J = !1; const Q = D._leaveCb = rt => { J || (J = !0, Y(), rt ? y(o, [D]) : y(e, [D]), D._leaveCb = void 0, m[V] === a && delete m[V]) }; m[V] = a, r ? x(r, [D, Q]) : Q() }, clone(D) { return Fi(D, t, g, v) } }; return P } function bi(a) { if (fi(a)) return a = se(a), a.children = null, a } function bn(a) { return fi(a) ? a.children ? a.children[0] : void 0 : a } function Li(a, t) { a.shapeFlag & 6 && a.component ? Li(a.component.subTree, t) : a.shapeFlag & 128 ? (a.ssContent.transition = t.clone(a.ssContent), a.ssFallback.transition = t.clone(a.ssFallback)) : a.transition = t } function br(a, t = !1, g) { let v = [], _ = 0; for (let C = 0; C < a.length; C++) { let b = a[C]; const u = g == null ? b.key : String(g) + String(b.key != null ? b.key : C); b.type === Ft ? (b.patchFlag & 128 && _++, v = v.concat(br(b.children, t, u))) : (t || b.type !== Ut) && v.push(u != null ? se(b, { key: u }) : b) } if (_ > 1) for (let C = 0; C < v.length; C++)v[C].patchFlag = -2; return v } const qe = a => !!a.type.__asyncLoader, fi = a => a.type.__isKeepAlive; function po(a, t) { xr(a, "a", t) } function mo(a, t) { xr(a, "da", t) } function xr(a, t, g = bt) { const v = a.__wdc || (a.__wdc = () => { let _ = g; for (; _;) { if (_.isDeactivated) return; _ = _.parent } return a() }); if (di(t, v, g), g) { let _ = g.parent; for (; _ && _.parent;)fi(_.parent.vnode) && vo(v, t, g, _), _ = _.parent } } function vo(a, t, g, v) { const _ = di(t, a, v, !0); Tr(() => { Yi(v[t], _) }, g) } function di(a, t, g = bt, v = !1) { if (g) { const _ = g[a] || (g[a] = []), C = t.__weh || (t.__weh = (...b) => { if (g.isUnmounted) return; Te(), xe(g); const u = Xt(t, g, a, b); return pe(), Oe(), u }); return v ? _.unshift(C) : _.push(C), C } } const Qt = a => (t, g = bt) => (!Be || a === "sp") && di(a, (...v) => t(...v), g), _o = Qt("bm"), wr = Qt("m"), yo = Qt("bu"), Co = Qt("u"), Sr = Qt("bum"), Tr = Qt("um"), bo = Qt("sp"), xo = Qt("rtg"), wo = Qt("rtc"); function So(a, t = bt) { di("ec", a, t) } function To(a, t) { const g = jt; if (g === null) return a; const v = mi(g) || g.proxy, _ = a.dirs || (a.dirs = []); for (let C = 0; C < t.length; C++) { let [b, u, n, l = _t] = t[C]; b && (gt(b) && (b = { mounted: b, updated: b }), b.deep && de(u), _.push({ dir: b, instance: v, value: u, oldValue: void 0, arg: n, modifiers: l })) } return a } function ae(a, t, g, v) { const _ = a.dirs, C = t && t.dirs; for (let b = 0; b < _.length; b++) { const u = _[b]; C && (u.oldValue = C[b].value); let n = u.dir[v]; n && (Te(), Xt(n, g, 8, [a.el, u, a, t]), Oe()) } } const Or = "components"; function xn(a, t) { return Eo(Or, a, !0, t) || a } const Oo = Symbol(); function Eo(a, t, g = !0, v = !1) { const _ = jt || bt; if (_) { const C = _.type; if (a === Or) { const u = sa(C, !1); if (u && (u === t || u === $t(t) || u === li($t(t)))) return C } const b = wn(_[a] || C[a], t) || wn(_.appContext[a], t); return !b && v ? C : b } } function wn(a, t) { return a && (a[t] || a[$t(t)] || a[li($t(t))]) } function nn(a, t, g, v) { let _; const C = g && g[v]; if (ct(a) || wt(a)) { _ = new Array(a.length); for (let b = 0, u = a.length; b < u; b++)_[b] = t(a[b], b, void 0, C && C[b]) } else if (typeof a == "number") { _ = new Array(a); for (let b = 0; b < a; b++)_[b] = t(b + 1, b, void 0, C && C[b]) } else if (yt(a)) if (a[Symbol.iterator]) _ = Array.from(a, (b, u) => t(b, u, void 0, C && C[u])); else { const b = Object.keys(a); _ = new Array(b.length); for (let u = 0, n = b.length; u < n; u++) { const l = b[u]; _[u] = t(a[l], l, u, C && C[u]) } } else _ = []; return g && (g[v] = _), _ } const Ii = a => a ? Br(a) ? mi(a) || a.proxy : Ii(a.parent) : null, Me = Et(Object.create(null), { $: a => a, $el: a => a.vnode.el, $data: a => a.data, $props: a => a.props, $attrs: a => a.attrs, $slots: a => a.slots, $refs: a => a.refs, $parent: a => Ii(a.parent), $root: a => Ii(a.root), $emit: a => a.emit, $options: a => rn(a), $forceUpdate: a => a.f || (a.f = () => en(a.update)), $nextTick: a => a.n || (a.n = $s.bind(a.proxy)), $watch: a => co.bind(a) }), xi = (a, t) => a !== _t && !a.__isScriptSetup && pt(a, t), Po = { get({ _: a }, t) { const { ctx: g, setupState: v, data: _, props: C, accessCache: b, type: u, appContext: n } = a; let l; if (t[0] !== "$") { const e = b[t]; if (e !== void 0) switch (e) { case 1: return v[t]; case 2: return _[t]; case 4: return g[t]; case 3: return C[t] } else { if (xi(v, t)) return b[t] = 1, v[t]; if (_ !== _t && pt(_, t)) return b[t] = 2, _[t]; if ((l = a.propsOptions[0]) && pt(l, t)) return b[t] = 3, C[t]; if (g !== _t && pt(g, t)) return b[t] = 4, g[t]; ji && (b[t] = 0) } } const h = Me[t]; let i, r; if (h) return t === "$attrs" && Lt(a, "get", t), h(a); if ((i = u.__cssModules) && (i = i[t])) return i; if (g !== _t && pt(g, t)) return b[t] = 4, g[t]; if (r = n.config.globalProperties, pt(r, t)) return r[t] }, set({ _: a }, t, g) { const { data: v, setupState: _, ctx: C } = a; return xi(_, t) ? (_[t] = g, !0) : v !== _t && pt(v, t) ? (v[t] = g, !0) : pt(a.props, t) || t[0] === "$" && t.slice(1) in a ? !1 : (C[t] = g, !0) }, has({ _: { data: a, setupState: t, accessCache: g, ctx: v, appContext: _, propsOptions: C } }, b) { let u; return !!g[b] || a !== _t && pt(a, b) || xi(t, b) || (u = C[0]) && pt(u, b) || pt(v, b) || pt(Me, b) || pt(_.config.globalProperties, b) }, defineProperty(a, t, g) { return g.get != null ? a._.accessCache[t] = 0 : pt(g, "value") && this.set(a, t, g.value, null), Reflect.defineProperty(a, t, g) } }; let ji = !0; function Ao(a) { const t = rn(a), g = a.proxy, v = a.ctx; ji = !1, t.beforeCreate && Sn(t.beforeCreate, a, "bc"); const { data: _, computed: C, methods: b, watch: u, provide: n, inject: l, created: h, beforeMount: i, mounted: r, beforeUpdate: e, updated: o, activated: c, deactivated: s, beforeDestroy: f, beforeUnmount: d, destroyed: p, unmounted: m, render: y, renderTracked: x, renderTriggered: P, errorCaptured: D, serverPrefetch: Y, expose: V, inheritAttrs: J, components: Q, directives: rt, filters: tt } = t; if (l && Mo(l, v, null, a.appContext.config.unwrapInjectedRef), b) for (const st in b) { const nt = b[st]; gt(nt) && (v[st] = nt.bind(g)) } if (_) { const st = _.call(g, g); yt(st) && (a.data = $i(st)) } if (ji = !0, C) for (const st in C) { const nt = C[st], w = gt(nt) ? nt.bind(g, g) : gt(nt.get) ? nt.get.bind(g, g) : Nt, F = !gt(nt) && gt(nt.set) ? nt.set.bind(g) : Nt, k = aa({ get: w, set: F }); Object.defineProperty(v, st, { enumerable: !0, configurable: !0, get: () => k.value, set: A => k.value = A }) } if (u) for (const st in u) Er(u[st], v, g, st); if (n) { const st = gt(n) ? n.call(g) : n; Reflect.ownKeys(st).forEach(nt => { ho(nt, st[nt]) }) } h && Sn(h, a, "c"); function ot(st, nt) { ct(nt) ? nt.forEach(w => st(w.bind(g))) : nt && st(nt.bind(g)) } if (ot(_o, i), ot(wr, r), ot(yo, e), ot(Co, o), ot(po, c), ot(mo, s), ot(So, D), ot(wo, x), ot(xo, P), ot(Sr, d), ot(Tr, m), ot(bo, Y), ct(V)) if (V.length) { const st = a.exposed || (a.exposed = {}); V.forEach(nt => { Object.defineProperty(st, nt, { get: () => g[nt], set: w => g[nt] = w }) }) } else a.exposed || (a.exposed = {}); y && a.render === Nt && (a.render = y), J != null && (a.inheritAttrs = J), Q && (a.components = Q), rt && (a.directives = rt) } function Mo(a, t, g = Nt, v = !1) { ct(a) && (a = Ri(a)); for (const _ in a) { const C = a[_]; let b; yt(C) ? "default" in C ? b = Ke(C.from || _, C.default, !0) : b = Ke(C.from || _) : b = Ke(C), kt(b) && v ? Object.defineProperty(t, _, { enumerable: !0, configurable: !0, get: () => b.value, set: u => b.value = u }) : t[_] = b } } function Sn(a, t, g) { Xt(ct(a) ? a.map(v => v.bind(t.proxy)) : a.bind(t.proxy), t, g) } function Er(a, t, g, v) { const _ = v.includes(".") ? yr(g, v) : () => g[v]; if (wt(a)) { const C = t[a]; gt(C) && Ci(_, C) } else if (gt(a)) Ci(_, a.bind(g)); else if (yt(a)) if (ct(a)) a.forEach(C => Er(C, t, g, v)); else { const C = gt(a.handler) ? a.handler.bind(g) : t[a.handler]; gt(C) && Ci(_, C, a) } } function rn(a) { const t = a.type, { mixins: g, extends: v } = t, { mixins: _, optionsCache: C, config: { optionMergeStrategies: b } } = a.appContext, u = C.get(t); let n; return u ? n = u : !_.length && !g && !v ? n = t : (n = {}, _.length && _.forEach(l => ei(n, l, b, !0)), ei(n, t, b)), yt(t) && C.set(t, n), n } function ei(a, t, g, v = !1) { const { mixins: _, extends: C } = t; C && ei(a, C, g, !0), _ && _.forEach(b => ei(a, b, g, !0)); for (const b in t) if (!(v && b === "expose")) { const u = ko[b] || g && g[b]; a[b] = u ? u(a[b], t[b]) : t[b] } return a } const ko = { data: Tn, props: he, emits: he, methods: he, computed: he, beforeCreate: At, created: At, beforeMount: At, mounted: At, beforeUpdate: At, updated: At, beforeDestroy: At, beforeUnmount: At, destroyed: At, unmounted: At, activated: At, deactivated: At, errorCaptured: At, serverPrefetch: At, components: he, directives: he, watch: Fo, provide: Tn, inject: Do }; function Tn(a, t) { return t ? a ? function () { return Et(gt(a) ? a.call(this, this) : a, gt(t) ? t.call(this, this) : t) } : t : a } function Do(a, t) { return he(Ri(a), Ri(t)) } function Ri(a) { if (ct(a)) { const t = {}; for (let g = 0; g < a.length; g++)t[a[g]] = a[g]; return t } return a } function At(a, t) { return a ? [...new Set([].concat(a, t))] : t } function he(a, t) { return a ? Et(Et(Object.create(null), a), t) : t } function Fo(a, t) { if (!a) return t; if (!t) return a; const g = Et(Object.create(null), a); for (const v in t) g[v] = At(a[v], t[v]); return g } function Lo(a, t, g, v = !1) { const _ = {}, C = {}; Qe(C, pi, 1), a.propsDefaults = Object.create(null), Pr(a, t, _, C); for (const b in a.propsOptions[0]) b in _ || (_[b] = void 0); g ? a.props = v ? _ : zs(_) : a.type.props ? a.props = _ : a.props = C, a.attrs = C } function Io(a, t, g, v) { const { props: _, attrs: C, vnode: { patchFlag: b } } = a, u = mt(_), [n] = a.propsOptions; let l = !1; if ((v || b > 0) && !(b & 16)) { if (b & 8) { const h = a.vnode.dynamicProps; for (let i = 0; i < h.length; i++) { let r = h[i]; if (ui(a.emitsOptions, r)) continue; const e = t[r]; if (n) if (pt(C, r)) e !== C[r] && (C[r] = e, l = !0); else { const o = $t(r); _[o] = Bi(n, u, o, e, a, !1) } else e !== C[r] && (C[r] = e, l = !0) } } } else { Pr(a, t, _, C) && (l = !0); let h; for (const i in u) (!t || !pt(t, i) && ((h = Se(i)) === i || !pt(t, h))) && (n ? g && (g[i] !== void 0 || g[h] !== void 0) && (_[i] = Bi(n, u, i, void 0, a, !0)) : delete _[i]); if (C !== u) for (const i in C) (!t || !pt(t, i)) && (delete C[i], l = !0) } l && Zt(a, "set", "$attrs") } function Pr(a, t, g, v) { const [_, C] = a.propsOptions; let b = !1, u; if (t) for (let n in t) { if (Ve(n)) continue; const l = t[n]; let h; _ && pt(_, h = $t(n)) ? !C || !C.includes(h) ? g[h] = l : (u || (u = {}))[h] = l : ui(a.emitsOptions, n) || (!(n in v) || l !== v[n]) && (v[n] = l, b = !0) } if (C) { const n = mt(g), l = u || _t; for (let h = 0; h < C.length; h++) { const i = C[h]; g[i] = Bi(_, n, i, l[i], a, !pt(l, i)) } } return b } function Bi(a, t, g, v, _, C) { const b = a[g]; if (b != null) { const u = pt(b, "default"); if (u && v === void 0) { const n = b.default; if (b.type !== Function && gt(n)) { const { propsDefaults: l } = _; g in l ? v = l[g] : (xe(_), v = l[g] = n.call(null, t), pe()) } else v = n } b[0] && (C && !u ? v = !1 : b[1] && (v === "" || v === Se(g)) && (v = !0)) } return v } function Ar(a, t, g = !1) { const v = t.propsCache, _ = v.get(a); if (_) return _; const C = a.props, b = {}, u = []; let n = !1; if (!gt(a)) { const h = i => { n = !0; const [r, e] = Ar(i, t, !0); Et(b, r), e && u.push(...e) }; !g && t.mixins.length && t.mixins.forEach(h), a.extends && h(a.extends), a.mixins && a.mixins.forEach(h) } if (!C && !n) return yt(a) && v.set(a, ve), ve; if (ct(C)) for (let h = 0; h < C.length; h++) { const i = $t(C[h]); On(i) && (b[i] = _t) } else if (C) for (const h in C) { const i = $t(h); if (On(i)) { const r = C[h], e = b[i] = ct(r) || gt(r) ? { type: r } : Object.assign({}, r); if (e) { const o = An(Boolean, e.type), c = An(String, e.type); e[0] = o > -1, e[1] = c < 0 || o < c, (o > -1 || pt(e, "default")) && u.push(i) } } } const l = [b, u]; return yt(a) && v.set(a, l), l } function On(a) { return a[0] !== "$" } function En(a) { const t = a && a.toString().match(/^\s*(function|class) (\w+)/); return t ? t[2] : a === null ? "null" : "" } function Pn(a, t) { return En(a) === En(t) } function An(a, t) { return ct(t) ? t.findIndex(g => Pn(g, a)) : gt(t) && Pn(t, a) ? 0 : -1 } const Mr = a => a[0] === "_" || a === "$stable", sn = a => ct(a) ? a.map(Kt) : [Kt(a)], jo = (a, t, g) => { if (t._n) return t; const v = io((..._) => sn(t(..._)), g); return v._c = !1, v }, kr = (a, t, g) => { const v = a._ctx; for (const _ in a) { if (Mr(_)) continue; const C = a[_]; if (gt(C)) t[_] = jo(_, C, v); else if (C != null) { const b = sn(C); t[_] = () => b } } }, Dr = (a, t) => { const g = sn(t); a.slots.default = () => g }, Ro = (a, t) => { if (a.vnode.shapeFlag & 32) { const g = t._; g ? (a.slots = mt(t), Qe(t, "_", g)) : kr(t, a.slots = {}) } else a.slots = {}, t && Dr(a, t); Qe(a.slots, pi, 1) }, Bo = (a, t, g) => { const { vnode: v, slots: _ } = a; let C = !0, b = _t; if (v.shapeFlag & 32) { const u = t._; u ? g && u === 1 ? C = !1 : (Et(_, t), !g && u === 1 && delete _._) : (C = !t.$stable, kr(t, _)), b = t } else t && (Dr(a, t), b = { default: 1 }); if (C) for (const u in _) !Mr(u) && !(u in b) && delete _[u] }; function Fr() { return { app: null, config: { isNativeTag: os, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let Wo = 0; function Xo(a, t) { return function (v, _ = null) { gt(v) || (v = Object.assign({}, v)), _ != null && !yt(_) && (_ = null); const C = Fr(), b = new Set; let u = !1; const n = C.app = { _uid: Wo++, _component: v, _props: _, _container: null, _context: C, _instance: null, version: ca, get config() { return C.config }, set config(l) { }, use(l, ...h) { return b.has(l) || (l && gt(l.install) ? (b.add(l), l.install(n, ...h)) : gt(l) && (b.add(l), l(n, ...h))), n }, mixin(l) { return C.mixins.includes(l) || C.mixins.push(l), n }, component(l, h) { return h ? (C.components[l] = h, n) : C.components[l] }, directive(l, h) { return h ? (C.directives[l] = h, n) : C.directives[l] }, mount(l, h, i) { if (!u) { const r = Vt(v, _); return r.appContext = C, h && t ? t(r, l) : a(r, l, i), u = !0, n._container = l, l.__vue_app__ = n, mi(r.component) || r.component.proxy } }, unmount() { u && (a(null, n._container), delete n._container.__vue_app__) }, provide(l, h) { return C.provides[l] = h, n } }; return n } } function Wi(a, t, g, v, _ = !1) { if (ct(a)) { a.forEach((r, e) => Wi(r, t && (ct(t) ? t[e] : t), g, v, _)); return } if (qe(v) && !_) return; const C = v.shapeFlag & 4 ? mi(v.component) || v.component.proxy : v.el, b = _ ? null : C, { i: u, r: n } = a, l = t && t.r, h = u.refs === _t ? u.refs = {} : u.refs, i = u.setupState; if (l != null && l !== n && (wt(l) ? (h[l] = null, pt(i, l) && (i[l] = null)) : kt(l) && (l.value = null)), gt(n)) ne(n, u, 12, [b, h]); else { const r = wt(n), e = kt(n); if (r || e) { const o = () => { if (a.f) { const c = r ? pt(i, n) ? i[n] : h[n] : n.value; _ ? ct(c) && Yi(c, C) : ct(c) ? c.includes(C) || c.push(C) : r ? (h[n] = [C], pt(i, n) && (i[n] = h[n])) : (n.value = [C], a.k && (h[a.k] = n.value)) } else r ? (h[n] = b, pt(i, n) && (i[n] = b)) : e && (n.value = b, a.k && (h[a.k] = b)) }; b ? (o.id = -1, Dt(o, g)) : o() } } } const Dt = lo; function Ho(a) { return zo(a) } function zo(a, t) { const g = fs(); g.__VUE__ = !0; const { insert: v, remove: _, patchProp: C, createElement: b, createText: u, createComment: n, setText: l, setElementText: h, parentNode: i, nextSibling: r, setScopeId: e = Nt, insertStaticContent: o } = a, c = (O, S, E, L = null, I = null, j = null, B = !1, H = null, K = !!S.dynamicChildren) => { if (O === S) return; O && !ue(O, S) && (L = X(O), A(O, I, j, !0), O = null), S.patchFlag === -2 && (K = !1, S.dynamicChildren = null); const { type: z, ref: W, shapeFlag: q } = S; switch (z) { case gi: s(O, S, E, L); break; case Ut: f(O, S, E, L); break; case wi: O == null && d(S, E, L, B); break; case Ft: Q(O, S, E, L, I, j, B, H, K); break; default: q & 1 ? y(O, S, E, L, I, j, B, H, K) : q & 6 ? rt(O, S, E, L, I, j, B, H, K) : (q & 64 || q & 128) && z.process(O, S, E, L, I, j, B, H, K, N) }W != null && I && Wi(W, O && O.ref, j, S || O, !S) }, s = (O, S, E, L) => { if (O == null) v(S.el = u(S.children), E, L); else { const I = S.el = O.el; S.children !== O.children && l(I, S.children) } }, f = (O, S, E, L) => { O == null ? v(S.el = n(S.children || ""), E, L) : S.el = O.el }, d = (O, S, E, L) => { [O.el, O.anchor] = o(O.children, S, E, L, O.el, O.anchor) }, p = ({ el: O, anchor: S }, E, L) => { let I; for (; O && O !== S;)I = r(O), v(O, E, L), O = I; v(S, E, L) }, m = ({ el: O, anchor: S }) => { let E; for (; O && O !== S;)E = r(O), _(O), O = E; _(S) }, y = (O, S, E, L, I, j, B, H, K) => { B = B || S.type === "svg", O == null ? x(S, E, L, I, j, B, H, K) : Y(O, S, I, j, B, H, K) }, x = (O, S, E, L, I, j, B, H) => { let K, z; const { type: W, props: q, shapeFlag: et, transition: at, dirs: lt } = O; if (K = O.el = b(O.type, j, q && q.is, q), et & 8 ? h(K, O.children) : et & 16 && D(O.children, K, null, L, I, j && W !== "foreignObject", B, H), lt && ae(O, null, L, "created"), P(K, O, O.scopeId, B, L), q) { for (const ut in q) ut !== "value" && !Ve(ut) && C(K, ut, null, q[ut], j, O.children, L, I, R); "value" in q && C(K, "value", null, q.value), (z = q.onVnodeBeforeMount) && Gt(z, L, O) } lt && ae(O, null, L, "beforeMount"); const ht = (!I || I && !I.pendingBranch) && at && !at.persisted; ht && at.beforeEnter(K), v(K, S, E), ((z = q && q.onVnodeMounted) || ht || lt) && Dt(() => { z && Gt(z, L, O), ht && at.enter(K), lt && ae(O, null, L, "mounted") }, I) }, P = (O, S, E, L, I) => { if (E && e(O, E), L) for (let j = 0; j < L.length; j++)e(O, L[j]); if (I) { let j = I.subTree; if (S === j) { const B = I.vnode; P(O, B, B.scopeId, B.slotScopeIds, I.parent) } } }, D = (O, S, E, L, I, j, B, H, K = 0) => { for (let z = K; z < O.length; z++) { const W = O[z] = H ? ee(O[z]) : Kt(O[z]); c(null, W, S, E, L, I, j, B, H) } }, Y = (O, S, E, L, I, j, B) => { const H = S.el = O.el; let { patchFlag: K, dynamicChildren: z, dirs: W } = S; K |= O.patchFlag & 16; const q = O.props || _t, et = S.props || _t; let at; E && le(E, !1), (at = et.onVnodeBeforeUpdate) && Gt(at, E, S, O), W && ae(S, O, E, "beforeUpdate"), E && le(E, !0); const lt = I && S.type !== "foreignObject"; if (z ? V(O.dynamicChildren, z, H, E, L, lt, j) : B || nt(O, S, H, null, E, L, lt, j, !1), K > 0) { if (K & 16) J(H, S, q, et, E, L, I); else if (K & 2 && q.class !== et.class && C(H, "class", null, et.class, I), K & 4 && C(H, "style", q.style, et.style, I), K & 8) { const ht = S.dynamicProps; for (let ut = 0; ut < ht.length; ut++) { const ft = ht[ut], xt = q[ft], Rt = et[ft]; (Rt !== xt || ft === "value") && C(H, ft, xt, Rt, I, O.children, E, L, R) } } K & 1 && O.children !== S.children && h(H, S.children) } else !B && z == null && J(H, S, q, et, E, L, I); ((at = et.onVnodeUpdated) || W) && Dt(() => { at && Gt(at, E, S, O), W && ae(S, O, E, "updated") }, L) }, V = (O, S, E, L, I, j, B) => { for (let H = 0; H < S.length; H++) { const K = O[H], z = S[H], W = K.el && (K.type === Ft || !ue(K, z) || K.shapeFlag & 70) ? i(K.el) : E; c(K, z, W, null, L, I, j, B, !0) } }, J = (O, S, E, L, I, j, B) => { if (E !== L) { if (E !== _t) for (const H in E) !Ve(H) && !(H in L) && C(O, H, E[H], null, B, S.children, I, j, R); for (const H in L) { if (Ve(H)) continue; const K = L[H], z = E[H]; K !== z && H !== "value" && C(O, H, z, K, B, S.children, I, j, R) } "value" in L && C(O, "value", E.value, L.value) } }, Q = (O, S, E, L, I, j, B, H, K) => { const z = S.el = O ? O.el : u(""), W = S.anchor = O ? O.anchor : u(""); let { patchFlag: q, dynamicChildren: et, slotScopeIds: at } = S; at && (H = H ? H.concat(at) : at), O == null ? (v(z, E, L), v(W, E, L), D(S.children, E, W, I, j, B, H, K)) : q > 0 && q & 64 && et && O.dynamicChildren ? (V(O.dynamicChildren, et, E, I, j, B, H), (S.key != null || I && S === I.subTree) && Lr(O, S, !0)) : nt(O, S, E, W, I, j, B, H, K) }, rt = (O, S, E, L, I, j, B, H, K) => { S.slotScopeIds = H, O == null ? S.shapeFlag & 512 ? I.ctx.activate(S, E, L, B, K) : tt(S, E, L, I, j, B, K) : it(O, S, K) }, tt = (O, S, E, L, I, j, B) => { const H = O.component = Qo(O, L, I); if (fi(O) && (H.ctx.renderer = N), ea(H), H.asyncDep) { if (I && I.registerDep(H, ot), !O.el) { const K = H.subTree = Vt(Ut); f(null, K, S, E) } return } ot(H, O, S, E, I, j, B) }, it = (O, S, E) => { const L = S.component = O.component; if (so(O, S, E)) if (L.asyncDep && !L.asyncResolved) { st(L, S, E); return } else L.next = S, Zs(L.update), L.update(); else S.el = O.el, L.vnode = S }, ot = (O, S, E, L, I, j, B) => { const H = () => { if (O.isMounted) { let { next: W, bu: q, u: et, parent: at, vnode: lt } = O, ht = W, ut; le(O, !1), W ? (W.el = lt.el, st(O, W, B)) : W = lt, q && Ge(q), (ut = W.props && W.props.onVnodeBeforeUpdate) && Gt(ut, at, W, lt), le(O, !0); const ft = yi(O), xt = O.subTree; O.subTree = ft, c(xt, ft, i(xt.el), X(xt), O, I, j), W.el = ft.el, ht === null && oo(O, ft.el), et && Dt(et, I), (ut = W.props && W.props.onVnodeUpdated) && Dt(() => Gt(ut, at, W, lt), I) } else { let W; const { el: q, props: et } = S, { bm: at, m: lt, parent: ht } = O, ut = qe(S); if (le(O, !1), at && Ge(at), !ut && (W = et && et.onVnodeBeforeMount) && Gt(W, ht, S), le(O, !0), q && Z) { const ft = () => { O.subTree = yi(O), Z(q, O.subTree, O, I, null) }; ut ? S.type.__asyncLoader().then(() => !O.isUnmounted && ft()) : ft() } else { const ft = O.subTree = yi(O); c(null, ft, E, L, O, I, j), S.el = ft.el } if (lt && Dt(lt, I), !ut && (W = et && et.onVnodeMounted)) { const ft = S; Dt(() => Gt(W, ht, ft), I) } (S.shapeFlag & 256 || ht && qe(ht.vnode) && ht.vnode.shapeFlag & 256) && O.a && Dt(O.a, I), O.isMounted = !0, S = E = L = null } }, K = O.effect = new Vi(H, () => en(z), O.scope), z = O.update = () => K.run(); z.id = O.uid, le(O, !0), z() }, st = (O, S, E) => { S.component = O; const L = O.vnode.props; O.vnode = S, O.next = null, Io(O, S.props, L, E), Bo(O, S.children, E), Te(), yn(), Oe() }, nt = (O, S, E, L, I, j, B, H, K = !1) => { const z = O && O.children, W = O ? O.shapeFlag : 0, q = S.children, { patchFlag: et, shapeFlag: at } = S; if (et > 0) { if (et & 128) { F(z, q, E, L, I, j, B, H, K); return } else if (et & 256) { w(z, q, E, L, I, j, B, H, K); return } } at & 8 ? (W & 16 && R(z, I, j), q !== z && h(E, q)) : W & 16 ? at & 16 ? F(z, q, E, L, I, j, B, H, K) : R(z, I, j, !0) : (W & 8 && h(E, ""), at & 16 && D(q, E, L, I, j, B, H, K)) }, w = (O, S, E, L, I, j, B, H, K) => { O = O || ve, S = S || ve; const z = O.length, W = S.length, q = Math.min(z, W); let et; for (et = 0; et < q; et++) { const at = S[et] = K ? ee(S[et]) : Kt(S[et]); c(O[et], at, E, null, I, j, B, H, K) } z > W ? R(O, I, j, !0, !1, q) : D(S, E, L, I, j, B, H, K, q) }, F = (O, S, E, L, I, j, B, H, K) => { let z = 0; const W = S.length; let q = O.length - 1, et = W - 1; for (; z <= q && z <= et;) { const at = O[z], lt = S[z] = K ? ee(S[z]) : Kt(S[z]); if (ue(at, lt)) c(at, lt, E, null, I, j, B, H, K); else break; z++ } for (; z <= q && z <= et;) { const at = O[q], lt = S[et] = K ? ee(S[et]) : Kt(S[et]); if (ue(at, lt)) c(at, lt, E, null, I, j, B, H, K); else break; q--, et-- } if (z > q) { if (z <= et) { const at = et + 1, lt = at < W ? S[at].el : L; for (; z <= et;)c(null, S[z] = K ? ee(S[z]) : Kt(S[z]), E, lt, I, j, B, H, K), z++ } } else if (z > et) for (; z <= q;)A(O[z], I, j, !0), z++; else { const at = z, lt = z, ht = new Map; for (z = lt; z <= et; z++) { const Pt = S[z] = K ? ee(S[z]) : Kt(S[z]); Pt.key != null && ht.set(Pt.key, z) } let ut, ft = 0; const xt = et - lt + 1; let Rt = !1, It = 0; const oe = new Array(xt); for (z = 0; z < xt; z++)oe[z] = 0; for (z = at; z <= q; z++) { const Pt = O[z]; if (ft >= xt) { A(Pt, I, j, !0); continue } let Bt; if (Pt.key != null) Bt = ht.get(Pt.key); else for (ut = lt; ut <= et; ut++)if (oe[ut - lt] === 0 && ue(Pt, S[ut])) { Bt = ut; break } Bt === void 0 ? A(Pt, I, j, !0) : (oe[Bt - lt] = z + 1, Bt >= It ? It = Bt : Rt = !0, c(Pt, S[Bt], E, null, I, j, B, H, K), ft++) } const Ee = Rt ? Yo(oe) : ve; for (ut = Ee.length - 1, z = xt - 1; z >= 0; z--) { const Pt = lt + z, Bt = S[Pt], hn = Pt + 1 < W ? S[Pt + 1].el : L; oe[z] === 0 ? c(null, Bt, E, hn, I, j, B, H, K) : Rt && (ut < 0 || z !== Ee[ut] ? k(Bt, E, hn, 2) : ut--) } } }, k = (O, S, E, L, I = null) => { const { el: j, type: B, transition: H, children: K, shapeFlag: z } = O; if (z & 6) { k(O.component.subTree, S, E, L); return } if (z & 128) { O.suspense.move(S, E, L); return } if (z & 64) { B.move(O, S, E, N); return } if (B === Ft) { v(j, S, E); for (let q = 0; q < K.length; q++)k(K[q], S, E, L); v(O.anchor, S, E); return } if (B === wi) { p(O, S, E); return } if (L !== 2 && z & 1 && H) if (L === 0) H.beforeEnter(j), v(j, S, E), Dt(() => H.enter(j), I); else { const { leave: q, delayLeave: et, afterLeave: at } = H, lt = () => v(j, S, E), ht = () => { q(j, () => { lt(), at && at() }) }; et ? et(j, lt, ht) : ht() } else v(j, S, E) }, A = (O, S, E, L = !1, I = !1) => { const { type: j, props: B, ref: H, children: K, dynamicChildren: z, shapeFlag: W, patchFlag: q, dirs: et } = O; if (H != null && Wi(H, null, E, O, !0), W & 256) { S.ctx.deactivate(O); return } const at = W & 1 && et, lt = !qe(O); let ht; if (lt && (ht = B && B.onVnodeBeforeUnmount) && Gt(ht, S, O), W & 6) T(O.component, E, L); else { if (W & 128) { O.suspense.unmount(E, L); return } at && ae(O, null, S, "beforeUnmount"), W & 64 ? O.type.remove(O, S, E, I, N, L) : z && (j !== Ft || q > 0 && q & 64) ? R(z, S, E, !1, !0) : (j === Ft && q & 384 || !I && W & 16) && R(K, S, E), L && U(O) } (lt && (ht = B && B.onVnodeUnmounted) || at) && Dt(() => { ht && Gt(ht, S, O), at && ae(O, null, S, "unmounted") }, E) }, U = O => { const { type: S, el: E, anchor: L, transition: I } = O; if (S === Ft) { M(E, L); return } if (S === wi) { m(O); return } const j = () => { _(E), I && !I.persisted && I.afterLeave && I.afterLeave() }; if (O.shapeFlag & 1 && I && !I.persisted) { const { leave: B, delayLeave: H } = I, K = () => B(E, j); H ? H(O.el, j, K) : K() } else j() }, M = (O, S) => { let E; for (; O !== S;)E = r(O), _(O), O = E; _(S) }, T = (O, S, E) => { const { bum: L, scope: I, update: j, subTree: B, um: H } = O; L && Ge(L), I.stop(), j && (j.active = !1, A(B, O, S, E)), H && Dt(H, S), Dt(() => { O.isUnmounted = !0 }, S), S && S.pendingBranch && !S.isUnmounted && O.asyncDep && !O.asyncResolved && O.suspenseId === S.pendingId && (S.deps--, S.deps === 0 && S.resolve()) }, R = (O, S, E, L = !1, I = !1, j = 0) => { for (let B = j; B < O.length; B++)A(O[B], S, E, L, I) }, X = O => O.shapeFlag & 6 ? X(O.component.subTree) : O.shapeFlag & 128 ? O.suspense.next() : r(O.anchor || O.el), G = (O, S, E) => { O == null ? S._vnode && A(S._vnode, null, null, !0) : c(S._vnode || null, O, S, null, null, null, E), yn(), gr(), S._vnode = O }, N = { p: c, um: A, m: k, r: U, mt: tt, mc: D, pc: nt, pbc: V, n: X, o: a }; let $, Z; return t && ([$, Z] = t(N)), { render: G, hydrate: $, createApp: Xo(G, $) } } function le({ effect: a, update: t }, g) { a.allowRecurse = t.allowRecurse = g } function Lr(a, t, g = !1) { const v = a.children, _ = t.children; if (ct(v) && ct(_)) for (let C = 0; C < v.length; C++) { const b = v[C]; let u = _[C]; u.shapeFlag & 1 && !u.dynamicChildren && ((u.patchFlag <= 0 || u.patchFlag === 32) && (u = _[C] = ee(_[C]), u.el = b.el), g || Lr(b, u)), u.type === gi && (u.el = b.el) } } function Yo(a) { const t = a.slice(), g = [0]; let v, _, C, b, u; const n = a.length; for (v = 0; v < n; v++) { const l = a[v]; if (l !== 0) { if (_ = g[g.length - 1], a[_] < l) { t[v] = _, g.push(v); continue } for (C = 0, b = g.length - 1; C < b;)u = C + b >> 1, a[g[u]] < l ? C = u + 1 : b = u; l < a[g[C]] && (C > 0 && (t[v] = g[C - 1]), g[C] = v) } } for (C = g.length, b = g[C - 1]; C-- > 0;)g[C] = b, b = t[b]; return g } const No = a => a.__isTeleport, Ft = Symbol(void 0), gi = Symbol(void 0), Ut = Symbol(void 0), wi = Symbol(void 0), ke = []; let Yt = null; function Tt(a = !1) { ke.push(Yt = a ? null : []) } function Uo() { ke.pop(), Yt = ke[ke.length - 1] || null } let Re = 1; function Mn(a) { Re += a } function Ir(a) { return a.dynamicChildren = Re > 0 ? Yt || ve : null, Uo(), Re > 0 && Yt && Yt.push(a), a } function Mt(a, t, g, v, _, C) { return Ir(dt(a, t, g, v, _, C, !0)) } function Vo(a, t, g, v, _) { return Ir(Vt(a, t, g, v, _, !0)) } function Go(a) { return a ? a.__v_isVNode === !0 : !1 } function ue(a, t) { return a.type === t.type && a.key === t.key } const pi = "__vInternal", jr = ({ key: a }) => a ?? null, $e = ({ ref: a, ref_key: t, ref_for: g }) => a != null ? wt(a) || kt(a) || gt(a) ? { i: jt, r: a, k: t, f: !!g } : a : null; function dt(a, t = null, g = null, v = 0, _ = null, C = a === Ft ? 0 : 1, b = !1, u = !1) { const n = { __v_isVNode: !0, __v_skip: !0, type: a, props: t, key: t && jr(t), ref: t && $e(t), scopeId: vr, slotScopeIds: null, children: g, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: C, patchFlag: v, dynamicProps: _, dynamicChildren: null, appContext: null, ctx: jt }; return u ? (on(n, g), C & 128 && a.normalize(n)) : g && (n.shapeFlag |= wt(g) ? 8 : 16), Re > 0 && !b && Yt && (n.patchFlag > 0 || C & 6) && n.patchFlag !== 32 && Yt.push(n), n } const Vt = Ko; function Ko(a, t = null, g = null, v = 0, _ = null, C = !1) { if ((!a || a === Oo) && (a = Ut), Go(a)) { const u = se(a, t, !0); return g && on(u, g), Re > 0 && !C && Yt && (u.shapeFlag & 6 ? Yt[Yt.indexOf(a)] = u : Yt.push(u)), u.patchFlag |= -2, u } if (oa(a) && (a = a.__vccOpts), t) { t = qo(t); let { class: u, style: n } = t; u && !wt(u) && (t.class = we(u)), yt(n) && (lr(n) && !ct(n) && (n = Et({}, n)), t.style = De(n)) } const b = wt(a) ? 1 : ao(a) ? 128 : No(a) ? 64 : yt(a) ? 4 : gt(a) ? 2 : 0; return dt(a, t, g, v, _, b, C, !0) } function qo(a) { return a ? lr(a) || pi in a ? Et({}, a) : a : null } function se(a, t, g = !1) { const { props: v, ref: _, patchFlag: C, children: b } = a, u = t ? $o(v || {}, t) : v; return { __v_isVNode: !0, __v_skip: !0, type: a.type, props: u, key: u && jr(u), ref: t && t.ref ? g && _ ? ct(_) ? _.concat($e(t)) : [_, $e(t)] : $e(t) : _, scopeId: a.scopeId, slotScopeIds: a.slotScopeIds, children: b, target: a.target, targetAnchor: a.targetAnchor, staticCount: a.staticCount, shapeFlag: a.shapeFlag, patchFlag: t && a.type !== Ft ? C === -1 ? 16 : C | 16 : C, dynamicProps: a.dynamicProps, dynamicChildren: a.dynamicChildren, appContext: a.appContext, dirs: a.dirs, transition: a.transition, component: a.component, suspense: a.suspense, ssContent: a.ssContent && se(a.ssContent), ssFallback: a.ssFallback && se(a.ssFallback), el: a.el, anchor: a.anchor, ctx: a.ctx, ce: a.ce } } function Rr(a = " ", t = 0) { return Vt(gi, null, a, t) } function ii(a = "", t = !1) { return t ? (Tt(), Vo(Ut, null, a)) : Vt(Ut, null, a) } function Kt(a) { return a == null || typeof a == "boolean" ? Vt(Ut) : ct(a) ? Vt(Ft, null, a.slice()) : typeof a == "object" ? ee(a) : Vt(gi, null, String(a)) } function ee(a) { return a.el === null && a.patchFlag !== -1 || a.memo ? a : se(a) } function on(a, t) { let g = 0; const { shapeFlag: v } = a; if (t == null) t = null; else if (ct(t)) g = 16; else if (typeof t == "object") if (v & 65) { const _ = t.default; _ && (_._c && (_._d = !1), on(a, _()), _._c && (_._d = !0)); return } else { g = 32; const _ = t._; !_ && !(pi in t) ? t._ctx = jt : _ === 3 && jt && (jt.slots._ === 1 ? t._ = 1 : (t._ = 2, a.patchFlag |= 1024)) } else gt(t) ? (t = { default: t, _ctx: jt }, g = 32) : (t = String(t), v & 64 ? (g = 16, t = [Rr(t)]) : g = 8); a.children = t, a.shapeFlag |= g } function $o(...a) { const t = {}; for (let g = 0; g < a.length; g++) { const v = a[g]; for (const _ in v) if (_ === "class") t.class !== v.class && (t.class = we([t.class, v.class])); else if (_ === "style") t.style = De([t.style, v.style]); else if (si(_)) { const C = t[_], b = v[_]; b && C !== b && !(ct(C) && C.includes(b)) && (t[_] = C ? [].concat(C, b) : b) } else _ !== "" && (t[_] = v[_]) } return t } function Gt(a, t, g, v = null) { Xt(a, t, 7, [g, v]) } const Jo = Fr(); let Zo = 0; function Qo(a, t, g) { const v = a.type, _ = (t ? t.appContext : a.appContext) || Jo, C = { uid: Zo++, vnode: a, type: v, parent: t, appContext: _, root: null, next: null, subTree: null, effect: null, update: null, scope: new ds(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(_.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: Ar(v, _), emitsOptions: mr(v, _), emit: null, emitted: null, propsDefaults: _t, inheritAttrs: v.inheritAttrs, ctx: _t, data: _t, props: _t, attrs: _t, slots: _t, refs: _t, setupState: _t, setupContext: null, suspense: g, suspenseId: g ? g.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return C.ctx = { _: C }, C.root = t ? t.root : C, C.emit = eo.bind(null, C), a.ce && a.ce(C), C } let bt = null; const ta = () => bt || jt, xe = a => { bt = a, a.scope.on() }, pe = () => { bt && bt.scope.off(), bt = null }; function Br(a) { return a.vnode.shapeFlag & 4 } let Be = !1; function ea(a, t = !1) { Be = t; const { props: g, children: v } = a.vnode, _ = Br(a); Lo(a, g, _, t), Ro(a, v); const C = _ ? ia(a, t) : void 0; return Be = !1, C } function ia(a, t) { const g = a.type; a.accessCache = Object.create(null), a.proxy = hr(new Proxy(a.ctx, Po)); const { setup: v } = g; if (v) { const _ = a.setupContext = v.length > 1 ? ra(a) : null; xe(a), Te(); const C = ne(v, a, 0, [a.props, _]); if (Oe(), pe(), Gn(C)) { if (C.then(pe, pe), t) return C.then(b => { kn(a, b, t) }).catch(b => { ci(b, a, 0) }); a.asyncDep = C } else kn(a, C, t) } else Wr(a, t) } function kn(a, t, g) { gt(t) ? a.type.__ssrInlineRender ? a.ssrRender = t : a.render = t : yt(t) && (a.setupState = cr(t)), Wr(a, g) } let Dn; function Wr(a, t, g) { const v = a.type; if (!a.render) { if (!t && Dn && !v.render) { const _ = v.template || rn(a).template; if (_) { const { isCustomElement: C, compilerOptions: b } = a.appContext.config, { delimiters: u, compilerOptions: n } = v, l = Et(Et({ isCustomElement: C, delimiters: u }, b), n); v.render = Dn(_, l) } } a.render = v.render || Nt } xe(a), Te(), Ao(a), Oe(), pe() } function na(a) { return new Proxy(a.attrs, { get(t, g) { return Lt(a, "get", "$attrs"), t[g] } }) } function ra(a) { const t = v => { a.exposed = v || {} }; let g; return { get attrs() { return g || (g = na(a)) }, slots: a.slots, emit: a.emit, expose: t } } function mi(a) { if (a.exposed) return a.exposeProxy || (a.exposeProxy = new Proxy(cr(hr(a.exposed)), { get(t, g) { if (g in t) return t[g]; if (g in Me) return Me[g](a) }, has(t, g) { return g in t || g in Me } })) } function sa(a, t = !0) { return gt(a) ? a.displayName || a.name : a.name || t && a.__name } function oa(a) { return gt(a) && "__vccOpts" in a } const aa = (a, t) => Ks(a, t, Be), la = Symbol(""), ha = () => Ke(la), ca = "3.2.47", ua = "http://www.w3.org/2000/svg", fe = typeof document < "u" ? document : null, Fn = fe && fe.createElement("template"), fa = { insert: (a, t, g) => { t.insertBefore(a, g || null) }, remove: a => { const t = a.parentNode; t && t.removeChild(a) }, createElement: (a, t, g, v) => { const _ = t ? fe.createElementNS(ua, a) : fe.createElement(a, g ? { is: g } : void 0); return a === "select" && v && v.multiple != null && _.setAttribute("multiple", v.multiple), _ }, createText: a => fe.createTextNode(a), createComment: a => fe.createComment(a), setText: (a, t) => { a.nodeValue = t }, setElementText: (a, t) => { a.textContent = t }, parentNode: a => a.parentNode, nextSibling: a => a.nextSibling, querySelector: a => fe.querySelector(a), setScopeId(a, t) { a.setAttribute(t, "") }, insertStaticContent(a, t, g, v, _, C) { const b = g ? g.previousSibling : t.lastChild; if (_ && (_ === C || _.nextSibling)) for (; t.insertBefore(_.cloneNode(!0), g), !(_ === C || !(_ = _.nextSibling));); else { Fn.innerHTML = v ? `<svg>${a}</svg>` : a; const u = Fn.content; if (v) { const n = u.firstChild; for (; n.firstChild;)u.appendChild(n.firstChild); u.removeChild(n) } t.insertBefore(u, g) } return [b ? b.nextSibling : t.firstChild, g ? g.previousSibling : t.lastChild] } }; function da(a, t, g) { const v = a._vtc; v && (t = (t ? [t, ...v] : [...v]).join(" ")), t == null ? a.removeAttribute("class") : g ? a.setAttribute("class", t) : a.className = t } function ga(a, t, g) { const v = a.style, _ = wt(g); if (g && !_) { if (t && !wt(t)) for (const C in t) g[C] == null && Xi(v, C, ""); for (const C in g) Xi(v, C, g[C]) } else { const C = v.display; _ ? t !== g && (v.cssText = g) : t && a.removeAttribute("style"), "_vod" in a && (v.display = C) } } const Ln = /\s*!important$/; function Xi(a, t, g) { if (ct(g)) g.forEach(v => Xi(a, t, v)); else if (g == null && (g = ""), t.startsWith("--")) a.setProperty(t, g); else { const v = pa(a, t); Ln.test(g) ? a.setProperty(Se(v), g.replace(Ln, ""), "important") : a[v] = g } } const In = ["Webkit", "Moz", "ms"], Si = {}; function pa(a, t) { const g = Si[t]; if (g) return g; let v = $t(t); if (v !== "filter" && v in a) return Si[t] = v; v = li(v); for (let _ = 0; _ < In.length; _++) { const C = In[_] + v; if (C in a) return Si[t] = C } return t } const jn = "http://www.w3.org/1999/xlink"; function ma(a, t, g, v, _) { if (v && t.startsWith("xlink:")) g == null ? a.removeAttributeNS(jn, t.slice(6, t.length)) : a.setAttributeNS(jn, t, g); else { const C = ns(t); g == null || C && !Un(g) ? a.removeAttribute(t) : a.setAttribute(t, C ? "" : g) } } function va(a, t, g, v, _, C, b) { if (t === "innerHTML" || t === "textContent") { v && b(v, _, C), a[t] = g ?? ""; return } if (t === "value" && a.tagName !== "PROGRESS" && !a.tagName.includes("-")) { a._value = g; const n = g ?? ""; (a.value !== n || a.tagName === "OPTION") && (a.value = n), g == null && a.removeAttribute(t); return } let u = !1; if (g === "" || g == null) { const n = typeof a[t]; n === "boolean" ? g = Un(g) : g == null && n === "string" ? (g = "", u = !0) : n === "number" && (g = 0, u = !0) } try { a[t] = g } catch { } u && a.removeAttribute(t) } function Xr(a, t, g, v) { a.addEventListener(t, g, v) } function _a(a, t, g, v) { a.removeEventListener(t, g, v) } function ya(a, t, g, v, _ = null) { const C = a._vei || (a._vei = {}), b = C[t]; if (v && b) b.value = v; else { const [u, n] = Ca(t); if (v) { const l = C[t] = wa(v, _); Xr(a, u, l, n) } else b && (_a(a, u, b, n), C[t] = void 0) } } const Rn = /(?:Once|Passive|Capture)$/; function Ca(a) { let t; if (Rn.test(a)) { t = {}; let v; for (; v = a.match(Rn);)a = a.slice(0, a.length - v[0].length), t[v[0].toLowerCase()] = !0 } return [a[2] === ":" ? a.slice(3) : Se(a.slice(2)), t] } let Ti = 0; const ba = Promise.resolve(), xa = () => Ti || (ba.then(() => Ti = 0), Ti = Date.now()); function wa(a, t) { const g = v => { if (!v._vts) v._vts = Date.now(); else if (v._vts <= g.attached) return; Xt(Sa(v, g.value), t, 5, [v]) }; return g.value = a, g.attached = xa(), g } function Sa(a, t) { if (ct(t)) { const g = a.stopImmediatePropagation; return a.stopImmediatePropagation = () => { g.call(a), a._stopped = !0 }, t.map(v => _ => !_._stopped && v && v(_)) } else return t } const Bn = /^on[a-z]/, Ta = (a, t, g, v, _ = !1, C, b, u, n) => { t === "class" ? da(a, v, _) : t === "style" ? ga(a, g, v) : si(t) ? zi(t) || ya(a, t, g, v, b) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Oa(a, t, v, _)) ? va(a, t, v, C, b, u, n) : (t === "true-value" ? a._trueValue = v : t === "false-value" && (a._falseValue = v), ma(a, t, v, _)) }; function Oa(a, t, g, v) { return v ? !!(t === "innerHTML" || t === "textContent" || t in a && Bn.test(t) && gt(g)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && a.tagName === "INPUT" || t === "type" && a.tagName === "TEXTAREA" || Bn.test(t) && wt(g) ? !1 : t in a } const Ea = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }; go.props; const Wn = a => { const t = a.props["onUpdate:modelValue"] || !1; return ct(t) ? g => Ge(t, g) : t }, Pa = { deep: !0, created(a, { value: t, modifiers: { number: g } }, v) { const _ = oi(t); Xr(a, "change", () => { const C = Array.prototype.filter.call(a.options, b => b.selected).map(b => g ? $n(ni(b)) : ni(b)); a._assign(a.multiple ? _ ? new Set(C) : C : C[0]) }), a._assign = Wn(v) }, mounted(a, { value: t }) { Xn(a, t) }, beforeUpdate(a, t, g) { a._assign = Wn(g) }, updated(a, { value: t }) { Xn(a, t) } }; function Xn(a, t) { const g = a.multiple; if (!(g && !ct(t) && !oi(t))) { for (let v = 0, _ = a.options.length; v < _; v++) { const C = a.options[v], b = ni(C); if (g) ct(t) ? C.selected = ss(t, b) > -1 : C.selected = t.has(b); else if (ri(ni(C), t)) { a.selectedIndex !== v && (a.selectedIndex = v); return } } !g && a.selectedIndex !== -1 && (a.selectedIndex = -1) } } function ni(a) { return "_value" in a ? a._value : a.value } const Aa = Et({ patchProp: Ta }, fa); let Hn; function Ma() { return Hn || (Hn = Ho(Aa)) } const ka = (...a) => { const t = Ma().createApp(...a), { mount: g } = t; return t.mount = v => { const _ = Da(v); if (!_) return; const C = t._component; !gt(C) && !C.render && !C.template && (C.template = _.innerHTML), _.innerHTML = ""; const b = g(_, !1, _ instanceof SVGElement); return _ instanceof Element && (_.removeAttribute("v-cloak"), _.setAttribute("data-v-app", "")), b }, t }; function Da(a) { return wt(a) ? document.querySelector(a) : a } function Fa(a) { return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a } function La(a) { if (a.__esModule) return a; var t = a.default; if (typeof t == "function") { var g = function v() { if (this instanceof v) { var _ = [null]; _.push.apply(_, arguments); var C = Function.bind.apply(t, _); return new C } return t.apply(this, arguments) }; g.prototype = t.prototype } else g = {}; return Object.defineProperty(g, "__esModule", { value: !0 }), Object.keys(a).forEach(function (v) { var _ = Object.getOwnPropertyDescriptor(a, v); Object.defineProperty(g, v, _.get ? _ : { enumerable: !0, get: function () { return a[v] } }) }), g } var Ct = {}; const Ia = {}, ja = Object.freeze(Object.defineProperty({ __proto__: null, default: Ia }, Symbol.toStringTag, { value: "Module" })), Oi = La(ja); (function (a) {/*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */var t = t || { version: "5.3.0" }; if (a.fabric = t, typeof document < "u" && typeof window < "u") document instanceof (typeof HTMLDocument < "u" ? HTMLDocument : Document) ? t.document = document : t.document = document.implementation.createHTMLDocument(""), t.window = window; else { var g = Oi, v = new g.JSDOM(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"), { features: { FetchExternalResources: ["img"] }, resources: "usable" }).window; t.document = v.document, t.jsdomImplForWrapper = Oi.implForWrapper, t.nodeCanvas = Oi.Canvas, t.window = v, DOMParser = t.window.DOMParser } t.isTouchSupported = "ontouchstart" in t.window || "ontouchstart" in t.document || t.window && t.window.navigator && t.window.navigator.maxTouchPoints > 0, t.isLikelyNode = typeof Buffer < "u" && typeof window > "u", t.SHARED_ATTRIBUTES = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"], t.DPI = 96, t.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)", t.commaWsp = "(?:\\s+,?\\s*|,\\s*)", t.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig, t.reNonWord = /[ \n\.,;!\?\-]/, t.fontPaths = {}, t.iMatrix = [1, 0, 0, 1, 0, 0], t.svgNS = "http://www.w3.org/2000/svg", t.perfLimitSizeTotal = 2097152, t.maxCacheSideLimit = 4096, t.minCacheSideLimit = 256, t.charWidthsCache = {}, t.textureSize = 2048, t.disableStyleCopyPaste = !1, t.enableGLFiltering = !0, t.devicePixelRatio = t.window.devicePixelRatio || t.window.webkitDevicePixelRatio || t.window.mozDevicePixelRatio || 1, t.browserShadowBlurConstant = 1, t.arcToSegmentsCache = {}, t.boundsOfCurveCache = {}, t.cachesBoundsOfCurve = !0, t.forceGLPutImageData = !1, t.initFilterBackend = function () { if (t.enableGLFiltering && t.isWebglSupported && t.isWebglSupported(t.textureSize)) return console.log("max texture size: " + t.maxTextureSize), new t.WebglFilterBackend({ tileSize: t.textureSize }); if (t.Canvas2dFilterBackend) return new t.Canvas2dFilterBackend }, typeof document < "u" && typeof window < "u" && (window.fabric = t), function () { function u(e, o) { if (this.__eventListeners[e]) { var c = this.__eventListeners[e]; o ? c[c.indexOf(o)] = !1 : t.util.array.fill(c, !1) } } function n(e, o) { if (this.__eventListeners || (this.__eventListeners = {}), arguments.length === 1) for (var c in e) this.on(c, e[c]); else this.__eventListeners[e] || (this.__eventListeners[e] = []), this.__eventListeners[e].push(o); return this } function l(e, o) { var c = function () { o.apply(this, arguments), this.off(e, c) }.bind(this); this.on(e, c) } function h(e, o) { if (arguments.length === 1) for (var c in e) l.call(this, c, e[c]); else l.call(this, e, o); return this } function i(e, o) { if (!this.__eventListeners) return this; if (arguments.length === 0) for (e in this.__eventListeners) u.call(this, e); else if (arguments.length === 1 && typeof arguments[0] == "object") for (var c in e) u.call(this, c, e[c]); else u.call(this, e, o); return this } function r(e, o) { if (!this.__eventListeners) return this; var c = this.__eventListeners[e]; if (!c) return this; for (var s = 0, f = c.length; s < f; s++)c[s] && c[s].call(this, o || {}); return this.__eventListeners[e] = c.filter(function (d) { return d !== !1 }), this } t.Observable = { fire: r, on: n, once: h, off: i } }(), t.Collection = { _objects: [], add: function () { if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded) for (var u = 0, n = arguments.length; u < n; u++)this._onObjectAdded(arguments[u]); return this.renderOnAddRemove && this.requestRenderAll(), this }, insertAt: function (u, n, l) { var h = this._objects; return l ? h[n] = u : h.splice(n, 0, u), this._onObjectAdded && this._onObjectAdded(u), this.renderOnAddRemove && this.requestRenderAll(), this }, remove: function () { for (var u = this._objects, n, l = !1, h = 0, i = arguments.length; h < i; h++)n = u.indexOf(arguments[h]), n !== -1 && (l = !0, u.splice(n, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[h])); return this.renderOnAddRemove && l && this.requestRenderAll(), this }, forEachObject: function (u, n) { for (var l = this.getObjects(), h = 0, i = l.length; h < i; h++)u.call(n, l[h], h, l); return this }, getObjects: function (u) { return typeof u > "u" ? this._objects.concat() : this._objects.filter(function (n) { return n.type === u }) }, item: function (u) { return this._objects[u] }, isEmpty: function () { return this._objects.length === 0 }, size: function () { return this._objects.length }, contains: function (u, n) { return this._objects.indexOf(u) > -1 ? !0 : n ? this._objects.some(function (l) { return typeof l.contains == "function" && l.contains(u, !0) }) : !1 }, complexity: function () { return this._objects.reduce(function (u, n) { return u += n.complexity ? n.complexity() : 0, u }, 0) } }, t.CommonMethods = { _setOptions: function (u) { for (var n in u) this.set(n, u[n]) }, _initGradient: function (u, n) { u && u.colorStops && !(u instanceof t.Gradient) && this.set(n, new t.Gradient(u)) }, _initPattern: function (u, n, l) { u && u.source && !(u instanceof t.Pattern) ? this.set(n, new t.Pattern(u, l)) : l && l() }, _setObject: function (u) { for (var n in u) this._set(n, u[n]) }, set: function (u, n) { return typeof u == "object" ? this._setObject(u) : this._set(u, n), this }, _set: function (u, n) { this[u] = n }, toggle: function (u) { var n = this.get(u); return typeof n == "boolean" && this.set(u, !n), this }, get: function (u) { return this[u] } }, function (u) {
    var n = Math.sqrt, l = Math.atan2, h = Math.pow, i = Math.PI / 180, r = Math.PI / 2; t.util = {
        cos: function (e) { if (e === 0) return 1; e < 0 && (e = -e); var o = e / r; switch (o) { case 1: case 3: return 0; case 2: return -1 }return Math.cos(e) }, sin: function (e) { if (e === 0) return 0; var o = e / r, c = 1; switch (e < 0 && (c = -1), o) { case 1: return c; case 2: return 0; case 3: return -c }return Math.sin(e) }, removeFromArray: function (e, o) { var c = e.indexOf(o); return c !== -1 && e.splice(c, 1), e }, getRandomInt: function (e, o) { return Math.floor(Math.random() * (o - e + 1)) + e }, degreesToRadians: function (e) { return e * i }, radiansToDegrees: function (e) { return e / i }, rotatePoint: function (e, o, c) { var s = new t.Point(e.x - o.x, e.y - o.y), f = t.util.rotateVector(s, c); return new t.Point(f.x, f.y).addEquals(o) }, rotateVector: function (e, o) { var c = t.util.sin(o), s = t.util.cos(o), f = e.x * s - e.y * c, d = e.x * c + e.y * s; return { x: f, y: d } }, createVector: function (e, o) { return new t.Point(o.x - e.x, o.y - e.y) }, calcAngleBetweenVectors: function (e, o) { return Math.acos((e.x * o.x + e.y * o.y) / (Math.hypot(e.x, e.y) * Math.hypot(o.x, o.y))) }, getHatVector: function (e) { return new t.Point(e.x, e.y).multiply(1 / Math.hypot(e.x, e.y)) }, getBisector: function (e, o, c) { var s = t.util.createVector(e, o), f = t.util.createVector(e, c), d = t.util.calcAngleBetweenVectors(s, f), p = t.util.calcAngleBetweenVectors(t.util.rotateVector(s, d), f), m = d * (p === 0 ? 1 : -1) / 2; return { vector: t.util.getHatVector(t.util.rotateVector(s, m)), angle: d } }, projectStrokeOnPoints: function (e, o, c) { var s = [], f = o.strokeWidth / 2, d = o.strokeUniform ? new t.Point(1 / o.scaleX, 1 / o.scaleY) : new t.Point(1, 1), p = function (m) { var y = f / Math.hypot(m.x, m.y); return new t.Point(m.x * y * d.x, m.y * y * d.y) }; return e.length <= 1 || e.forEach(function (m, y) { var x = new t.Point(m.x, m.y), P, D; y === 0 ? (D = e[y + 1], P = c ? p(t.util.createVector(D, x)).addEquals(x) : e[e.length - 1]) : y === e.length - 1 ? (P = e[y - 1], D = c ? p(t.util.createVector(P, x)).addEquals(x) : e[0]) : (P = e[y - 1], D = e[y + 1]); var Y = t.util.getBisector(x, P, D), V = Y.vector, J = Y.angle, Q, rt; if (o.strokeLineJoin === "miter" && (Q = -f / Math.sin(J / 2), rt = new t.Point(V.x * Q * d.x, V.y * Q * d.y), Math.hypot(rt.x, rt.y) / f <= o.strokeMiterLimit)) { s.push(x.add(rt)), s.push(x.subtract(rt)); return } Q = -f * Math.SQRT2, rt = new t.Point(V.x * Q * d.x, V.y * Q * d.y), s.push(x.add(rt)), s.push(x.subtract(rt)) }), s }, transformPoint: function (e, o, c) { return c ? new t.Point(o[0] * e.x + o[2] * e.y, o[1] * e.x + o[3] * e.y) : new t.Point(o[0] * e.x + o[2] * e.y + o[4], o[1] * e.x + o[3] * e.y + o[5]) }, makeBoundingBoxFromPoints: function (e, o) { if (o) for (var c = 0; c < e.length; c++)e[c] = t.util.transformPoint(e[c], o); var s = [e[0].x, e[1].x, e[2].x, e[3].x], f = t.util.array.min(s), d = t.util.array.max(s), p = d - f, m = [e[0].y, e[1].y, e[2].y, e[3].y], y = t.util.array.min(m), x = t.util.array.max(m), P = x - y; return { left: f, top: y, width: p, height: P } }, invertTransform: function (e) { var o = 1 / (e[0] * e[3] - e[1] * e[2]), c = [o * e[3], -o * e[1], -o * e[2], o * e[0]], s = t.util.transformPoint({ x: e[4], y: e[5] }, c, !0); return c[4] = -s.x, c[5] = -s.y, c }, toFixed: function (e, o) { return parseFloat(Number(e).toFixed(o)) }, parseUnit: function (e, o) { var c = /\D{0,2}$/.exec(e), s = parseFloat(e); switch (o || (o = t.Text.DEFAULT_SVG_FONT_SIZE), c[0]) { case "mm": return s * t.DPI / 25.4; case "cm": return s * t.DPI / 2.54; case "in": return s * t.DPI; case "pt": return s * t.DPI / 72; case "pc": return s * t.DPI / 72 * 12; case "em": return s * o; default: return s } }, falseFunction: function () { return !1 }, getKlass: function (e, o) { return e = t.util.string.camelize(e.charAt(0).toUpperCase() + e.slice(1)), t.util.resolveNamespace(o)[e] }, getSvgAttributes: function (e) { var o = ["instantiated_by_use", "style", "id", "class"]; switch (e) { case "linearGradient": o = o.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]); break; case "radialGradient": o = o.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]); break; case "stop": o = o.concat(["offset", "stop-color", "stop-opacity"]); break }return o }, resolveNamespace: function (e) { if (!e) return t; var o = e.split("."), c = o.length, s, f = u || t.window; for (s = 0; s < c; ++s)f = f[o[s]]; return f }, loadImage: function (e, o, c, s) { if (!e) { o && o.call(c, e); return } var f = t.util.createImage(), d = function () { o && o.call(c, f, !1), f = f.onload = f.onerror = null }; f.onload = d, f.onerror = function () { t.log("Error loading " + f.src), o && o.call(c, null, !0), f = f.onload = f.onerror = null }, e.indexOf("data") !== 0 && s !== void 0 && s !== null && (f.crossOrigin = s), e.substring(0, 14) === "data:image/svg" && (f.onload = null, t.util.loadImageInDom(f, d)), f.src = e }, loadImageInDom: function (e, o) { var c = t.document.createElement("div"); c.style.width = c.style.height = "1px", c.style.left = c.style.top = "-100%", c.style.position = "absolute", c.appendChild(e), t.document.querySelector("body").appendChild(c), e.onload = function () { o(), c.parentNode.removeChild(c), c = null } }, enlivenObjects: function (e, o, c, s) { e = e || []; var f = [], d = 0, p = e.length; function m() { ++d === p && o && o(f.filter(function (y) { return y })) } if (!p) { o && o(f); return } e.forEach(function (y, x) { if (!y || !y.type) { m(); return } var P = t.util.getKlass(y.type, c); P.fromObject(y, function (D, Y) { Y || (f[x] = D), s && s(y, D, Y), m() }) }) }, enlivenObjectEnlivables: function (e, o, c) { var s = t.Object.ENLIVEN_PROPS.filter(function (f) { return !!e[f] }); t.util.enlivenObjects(s.map(function (f) { return e[f] }), function (f) { var d = {}; s.forEach(function (p, m) { d[p] = f[m], o && (o[p] = f[m]) }), c && c(d) }) }, enlivenPatterns: function (e, o) { e = e || []; function c() { ++f === d && o && o(s) } var s = [], f = 0, d = e.length; if (!d) { o && o(s); return } e.forEach(function (p, m) { p && p.source ? new t.Pattern(p, function (y) { s[m] = y, c() }) : (s[m] = p, c()) }) }, groupSVGElements: function (e, o, c) { var s; return e && e.length === 1 ? (typeof c < "u" && (e[0].sourcePath = c), e[0]) : (o && (o.width && o.height ? o.centerPoint = { x: o.width / 2, y: o.height / 2 } : (delete o.width, delete o.height)), s = new t.Group(e, o), typeof c < "u" && (s.sourcePath = c), s) }, populateWithProperties: function (e, o, c) { if (c && Array.isArray(c)) for (var s = 0, f = c.length; s < f; s++)c[s] in e && (o[c[s]] = e[c[s]]) }, createCanvasElement: function () { return t.document.createElement("canvas") }, copyCanvasElement: function (e) { var o = t.util.createCanvasElement(); return o.width = e.width, o.height = e.height, o.getContext("2d").drawImage(e, 0, 0), o }, toDataURL: function (e, o, c) { return e.toDataURL("image/" + o, c) }, createImage: function () { return t.document.createElement("img") }, multiplyTransformMatrices: function (e, o, c) { return [e[0] * o[0] + e[2] * o[1], e[1] * o[0] + e[3] * o[1], e[0] * o[2] + e[2] * o[3], e[1] * o[2] + e[3] * o[3], c ? 0 : e[0] * o[4] + e[2] * o[5] + e[4], c ? 0 : e[1] * o[4] + e[3] * o[5] + e[5]] }, qrDecompose: function (e) { var o = l(e[1], e[0]), c = h(e[0], 2) + h(e[1], 2), s = n(c), f = (e[0] * e[3] - e[2] * e[1]) / s, d = l(e[0] * e[2] + e[1] * e[3], c); return { angle: o / i, scaleX: s, scaleY: f, skewX: d / i, skewY: 0, translateX: e[4], translateY: e[5] } }, calcRotateMatrix: function (e) { if (!e.angle) return t.iMatrix.concat(); var o = t.util.degreesToRadians(e.angle), c = t.util.cos(o), s = t.util.sin(o); return [c, s, -s, c, 0, 0] }, calcDimensionsMatrix: function (e) { var o = typeof e.scaleX > "u" ? 1 : e.scaleX, c = typeof e.scaleY > "u" ? 1 : e.scaleY, s = [e.flipX ? -o : o, 0, 0, e.flipY ? -c : c, 0, 0], f = t.util.multiplyTransformMatrices, d = t.util.degreesToRadians; return e.skewX && (s = f(s, [1, 0, Math.tan(d(e.skewX)), 1], !0)), e.skewY && (s = f(s, [1, Math.tan(d(e.skewY)), 0, 1], !0)), s }, composeMatrix: function (e) { var o = [1, 0, 0, 1, e.translateX || 0, e.translateY || 0], c = t.util.multiplyTransformMatrices; return e.angle && (o = c(o, t.util.calcRotateMatrix(e))), (e.scaleX !== 1 || e.scaleY !== 1 || e.skewX || e.skewY || e.flipX || e.flipY) && (o = c(o, t.util.calcDimensionsMatrix(e))), o }, resetObjectTransform: function (e) { e.scaleX = 1, e.scaleY = 1, e.skewX = 0, e.skewY = 0, e.flipX = !1, e.flipY = !1, e.rotate(0) }, saveObjectTransform: function (e) { return { scaleX: e.scaleX, scaleY: e.scaleY, skewX: e.skewX, skewY: e.skewY, angle: e.angle, left: e.left, flipX: e.flipX, flipY: e.flipY, top: e.top } }, isTransparent: function (e, o, c, s) { s > 0 && (o > s ? o -= s : o = 0, c > s ? c -= s : c = 0); var f = !0, d, p, m = e.getImageData(o, c, s * 2 || 1, s * 2 || 1), y = m.data.length; for (d = 3; d < y && (p = m.data[d], f = p <= 0, f !== !1); d += 4); return m = null, f }, parsePreserveAspectRatioAttribute: function (e) { var o = "meet", c = "Mid", s = "Mid", f = e.split(" "), d; return f && f.length && (o = f.pop(), o !== "meet" && o !== "slice" ? (d = o, o = "meet") : f.length && (d = f.pop())), c = d !== "none" ? d.slice(1, 4) : "none", s = d !== "none" ? d.slice(5, 8) : "none", { meetOrSlice: o, alignX: c, alignY: s } }, clearFabricFontCache: function (e) { e = (e || "").toLowerCase(), e ? t.charWidthsCache[e] && delete t.charWidthsCache[e] : t.charWidthsCache = {} }, limitDimsByArea: function (e, o) { var c = Math.sqrt(o * e), s = Math.floor(o / c); return { x: Math.floor(c), y: s } }, capValue: function (e, o, c) { return Math.max(e, Math.min(o, c)) }, findScaleToFit: function (e, o) { return Math.min(o.width / e.width, o.height / e.height) }, findScaleToCover: function (e, o) { return Math.max(o.width / e.width, o.height / e.height) }, matrixToSVG: function (e) { return "matrix(" + e.map(function (o) { return t.util.toFixed(o, t.Object.NUM_FRACTION_DIGITS) }).join(" ") + ")" }, removeTransformFromObject: function (e, o) { var c = t.util.invertTransform(o), s = t.util.multiplyTransformMatrices(c, e.calcOwnMatrix()); t.util.applyTransformToObject(e, s) }, addTransformToObject: function (e, o) { t.util.applyTransformToObject(e, t.util.multiplyTransformMatrices(o, e.calcOwnMatrix())) }, applyTransformToObject: function (e, o) { var c = t.util.qrDecompose(o), s = new t.Point(c.translateX, c.translateY); e.flipX = !1, e.flipY = !1, e.set("scaleX", c.scaleX), e.set("scaleY", c.scaleY), e.skewX = c.skewX, e.skewY = c.skewY, e.angle = c.angle, e.setPositionByOrigin(s, "center", "center") }, sizeAfterTransform: function (e, o, c) { var s = e / 2, f = o / 2, d = [{ x: -s, y: -f }, { x: s, y: -f }, { x: -s, y: f }, { x: s, y: f }], p = t.util.calcDimensionsMatrix(c), m = t.util.makeBoundingBoxFromPoints(d, p); return { x: m.width, y: m.height } }, mergeClipPaths: function (e, o) { var c = e, s = o; c.inverted && !s.inverted && (c = o, s = e), t.util.applyTransformToObject(s, t.util.multiplyTransformMatrices(t.util.invertTransform(c.calcTransformMatrix()), s.calcTransformMatrix())); var f = c.inverted && s.inverted; return f && (c.inverted = s.inverted = !1), new t.Group([c], { clipPath: s, inverted: f }) }, hasStyleChanged: function (e, o, c) { return c = c || !1, e.fill !== o.fill || e.stroke !== o.stroke || e.strokeWidth !== o.strokeWidth || e.fontSize !== o.fontSize || e.fontFamily !== o.fontFamily || e.fontWeight !== o.fontWeight || e.fontStyle !== o.fontStyle || e.textBackgroundColor !== o.textBackgroundColor || e.deltaY !== o.deltaY || c && (e.overline !== o.overline || e.underline !== o.underline || e.linethrough !== o.linethrough) }, stylesToArray: function (c, o) {
            for (var c = t.util.object.clone(c, !0), s = o.split(`
`), f = -1, d = {}, p = [], m = 0; m < s.length; m++) { if (!c[m]) { f += s[m].length; continue } for (var y = 0; y < s[m].length; y++) { f++; var x = c[m][y]; if (x && Object.keys(x).length > 0) { var P = t.util.hasStyleChanged(d, x, !0); P ? p.push({ start: f, end: f + 1, style: x }) : p[p.length - 1].end++ } d = x || {} } } return p
        }, stylesFromArray: function (e, o) {
            if (!Array.isArray(e)) return e; for (var c = o.split(`
`), s = -1, f = 0, d = {}, p = 0; p < c.length; p++)for (var m = 0; m < c[p].length; m++)s++, e[f] && e[f].start <= s && s < e[f].end && (d[p] = d[p] || {}, d[p][m] = Object.assign({}, e[f].style), s === e[f].end - 1 && f++); return d
        }
    }
}(a), function () { var u = Array.prototype.join, n = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, l = { m: "l", M: "L" }; function h(w, F, k, A, U, M, T, R, X, G, N) { var $ = t.util.cos(w), Z = t.util.sin(w), O = t.util.cos(F), S = t.util.sin(F), E = k * U * O - A * M * S + T, L = A * U * O + k * M * S + R, I = G + X * (-k * U * Z - A * M * $), j = N + X * (-A * U * Z + k * M * $), B = E + X * (k * U * S + A * M * O), H = L + X * (A * U * S - k * M * O); return ["C", I, j, B, H, E, L] } function i(w, F, k, A, U, M, T) { var R = Math.PI, X = T * R / 180, G = t.util.sin(X), N = t.util.cos(X), $ = 0, Z = 0; k = Math.abs(k), A = Math.abs(A); var O = -N * w * .5 - G * F * .5, S = -N * F * .5 + G * w * .5, E = k * k, L = A * A, I = S * S, j = O * O, B = E * L - E * I - L * j, H = 0; if (B < 0) { var K = Math.sqrt(1 - B / (E * L)); k *= K, A *= K } else H = (U === M ? -1 : 1) * Math.sqrt(B / (E * I + L * j)); var z = H * k * S / A, W = -H * A * O / k, q = N * z - G * W + w * .5, et = G * z + N * W + F * .5, at = r(1, 0, (O - z) / k, (S - W) / A), lt = r((O - z) / k, (S - W) / A, (-O - z) / k, (-S - W) / A); M === 0 && lt > 0 ? lt -= 2 * R : M === 1 && lt < 0 && (lt += 2 * R); for (var ht = Math.ceil(Math.abs(lt / R * 2)), ut = [], ft = lt / ht, xt = 8 / 3 * Math.sin(ft / 4) * Math.sin(ft / 4) / Math.sin(ft / 2), Rt = at + ft, It = 0; It < ht; It++)ut[It] = h(at, Rt, N, G, k, A, q, et, xt, $, Z), $ = ut[It][5], Z = ut[It][6], at = Rt, Rt += ft; return ut } function r(w, F, k, A) { var U = Math.atan2(F, w), M = Math.atan2(A, k); return M >= U ? M - U : 2 * Math.PI - (U - M) } function e(w, F, k, A, U, M, T, R) { var X; if (t.cachesBoundsOfCurve && (X = u.call(arguments), t.boundsOfCurveCache[X])) return t.boundsOfCurveCache[X]; var G = Math.sqrt, N = Math.min, $ = Math.max, Z = Math.abs, O = [], S = [[], []], E, L, I, j, B, H, K, z; L = 6 * w - 12 * k + 6 * U, E = -3 * w + 9 * k - 9 * U + 3 * T, I = 3 * k - 3 * w; for (var W = 0; W < 2; ++W) { if (W > 0 && (L = 6 * F - 12 * A + 6 * M, E = -3 * F + 9 * A - 9 * M + 3 * R, I = 3 * A - 3 * F), Z(E) < 1e-12) { if (Z(L) < 1e-12) continue; j = -I / L, 0 < j && j < 1 && O.push(j); continue } K = L * L - 4 * I * E, !(K < 0) && (z = G(K), B = (-L + z) / (2 * E), 0 < B && B < 1 && O.push(B), H = (-L - z) / (2 * E), 0 < H && H < 1 && O.push(H)) } for (var q, et, at = O.length, lt = at, ht; at--;)j = O[at], ht = 1 - j, q = ht * ht * ht * w + 3 * ht * ht * j * k + 3 * ht * j * j * U + j * j * j * T, S[0][at] = q, et = ht * ht * ht * F + 3 * ht * ht * j * A + 3 * ht * j * j * M + j * j * j * R, S[1][at] = et; S[0][lt] = w, S[1][lt] = F, S[0][lt + 1] = T, S[1][lt + 1] = R; var ut = [{ x: N.apply(null, S[0]), y: N.apply(null, S[1]) }, { x: $.apply(null, S[0]), y: $.apply(null, S[1]) }]; return t.cachesBoundsOfCurve && (t.boundsOfCurveCache[X] = ut), ut } function o(w, F, k) { for (var A = k[1], U = k[2], M = k[3], T = k[4], R = k[5], X = k[6], G = k[7], N = i(X - w, G - F, A, U, T, R, M), $ = 0, Z = N.length; $ < Z; $++)N[$][1] += w, N[$][2] += F, N[$][3] += w, N[$][4] += F, N[$][5] += w, N[$][6] += F; return N } function c(w) { var F = 0, k = 0, A = w.length, U = 0, M = 0, T, R, X, G = [], N, $, Z; for (R = 0; R < A; ++R) { switch (X = !1, T = w[R].slice(0), T[0]) { case "l": T[0] = "L", T[1] += F, T[2] += k; case "L": F = T[1], k = T[2]; break; case "h": T[1] += F; case "H": T[0] = "L", T[2] = k, F = T[1]; break; case "v": T[1] += k; case "V": T[0] = "L", k = T[1], T[1] = F, T[2] = k; break; case "m": T[0] = "M", T[1] += F, T[2] += k; case "M": F = T[1], k = T[2], U = T[1], M = T[2]; break; case "c": T[0] = "C", T[1] += F, T[2] += k, T[3] += F, T[4] += k, T[5] += F, T[6] += k; case "C": $ = T[3], Z = T[4], F = T[5], k = T[6]; break; case "s": T[0] = "S", T[1] += F, T[2] += k, T[3] += F, T[4] += k; case "S": N === "C" ? ($ = 2 * F - $, Z = 2 * k - Z) : ($ = F, Z = k), F = T[3], k = T[4], T[0] = "C", T[5] = T[3], T[6] = T[4], T[3] = T[1], T[4] = T[2], T[1] = $, T[2] = Z, $ = T[3], Z = T[4]; break; case "q": T[0] = "Q", T[1] += F, T[2] += k, T[3] += F, T[4] += k; case "Q": $ = T[1], Z = T[2], F = T[3], k = T[4]; break; case "t": T[0] = "T", T[1] += F, T[2] += k; case "T": N === "Q" ? ($ = 2 * F - $, Z = 2 * k - Z) : ($ = F, Z = k), T[0] = "Q", F = T[1], k = T[2], T[1] = $, T[2] = Z, T[3] = F, T[4] = k; break; case "a": T[0] = "A", T[6] += F, T[7] += k; case "A": X = !0, G = G.concat(o(F, k, T)), F = T[6], k = T[7]; break; case "z": case "Z": F = U, k = M; break }X || G.push(T), N = T[0] } return G } function s(w, F, k, A) { return Math.sqrt((k - w) * (k - w) + (A - F) * (A - F)) } function f(w) { return w * w * w } function d(w) { return 3 * w * w * (1 - w) } function p(w) { return 3 * w * (1 - w) * (1 - w) } function m(w) { return (1 - w) * (1 - w) * (1 - w) } function y(w, F, k, A, U, M, T, R) { return function (X) { var G = f(X), N = d(X), $ = p(X), Z = m(X); return { x: T * G + U * N + k * $ + w * Z, y: R * G + M * N + A * $ + F * Z } } } function x(w, F, k, A, U, M, T, R) { return function (X) { var G = 1 - X, N = 3 * G * G * (k - w) + 6 * G * X * (U - k) + 3 * X * X * (T - U), $ = 3 * G * G * (A - F) + 6 * G * X * (M - A) + 3 * X * X * (R - M); return Math.atan2($, N) } } function P(w) { return w * w } function D(w) { return 2 * w * (1 - w) } function Y(w) { return (1 - w) * (1 - w) } function V(w, F, k, A, U, M) { return function (T) { var R = P(T), X = D(T), G = Y(T); return { x: U * R + k * X + w * G, y: M * R + A * X + F * G } } } function J(w, F, k, A, U, M) { return function (T) { var R = 1 - T, X = 2 * R * (k - w) + 2 * T * (U - k), G = 2 * R * (A - F) + 2 * T * (M - A); return Math.atan2(G, X) } } function Q(w, F, k) { var A = { x: F, y: k }, U, M = 0, T; for (T = 1; T <= 100; T += 1)U = w(T / 100), M += s(A.x, A.y, U.x, U.y), A = U; return M } function rt(w, F) { for (var k = 0, A = 0, U = w.iterator, M = { x: w.x, y: w.y }, T, R, X = .01, G = w.angleFinder, N; A < F && X > 1e-4;)T = U(k), N = k, R = s(M.x, M.y, T.x, T.y), R + A > F ? (k -= X, X /= 2) : (M = T, k += X, A += R); return T.angle = G(N), T } function tt(w) { for (var F = 0, k = w.length, A, U = 0, M = 0, T = 0, R = 0, X = [], G, N, $, Z = 0; Z < k; Z++) { switch (A = w[Z], N = { x: U, y: M, command: A[0] }, A[0]) { case "M": N.length = 0, T = U = A[1], R = M = A[2]; break; case "L": N.length = s(U, M, A[1], A[2]), U = A[1], M = A[2]; break; case "C": G = y(U, M, A[1], A[2], A[3], A[4], A[5], A[6]), $ = x(U, M, A[1], A[2], A[3], A[4], A[5], A[6]), N.iterator = G, N.angleFinder = $, N.length = Q(G, U, M), U = A[5], M = A[6]; break; case "Q": G = V(U, M, A[1], A[2], A[3], A[4]), $ = J(U, M, A[1], A[2], A[3], A[4]), N.iterator = G, N.angleFinder = $, N.length = Q(G, U, M), U = A[3], M = A[4]; break; case "Z": case "z": N.destX = T, N.destY = R, N.length = s(U, M, T, R), U = T, M = R; break }F += N.length, X.push(N) } return X.push({ length: F, x: U, y: M }), X } function it(w, F, k) { k || (k = tt(w)); for (var A = 0; F - k[A].length > 0 && A < k.length - 2;)F -= k[A].length, A++; var U = k[A], M = F / U.length, T = U.command, R = w[A], X; switch (T) { case "M": return { x: U.x, y: U.y, angle: 0 }; case "Z": case "z": return X = new t.Point(U.x, U.y).lerp(new t.Point(U.destX, U.destY), M), X.angle = Math.atan2(U.destY - U.y, U.destX - U.x), X; case "L": return X = new t.Point(U.x, U.y).lerp(new t.Point(R[1], R[2]), M), X.angle = Math.atan2(R[2] - U.y, R[1] - U.x), X; case "C": return rt(U, F); case "Q": return rt(U, F) } } function ot(w) { var F = [], k = [], A, U, M = t.rePathCommand, T = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*", R = "(" + T + ")" + t.commaWsp, X = "([01])" + t.commaWsp + "?", G = R + "?" + R + "?" + R + X + X + R + "?(" + T + ")", N = new RegExp(G, "g"), $, Z, O; if (!w || !w.match) return F; O = w.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi); for (var S = 0, E, L = O.length; S < L; S++) { A = O[S], Z = A.slice(1).trim(), k.length = 0; var I = A.charAt(0); if (E = [I], I.toLowerCase() === "a") for (var j; j = N.exec(Z);)for (var B = 1; B < j.length; B++)k.push(j[B]); else for (; $ = M.exec(Z);)k.push($[0]); for (var B = 0, H = k.length; B < H; B++)U = parseFloat(k[B]), isNaN(U) || E.push(U); var K = n[I.toLowerCase()], z = l[I] || I; if (E.length - 1 > K) for (var W = 1, q = E.length; W < q; W += K)F.push([I].concat(E.slice(W, W + K))), I = z; else F.push(E) } return F } function st(w, F) { var k = [], A, U = new t.Point(w[0].x, w[0].y), M = new t.Point(w[1].x, w[1].y), T = w.length, R = 1, X = 0, G = T > 2; for (F = F || 0, G && (R = w[2].x < M.x ? -1 : w[2].x === M.x ? 0 : 1, X = w[2].y < M.y ? -1 : w[2].y === M.y ? 0 : 1), k.push(["M", U.x - R * F, U.y - X * F]), A = 1; A < T; A++) { if (!U.eq(M)) { var N = U.midPointFrom(M); k.push(["Q", U.x, U.y, N.x, N.y]) } U = w[A], A + 1 < w.length && (M = w[A + 1]) } return G && (R = U.x > w[A - 2].x ? 1 : U.x === w[A - 2].x ? 0 : -1, X = U.y > w[A - 2].y ? 1 : U.y === w[A - 2].y ? 0 : -1), k.push(["L", U.x + R * F, U.y + X * F]), k } function nt(w, F, k) { return k && (F = t.util.multiplyTransformMatrices(F, [1, 0, 0, 1, -k.x, -k.y])), w.map(function (A) { for (var U = A.slice(0), M = {}, T = 1; T < A.length - 1; T += 2)M.x = A[T], M.y = A[T + 1], M = t.util.transformPoint(M, F), U[T] = M.x, U[T + 1] = M.y; return U }) } t.util.joinPath = function (w) { return w.map(function (F) { return F.join(" ") }).join(" ") }, t.util.parsePath = ot, t.util.makePathSimpler = c, t.util.getSmoothPathFromPoints = st, t.util.getPathSegmentsInfo = tt, t.util.getBoundsOfCurve = e, t.util.getPointOnPath = it, t.util.transformPath = nt }(), function () { var u = Array.prototype.slice; function n(e, o) { for (var c = u.call(arguments, 2), s = [], f = 0, d = e.length; f < d; f++)s[f] = c.length ? e[f][o].apply(e[f], c) : e[f][o].call(e[f]); return s } function l(e, o) { return r(e, o, function (c, s) { return c >= s }) } function h(e, o) { return r(e, o, function (c, s) { return c < s }) } function i(e, o) { for (var c = e.length; c--;)e[c] = o; return e } function r(e, o, c) { if (!(!e || e.length === 0)) { var s = e.length - 1, f = o ? e[s][o] : e[s]; if (o) for (; s--;)c(e[s][o], f) && (f = e[s][o]); else for (; s--;)c(e[s], f) && (f = e[s]); return f } } t.util.array = { fill: i, invoke: n, min: h, max: l } }(), function () { function u(l, h, i) { if (i) if (!t.isLikelyNode && h instanceof Element) l = h; else if (h instanceof Array) { l = []; for (var r = 0, e = h.length; r < e; r++)l[r] = u({}, h[r], i) } else if (h && typeof h == "object") for (var o in h) o === "canvas" || o === "group" ? l[o] = null : h.hasOwnProperty(o) && (l[o] = u({}, h[o], i)); else l = h; else for (var o in h) l[o] = h[o]; return l } function n(l, h) { return u({}, l, h) } t.util.object = { extend: u, clone: n }, t.util.object.extend(t.util, t.Observable) }(), function () { function u(r) { return r.replace(/-+(.)?/g, function (e, o) { return o ? o.toUpperCase() : "" }) } function n(r, e) { return r.charAt(0).toUpperCase() + (e ? r.slice(1) : r.slice(1).toLowerCase()) } function l(r) { return r.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function h(r) { var e = 0, o, c = []; for (e = 0, o; e < r.length; e++)(o = i(r, e)) !== !1 && c.push(o); return c } function i(r, e) { var o = r.charCodeAt(e); if (isNaN(o)) return ""; if (o < 55296 || o > 57343) return r.charAt(e); if (55296 <= o && o <= 56319) { if (r.length <= e + 1) throw "High surrogate without following low surrogate"; var c = r.charCodeAt(e + 1); if (56320 > c || c > 57343) throw "High surrogate without following low surrogate"; return r.charAt(e) + r.charAt(e + 1) } if (e === 0) throw "Low surrogate without preceding high surrogate"; var s = r.charCodeAt(e - 1); if (55296 > s || s > 56319) throw "Low surrogate without preceding high surrogate"; return !1 } t.util.string = { camelize: u, capitalize: n, escapeXml: l, graphemeSplit: h } }(), function () { var u = Array.prototype.slice, n = function () { }, l = function () { for (var o in { toString: 1 }) if (o === "toString") return !1; return !0 }(), h = function (o, c, s) { for (var f in c) f in o.prototype && typeof o.prototype[f] == "function" && (c[f] + "").indexOf("callSuper") > -1 ? o.prototype[f] = function (d) { return function () { var p = this.constructor.superclass; this.constructor.superclass = s; var m = c[d].apply(this, arguments); if (this.constructor.superclass = p, d !== "initialize") return m } }(f) : o.prototype[f] = c[f], l && (c.toString !== Object.prototype.toString && (o.prototype.toString = c.toString), c.valueOf !== Object.prototype.valueOf && (o.prototype.valueOf = c.valueOf)) }; function i() { } function r(o) { for (var c = null, s = this; s.constructor.superclass;) { var f = s.constructor.superclass.prototype[o]; if (s[o] !== f) { c = f; break } s = s.constructor.superclass.prototype } return c ? arguments.length > 1 ? c.apply(this, u.call(arguments, 1)) : c.call(this) : console.log("tried to callSuper " + o + ", method not found in prototype chain", this) } function e() { var o = null, c = u.call(arguments, 0); typeof c[0] == "function" && (o = c.shift()); function s() { this.initialize.apply(this, arguments) } s.superclass = o, s.subclasses = [], o && (i.prototype = o.prototype, s.prototype = new i, o.subclasses.push(s)); for (var f = 0, d = c.length; f < d; f++)h(s, c[f], o); return s.prototype.initialize || (s.prototype.initialize = n), s.prototype.constructor = s, s.prototype.callSuper = r, s } t.util.createClass = e }(), function () { var u = !!t.document.createElement("div").attachEvent, n = ["touchstart", "touchmove", "touchend"]; t.util.addListener = function (h, i, r, e) { h && h.addEventListener(i, r, u ? !1 : e) }, t.util.removeListener = function (h, i, r, e) { h && h.removeEventListener(i, r, u ? !1 : e) }; function l(h) { var i = h.changedTouches; return i && i[0] ? i[0] : h } t.util.getPointer = function (h) { var i = h.target, r = t.util.getScrollLeftTop(i), e = l(h); return { x: e.clientX + r.left, y: e.clientY + r.top } }, t.util.isTouchEvent = function (h) { return n.indexOf(h.type) > -1 || h.pointerType === "touch" } }(), function () { function u(e, o) { var c = e.style; if (!c) return e; if (typeof o == "string") return e.style.cssText += ";" + o, o.indexOf("opacity") > -1 ? r(e, o.match(/opacity:\s*(\d?\.?\d*)/)[1]) : e; for (var s in o) if (s === "opacity") r(e, o[s]); else { var f = s === "float" || s === "cssFloat" ? typeof c.styleFloat > "u" ? "cssFloat" : "styleFloat" : s; c.setProperty(f, o[s]) } return e } var n = t.document.createElement("div"), l = typeof n.style.opacity == "string", h = typeof n.style.filter == "string", i = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, r = function (e) { return e }; l ? r = function (e, o) { return e.style.opacity = o, e } : h && (r = function (e, o) { var c = e.style; return e.currentStyle && !e.currentStyle.hasLayout && (c.zoom = 1), i.test(c.filter) ? (o = o >= .9999 ? "" : "alpha(opacity=" + o * 100 + ")", c.filter = c.filter.replace(i, o)) : c.filter += " alpha(opacity=" + o * 100 + ")", e }), t.util.setStyle = u }(), function () { var u = Array.prototype.slice; function n(m) { return typeof m == "string" ? t.document.getElementById(m) : m } var l, h = function (m) { return u.call(m, 0) }; try { l = h(t.document.childNodes) instanceof Array } catch { } l || (h = function (m) { for (var y = new Array(m.length), x = m.length; x--;)y[x] = m[x]; return y }); function i(m, y) { var x = t.document.createElement(m); for (var P in y) P === "class" ? x.className = y[P] : P === "for" ? x.htmlFor = y[P] : x.setAttribute(P, y[P]); return x } function r(m, y) { m && (" " + m.className + " ").indexOf(" " + y + " ") === -1 && (m.className += (m.className ? " " : "") + y) } function e(m, y, x) { return typeof y == "string" && (y = i(y, x)), m.parentNode && m.parentNode.replaceChild(y, m), y.appendChild(m), y } function o(m) { for (var y = 0, x = 0, P = t.document.documentElement, D = t.document.body || { scrollLeft: 0, scrollTop: 0 }; m && (m.parentNode || m.host) && (m = m.parentNode || m.host, m === t.document ? (y = D.scrollLeft || P.scrollLeft || 0, x = D.scrollTop || P.scrollTop || 0) : (y += m.scrollLeft || 0, x += m.scrollTop || 0), !(m.nodeType === 1 && m.style.position === "fixed"));); return { left: y, top: x } } function c(m) { var y, x = m && m.ownerDocument, P = { left: 0, top: 0 }, D = { left: 0, top: 0 }, Y, V = { borderLeftWidth: "left", borderTopWidth: "top", paddingLeft: "left", paddingTop: "top" }; if (!x) return D; for (var J in V) D[V[J]] += parseInt(s(m, J), 10) || 0; return y = x.documentElement, typeof m.getBoundingClientRect < "u" && (P = m.getBoundingClientRect()), Y = o(m), { left: P.left + Y.left - (y.clientLeft || 0) + D.left, top: P.top + Y.top - (y.clientTop || 0) + D.top } } var s; t.document.defaultView && t.document.defaultView.getComputedStyle ? s = function (m, y) { var x = t.document.defaultView.getComputedStyle(m, null); return x ? x[y] : void 0 } : s = function (m, y) { var x = m.style[y]; return !x && m.currentStyle && (x = m.currentStyle[y]), x }, function () { var m = t.document.documentElement.style, y = "userSelect" in m ? "userSelect" : "MozUserSelect" in m ? "MozUserSelect" : "WebkitUserSelect" in m ? "WebkitUserSelect" : "KhtmlUserSelect" in m ? "KhtmlUserSelect" : ""; function x(D) { return typeof D.onselectstart < "u" && (D.onselectstart = t.util.falseFunction), y ? D.style[y] = "none" : typeof D.unselectable == "string" && (D.unselectable = "on"), D } function P(D) { return typeof D.onselectstart < "u" && (D.onselectstart = null), y ? D.style[y] = "" : typeof D.unselectable == "string" && (D.unselectable = ""), D } t.util.makeElementUnselectable = x, t.util.makeElementSelectable = P }(); function f(m) { var y = t.jsdomImplForWrapper(m); return y._canvas || y._image } function d(m) { if (t.isLikelyNode) { var y = t.jsdomImplForWrapper(m); y && (y._image = null, y._canvas = null, y._currentSrc = null, y._attributes = null, y._classList = null) } } function p(m, y) { m.imageSmoothingEnabled = m.imageSmoothingEnabled || m.webkitImageSmoothingEnabled || m.mozImageSmoothingEnabled || m.msImageSmoothingEnabled || m.oImageSmoothingEnabled, m.imageSmoothingEnabled = y } t.util.setImageSmoothing = p, t.util.getById = n, t.util.toArray = h, t.util.addClass = r, t.util.makeElement = i, t.util.wrapElement = e, t.util.getScrollLeftTop = o, t.util.getElementOffset = c, t.util.getNodeCanvas = f, t.util.cleanUpJsdomNode = d }(), function () { function u(h, i) { return h + (/\?/.test(h) ? "&" : "?") + i } function n() { } function l(h, i) { i || (i = {}); var r = i.method ? i.method.toUpperCase() : "GET", e = i.onComplete || function () { }, o = new t.window.XMLHttpRequest, c = i.body || i.parameters; return o.onreadystatechange = function () { o.readyState === 4 && (e(o), o.onreadystatechange = n) }, r === "GET" && (c = null, typeof i.parameters == "string" && (h = u(h, i.parameters))), o.open(r, h, !0), (r === "POST" || r === "PUT") && o.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), o.send(c), o } t.util.request = l }(), t.log = console.log, t.warn = console.warn, function () { var u = t.util.object.extend, n = t.util.object.clone, l = []; t.util.object.extend(l, { cancelAll: function () { var f = this.splice(0); return f.forEach(function (d) { d.cancel() }), f }, cancelByCanvas: function (f) { if (!f) return []; var d = this.filter(function (p) { return typeof p.target == "object" && p.target.canvas === f }); return d.forEach(function (p) { p.cancel() }), d }, cancelByTarget: function (f) { var d = this.findAnimationsByTarget(f); return d.forEach(function (p) { p.cancel() }), d }, findAnimationIndex: function (f) { return this.indexOf(this.findAnimation(f)) }, findAnimation: function (f) { return this.find(function (d) { return d.cancel === f }) }, findAnimationsByTarget: function (f) { return f ? this.filter(function (d) { return d.target === f }) : [] } }); function h() { return !1 } function i(f, d, p, m) { return -p * Math.cos(f / m * (Math.PI / 2)) + p + d } function r(f) { f || (f = {}); var d = !1, p, m = function () { var y = t.runningAnimations.indexOf(p); return y > -1 && t.runningAnimations.splice(y, 1)[0] }; return p = u(n(f), { cancel: function () { return d = !0, m() }, currentValue: "startValue" in f ? f.startValue : 0, completionRate: 0, durationRate: 0 }), t.runningAnimations.push(p), c(function (y) { var x = y || +new Date, P = f.duration || 500, D = x + P, Y, V = f.onChange || h, J = f.abort || h, Q = f.onComplete || h, rt = f.easing || i, tt = "startValue" in f ? f.startValue.length > 0 : !1, it = "startValue" in f ? f.startValue : 0, ot = "endValue" in f ? f.endValue : 100, st = f.byValue || (tt ? it.map(function (nt, w) { return ot[w] - it[w] }) : ot - it); f.onStart && f.onStart(), function nt(w) { Y = w || +new Date; var F = Y > D ? P : Y - x, k = F / P, A = tt ? it.map(function (M, T) { return rt(F, it[T], st[T], P) }) : rt(F, it, st, P), U = Math.abs(tt ? (A[0] - it[0]) / st[0] : (A - it) / st); if (p.currentValue = tt ? A.slice() : A, p.completionRate = U, p.durationRate = k, !d) { if (J(A, U, k)) { m(); return } if (Y > D) { p.currentValue = tt ? ot.slice() : ot, p.completionRate = 1, p.durationRate = 1, V(tt ? ot.slice() : ot, 1, 1), Q(ot, 1, 1), m(); return } else V(A, U, k), c(nt) } }(x) }), p.cancel } var e = t.window.requestAnimationFrame || t.window.webkitRequestAnimationFrame || t.window.mozRequestAnimationFrame || t.window.oRequestAnimationFrame || t.window.msRequestAnimationFrame || function (f) { return t.window.setTimeout(f, 1e3 / 60) }, o = t.window.cancelAnimationFrame || t.window.clearTimeout; function c() { return e.apply(t.window, arguments) } function s() { return o.apply(t.window, arguments) } t.util.animate = r, t.util.requestAnimFrame = c, t.util.cancelAnimFrame = s, t.runningAnimations = l }(), function () { function u(l, h, i) { var r = "rgba(" + parseInt(l[0] + i * (h[0] - l[0]), 10) + "," + parseInt(l[1] + i * (h[1] - l[1]), 10) + "," + parseInt(l[2] + i * (h[2] - l[2]), 10); return r += "," + (l && h ? parseFloat(l[3] + i * (h[3] - l[3])) : 1), r += ")", r } function n(l, h, i, r) { var e = new t.Color(l).getSource(), o = new t.Color(h).getSource(), c = r.onComplete, s = r.onChange; return r = r || {}, t.util.animate(t.util.object.extend(r, { duration: i || 500, startValue: e, endValue: o, byValue: o, easing: function (f, d, p, m) { var y = r.colorEasing ? r.colorEasing(f, m) : 1 - Math.cos(f / m * (Math.PI / 2)); return u(d, p, y) }, onComplete: function (f, d, p) { if (c) return c(u(o, o, 0), d, p) }, onChange: function (f, d, p) { if (s) { if (Array.isArray(f)) return s(u(f, f, 0), d, p); s(f, d, p) } } })) } t.util.animateColor = n }(), function () { function u(w, F, k, A) { return w < Math.abs(F) ? (w = F, A = k / 4) : F === 0 && w === 0 ? A = k / (2 * Math.PI) * Math.asin(1) : A = k / (2 * Math.PI) * Math.asin(F / w), { a: w, c: F, p: k, s: A } } function n(w, F, k) { return w.a * Math.pow(2, 10 * (F -= 1)) * Math.sin((F * k - w.s) * (2 * Math.PI) / w.p) } function l(w, F, k, A) { return k * ((w = w / A - 1) * w * w + 1) + F } function h(w, F, k, A) { return w /= A / 2, w < 1 ? k / 2 * w * w * w + F : k / 2 * ((w -= 2) * w * w + 2) + F } function i(w, F, k, A) { return k * (w /= A) * w * w * w + F } function r(w, F, k, A) { return -k * ((w = w / A - 1) * w * w * w - 1) + F } function e(w, F, k, A) { return w /= A / 2, w < 1 ? k / 2 * w * w * w * w + F : -k / 2 * ((w -= 2) * w * w * w - 2) + F } function o(w, F, k, A) { return k * (w /= A) * w * w * w * w + F } function c(w, F, k, A) { return k * ((w = w / A - 1) * w * w * w * w + 1) + F } function s(w, F, k, A) { return w /= A / 2, w < 1 ? k / 2 * w * w * w * w * w + F : k / 2 * ((w -= 2) * w * w * w * w + 2) + F } function f(w, F, k, A) { return -k * Math.cos(w / A * (Math.PI / 2)) + k + F } function d(w, F, k, A) { return k * Math.sin(w / A * (Math.PI / 2)) + F } function p(w, F, k, A) { return -k / 2 * (Math.cos(Math.PI * w / A) - 1) + F } function m(w, F, k, A) { return w === 0 ? F : k * Math.pow(2, 10 * (w / A - 1)) + F } function y(w, F, k, A) { return w === A ? F + k : k * (-Math.pow(2, -10 * w / A) + 1) + F } function x(w, F, k, A) { return w === 0 ? F : w === A ? F + k : (w /= A / 2, w < 1 ? k / 2 * Math.pow(2, 10 * (w - 1)) + F : k / 2 * (-Math.pow(2, -10 * --w) + 2) + F) } function P(w, F, k, A) { return -k * (Math.sqrt(1 - (w /= A) * w) - 1) + F } function D(w, F, k, A) { return k * Math.sqrt(1 - (w = w / A - 1) * w) + F } function Y(w, F, k, A) { return w /= A / 2, w < 1 ? -k / 2 * (Math.sqrt(1 - w * w) - 1) + F : k / 2 * (Math.sqrt(1 - (w -= 2) * w) + 1) + F } function V(w, F, k, A) { var U = 1.70158, M = 0, T = k; if (w === 0) return F; if (w /= A, w === 1) return F + k; M || (M = A * .3); var R = u(T, k, M, U); return -n(R, w, A) + F } function J(w, F, k, A) { var U = 1.70158, M = 0, T = k; if (w === 0) return F; if (w /= A, w === 1) return F + k; M || (M = A * .3); var R = u(T, k, M, U); return R.a * Math.pow(2, -10 * w) * Math.sin((w * A - R.s) * (2 * Math.PI) / R.p) + R.c + F } function Q(w, F, k, A) { var U = 1.70158, M = 0, T = k; if (w === 0) return F; if (w /= A / 2, w === 2) return F + k; M || (M = A * (.3 * 1.5)); var R = u(T, k, M, U); return w < 1 ? -.5 * n(R, w, A) + F : R.a * Math.pow(2, -10 * (w -= 1)) * Math.sin((w * A - R.s) * (2 * Math.PI) / R.p) * .5 + R.c + F } function rt(w, F, k, A, U) { return U === void 0 && (U = 1.70158), k * (w /= A) * w * ((U + 1) * w - U) + F } function tt(w, F, k, A, U) { return U === void 0 && (U = 1.70158), k * ((w = w / A - 1) * w * ((U + 1) * w + U) + 1) + F } function it(w, F, k, A, U) { return U === void 0 && (U = 1.70158), w /= A / 2, w < 1 ? k / 2 * (w * w * (((U *= 1.525) + 1) * w - U)) + F : k / 2 * ((w -= 2) * w * (((U *= 1.525) + 1) * w + U) + 2) + F } function ot(w, F, k, A) { return k - st(A - w, 0, k, A) + F } function st(w, F, k, A) { return (w /= A) < 1 / 2.75 ? k * (7.5625 * w * w) + F : w < 2 / 2.75 ? k * (7.5625 * (w -= 1.5 / 2.75) * w + .75) + F : w < 2.5 / 2.75 ? k * (7.5625 * (w -= 2.25 / 2.75) * w + .9375) + F : k * (7.5625 * (w -= 2.625 / 2.75) * w + .984375) + F } function nt(w, F, k, A) { return w < A / 2 ? ot(w * 2, 0, k, A) * .5 + F : st(w * 2 - A, 0, k, A) * .5 + k * .5 + F } t.util.ease = { easeInQuad: function (w, F, k, A) { return k * (w /= A) * w + F }, easeOutQuad: function (w, F, k, A) { return -k * (w /= A) * (w - 2) + F }, easeInOutQuad: function (w, F, k, A) { return w /= A / 2, w < 1 ? k / 2 * w * w + F : -k / 2 * (--w * (w - 2) - 1) + F }, easeInCubic: function (w, F, k, A) { return k * (w /= A) * w * w + F }, easeOutCubic: l, easeInOutCubic: h, easeInQuart: i, easeOutQuart: r, easeInOutQuart: e, easeInQuint: o, easeOutQuint: c, easeInOutQuint: s, easeInSine: f, easeOutSine: d, easeInOutSine: p, easeInExpo: m, easeOutExpo: y, easeInOutExpo: x, easeInCirc: P, easeOutCirc: D, easeInOutCirc: Y, easeInElastic: V, easeOutElastic: J, easeInOutElastic: Q, easeInBack: rt, easeOutBack: tt, easeInOutBack: it, easeInBounce: ot, easeOutBounce: st, easeInOutBounce: nt } }(), function (u) { var n = u.fabric || (u.fabric = {}), l = n.util.object.extend, h = n.util.object.clone, i = n.util.toFixed, r = n.util.parseUnit, e = n.util.multiplyTransformMatrices, o = ["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"], c = ["symbol", "image", "marker", "pattern", "view", "svg"], s = ["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"], f = ["symbol", "g", "a", "svg", "clipPath", "defs"], d = { cx: "left", x: "left", r: "radius", cy: "top", y: "top", display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" }, p = { stroke: "strokeOpacity", fill: "fillOpacity" }, m = "font-size", y = "clip-path"; n.svgValidTagNamesRegEx = D(o), n.svgViewBoxElementsRegEx = D(c), n.svgInvalidAncestorsRegEx = D(s), n.svgValidParentsRegEx = D(f), n.cssRules = {}, n.gradientDefs = {}, n.clipPaths = {}; function x(M) { return M in d ? d[M] : M } function P(M, T, R, X) { var G = Array.isArray(T), N; if ((M === "fill" || M === "stroke") && T === "none") T = ""; else { if (M === "strokeUniform") return T === "non-scaling-stroke"; if (M === "strokeDashArray") T === "none" ? T = null : T = T.replace(/,/g, " ").split(/\s+/).map(parseFloat); else if (M === "transformMatrix") R && R.transformMatrix ? T = e(R.transformMatrix, n.parseTransformAttribute(T)) : T = n.parseTransformAttribute(T); else if (M === "visible") T = T !== "none" && T !== "hidden", R && R.visible === !1 && (T = !1); else if (M === "opacity") T = parseFloat(T), R && typeof R.opacity < "u" && (T *= R.opacity); else if (M === "textAnchor") T = T === "start" ? "left" : T === "end" ? "right" : "center"; else if (M === "charSpacing") N = r(T, X) / X * 1e3; else if (M === "paintFirst") { var $ = T.indexOf("fill"), Z = T.indexOf("stroke"), T = "fill"; ($ > -1 && Z > -1 && Z < $ || $ === -1 && Z > -1) && (T = "stroke") } else { if (M === "href" || M === "xlink:href" || M === "font") return T; if (M === "imageSmoothing") return T === "optimizeQuality"; N = G ? T.map(r) : r(T, X) } } return !G && isNaN(N) ? T : N } function D(M) { return new RegExp("^(" + M.join("|") + ")\\b", "i") } function Y(M) { for (var T in p) if (!(typeof M[p[T]] > "u" || M[T] === "")) { if (typeof M[T] > "u") { if (!n.Object.prototype[T]) continue; M[T] = n.Object.prototype[T] } if (M[T].indexOf("url(") !== 0) { var R = new n.Color(M[T]); M[T] = R.setAlpha(i(R.getAlpha() * M[p[T]], 2)).toRgba() } } return M } function V(M, T) { var R, X = [], G, N, $; for (N = 0, $ = T.length; N < $; N++)R = T[N], G = M.getElementsByTagName(R), X = X.concat(Array.prototype.slice.call(G)); return X } n.parseTransformAttribute = function () { function M(W, q) { var et = n.util.cos(q[0]), at = n.util.sin(q[0]), lt = 0, ht = 0; q.length === 3 && (lt = q[1], ht = q[2]), W[0] = et, W[1] = at, W[2] = -at, W[3] = et, W[4] = lt - (et * lt - at * ht), W[5] = ht - (at * lt + et * ht) } function T(W, q) { var et = q[0], at = q.length === 2 ? q[1] : q[0]; W[0] = et, W[3] = at } function R(W, q, et) { W[et] = Math.tan(n.util.degreesToRadians(q[0])) } function X(W, q) { W[4] = q[0], q.length === 2 && (W[5] = q[1]) } var G = n.iMatrix, N = n.reNum, $ = n.commaWsp, Z = "(?:(skewX)\\s*\\(\\s*(" + N + ")\\s*\\))", O = "(?:(skewY)\\s*\\(\\s*(" + N + ")\\s*\\))", S = "(?:(rotate)\\s*\\(\\s*(" + N + ")(?:" + $ + "(" + N + ")" + $ + "(" + N + "))?\\s*\\))", E = "(?:(scale)\\s*\\(\\s*(" + N + ")(?:" + $ + "(" + N + "))?\\s*\\))", L = "(?:(translate)\\s*\\(\\s*(" + N + ")(?:" + $ + "(" + N + "))?\\s*\\))", I = "(?:(matrix)\\s*\\(\\s*(" + N + ")" + $ + "(" + N + ")" + $ + "(" + N + ")" + $ + "(" + N + ")" + $ + "(" + N + ")" + $ + "(" + N + ")\\s*\\))", j = "(?:" + I + "|" + L + "|" + E + "|" + S + "|" + Z + "|" + O + ")", B = "(?:" + j + "(?:" + $ + "*" + j + ")*)", H = "^\\s*(?:" + B + "?)\\s*$", K = new RegExp(H), z = new RegExp(j, "g"); return function (W) { var q = G.concat(), et = []; if (!W || W && !K.test(W)) return q; W.replace(z, function (lt) { var ht = new RegExp(j).exec(lt).filter(function (xt) { return !!xt }), ut = ht[1], ft = ht.slice(2).map(parseFloat); switch (ut) { case "translate": X(q, ft); break; case "rotate": ft[0] = n.util.degreesToRadians(ft[0]), M(q, ft); break; case "scale": T(q, ft); break; case "skewX": R(q, ft, 2); break; case "skewY": R(q, ft, 1); break; case "matrix": q = ft; break }et.push(q.concat()), q = G.concat() }); for (var at = et[0]; et.length > 1;)et.shift(), at = n.util.multiplyTransformMatrices(at, et[0]); return at } }(); function J(M, T) { var R, X; M.replace(/;\s*$/, "").split(";").forEach(function (G) { var N = G.split(":"); R = N[0].trim().toLowerCase(), X = N[1].trim(), T[R] = X }) } function Q(M, T) { var R, X; for (var G in M) typeof M[G] > "u" || (R = G.toLowerCase(), X = M[G], T[R] = X) } function rt(M, T) { var R = {}; for (var X in n.cssRules[T]) if (tt(M, X.split(" "))) for (var G in n.cssRules[T][X]) R[G] = n.cssRules[T][X][G]; return R } function tt(M, T) { var R, X = !0; return R = ot(M, T.pop()), R && T.length && (X = it(M, T)), R && X && T.length === 0 } function it(M, T) { for (var R, X = !0; M.parentNode && M.parentNode.nodeType === 1 && T.length;)X && (R = T.pop()), M = M.parentNode, X = ot(M, R); return T.length === 0 } function ot(M, T) { var R = M.nodeName, X = M.getAttribute("class"), G = M.getAttribute("id"), N, $; if (N = new RegExp("^" + R, "i"), T = T.replace(N, ""), G && T.length && (N = new RegExp("#" + G + "(?![a-zA-Z\\-]+)", "i"), T = T.replace(N, "")), X && T.length) for (X = X.split(" "), $ = X.length; $--;)N = new RegExp("\\." + X[$] + "(?![a-zA-Z\\-]+)", "i"), T = T.replace(N, ""); return T.length === 0 } function st(M, T) { var R; if (M.getElementById && (R = M.getElementById(T)), R) return R; var X, G, N, $ = M.getElementsByTagName("*"); for (G = 0, N = $.length; G < N; G++)if (X = $[G], T === X.getAttribute("id")) return X } function nt(M) { for (var T = V(M, ["use", "svg:use"]), R = 0; T.length && R < T.length;) { var X = T[R], G = X.getAttribute("xlink:href") || X.getAttribute("href"); if (G === null) return; var N = G.slice(1), $ = X.getAttribute("x") || 0, Z = X.getAttribute("y") || 0, O = st(M, N).cloneNode(!0), S = (O.getAttribute("transform") || "") + " translate(" + $ + ", " + Z + ")", E, L = T.length, I, j, B, H, K = n.svgNS; if (F(O), /^svg$/i.test(O.nodeName)) { var z = O.ownerDocument.createElementNS(K, "g"); for (j = 0, B = O.attributes, H = B.length; j < H; j++)I = B.item(j), z.setAttributeNS(K, I.nodeName, I.nodeValue); for (; O.firstChild;)z.appendChild(O.firstChild); O = z } for (j = 0, B = X.attributes, H = B.length; j < H; j++)I = B.item(j), !(I.nodeName === "x" || I.nodeName === "y" || I.nodeName === "xlink:href" || I.nodeName === "href") && (I.nodeName === "transform" ? S = I.nodeValue + " " + S : O.setAttribute(I.nodeName, I.nodeValue)); O.setAttribute("transform", S), O.setAttribute("instantiated_by_use", "1"), O.removeAttribute("id"), E = X.parentNode, E.replaceChild(O, X), T.length === L && R++ } } var w = new RegExp("^\\s*(" + n.reNum + "+)\\s*,?\\s*(" + n.reNum + "+)\\s*,?\\s*(" + n.reNum + "+)\\s*,?\\s*(" + n.reNum + "+)\\s*$"); function F(M) { if (!n.svgViewBoxElementsRegEx.test(M.nodeName)) return {}; var T = M.getAttribute("viewBox"), R = 1, X = 1, G = 0, N = 0, $, Z, O, S, E = M.getAttribute("width"), L = M.getAttribute("height"), I = M.getAttribute("x") || 0, j = M.getAttribute("y") || 0, B = M.getAttribute("preserveAspectRatio") || "", H = !T || !(T = T.match(w)), K = !E || !L || E === "100%" || L === "100%", z = H && K, W = {}, q = "", et = 0, at = 0; if (W.width = 0, W.height = 0, W.toBeParsed = z, H && (I || j) && M.parentNode && M.parentNode.nodeName !== "#document" && (q = " translate(" + r(I) + " " + r(j) + ") ", O = (M.getAttribute("transform") || "") + q, M.setAttribute("transform", O), M.removeAttribute("x"), M.removeAttribute("y")), z) return W; if (H) return W.width = r(E), W.height = r(L), W; if (G = -parseFloat(T[1]), N = -parseFloat(T[2]), $ = parseFloat(T[3]), Z = parseFloat(T[4]), W.minX = G, W.minY = N, W.viewBoxWidth = $, W.viewBoxHeight = Z, K ? (W.width = $, W.height = Z) : (W.width = r(E), W.height = r(L), R = W.width / $, X = W.height / Z), B = n.util.parsePreserveAspectRatioAttribute(B), B.alignX !== "none" && (B.meetOrSlice === "meet" && (X = R = R > X ? X : R), B.meetOrSlice === "slice" && (X = R = R > X ? R : X), et = W.width - $ * R, at = W.height - Z * R, B.alignX === "Mid" && (et /= 2), B.alignY === "Mid" && (at /= 2), B.alignX === "Min" && (et = 0), B.alignY === "Min" && (at = 0)), R === 1 && X === 1 && G === 0 && N === 0 && I === 0 && j === 0) return W; if ((I || j) && M.parentNode.nodeName !== "#document" && (q = " translate(" + r(I) + " " + r(j) + ") "), O = q + " matrix(" + R + " 0 0 " + X + " " + (G * R + et) + " " + (N * X + at) + ") ", M.nodeName === "svg") { for (S = M.ownerDocument.createElementNS(n.svgNS, "g"); M.firstChild;)S.appendChild(M.firstChild); M.appendChild(S) } else S = M, S.removeAttribute("x"), S.removeAttribute("y"), O = S.getAttribute("transform") + O; return S.setAttribute("transform", O), W } function k(M, T) { for (; M && (M = M.parentNode);)if (M.nodeName && T.test(M.nodeName.replace("svg:", "")) && !M.getAttribute("instantiated_by_use")) return !0; return !1 } n.parseSVGDocument = function (M, T, R, X) { if (M) { nt(M); var G = n.Object.__uid++, N, $, Z = F(M), O = n.util.toArray(M.getElementsByTagName("*")); if (Z.crossOrigin = X && X.crossOrigin, Z.svgUid = G, O.length === 0 && n.isLikelyNode) { O = M.selectNodes('//*[name(.)!="svg"]'); var S = []; for (N = 0, $ = O.length; N < $; N++)S[N] = O[N]; O = S } var E = O.filter(function (I) { return F(I), n.svgValidTagNamesRegEx.test(I.nodeName.replace("svg:", "")) && !k(I, n.svgInvalidAncestorsRegEx) }); if (!E || E && !E.length) { T && T([], {}); return } var L = {}; O.filter(function (I) { return I.nodeName.replace("svg:", "") === "clipPath" }).forEach(function (I) { var j = I.getAttribute("id"); L[j] = n.util.toArray(I.getElementsByTagName("*")).filter(function (B) { return n.svgValidTagNamesRegEx.test(B.nodeName.replace("svg:", "")) }) }), n.gradientDefs[G] = n.getGradientDefs(M), n.cssRules[G] = n.getCSSRules(M), n.clipPaths[G] = L, n.parseElements(E, function (I, j) { T && (T(I, Z, j, O), delete n.gradientDefs[G], delete n.cssRules[G], delete n.clipPaths[G]) }, h(Z), R, X) } }; function A(M, T) { var R = ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"], X = "xlink:href", G = T.getAttribute(X).slice(1), N = st(M, G); if (N && N.getAttribute(X) && A(M, N), R.forEach(function (Z) { N && !T.hasAttribute(Z) && N.hasAttribute(Z) && T.setAttribute(Z, N.getAttribute(Z)) }), !T.children.length) for (var $ = N.cloneNode(!0); $.firstChild;)T.appendChild($.firstChild); T.removeAttribute(X) } var U = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + n.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + n.reNum + "))?\\s+(.*)"); l(n, { parseFontDeclaration: function (M, T) { var R = M.match(U); if (R) { var X = R[1], G = R[3], N = R[4], $ = R[5], Z = R[6]; X && (T.fontStyle = X), G && (T.fontWeight = isNaN(parseFloat(G)) ? G : parseFloat(G)), N && (T.fontSize = r(N)), Z && (T.fontFamily = Z), $ && (T.lineHeight = $ === "normal" ? 1 : $) } }, getGradientDefs: function (M) { var T = ["linearGradient", "radialGradient", "svg:linearGradient", "svg:radialGradient"], R = V(M, T), X, G = 0, N = {}; for (G = R.length; G--;)X = R[G], X.getAttribute("xlink:href") && A(M, X), N[X.getAttribute("id")] = X; return N }, parseAttributes: function (M, T, R) { if (M) { var X, G = {}, N, $; typeof R > "u" && (R = M.getAttribute("svgUid")), M.parentNode && n.svgValidParentsRegEx.test(M.parentNode.nodeName) && (G = n.parseAttributes(M.parentNode, T, R)); var Z = T.reduce(function (B, H) { return X = M.getAttribute(H), X && (B[H] = X), B }, {}), O = l(rt(M, R), n.parseStyleAttribute(M)); Z = l(Z, O), O[y] && M.setAttribute(y, O[y]), N = $ = G.fontSize || n.Text.DEFAULT_SVG_FONT_SIZE, Z[m] && (Z[m] = N = r(Z[m], $)); var S, E, L = {}; for (var I in Z) S = x(I), E = P(S, Z[I], G, N), L[S] = E; L && L.font && n.parseFontDeclaration(L.font, L); var j = l(G, L); return n.svgValidParentsRegEx.test(M.nodeName) ? j : Y(j) } }, parseElements: function (M, T, R, X, G) { new n.ElementsParser(M, T, R, X, G).parse() }, parseStyleAttribute: function (M) { var T = {}, R = M.getAttribute("style"); return R && (typeof R == "string" ? J(R, T) : Q(R, T)), T }, parsePointsAttribute: function (M) { if (!M) return null; M = M.replace(/,/g, " ").trim(), M = M.split(/\s+/); var T = [], R, X; for (R = 0, X = M.length; R < X; R += 2)T.push({ x: parseFloat(M[R]), y: parseFloat(M[R + 1]) }); return T }, getCSSRules: function (M) { var T = M.getElementsByTagName("style"), R, X, G = {}, N; for (R = 0, X = T.length; R < X; R++) { var $ = T[R].textContent; $ = $.replace(/\/\*[\s\S]*?\*\//g, ""), $.trim() !== "" && (N = $.split("}"), N = N.filter(function (Z) { return Z.trim() }), N.forEach(function (Z) { var O = Z.split("{"), S = {}, E = O[1].trim(), L = E.split(";").filter(function (H) { return H.trim() }); for (R = 0, X = L.length; R < X; R++) { var I = L[R].split(":"), j = I[0].trim(), B = I[1].trim(); S[j] = B } Z = O[0].trim(), Z.split(",").forEach(function (H) { H = H.replace(/^svg/i, "").trim(), H !== "" && (G[H] ? n.util.object.extend(G[H], S) : G[H] = n.util.object.clone(S)) }) })) } return G }, loadSVGFromURL: function (M, T, R, X) { M = M.replace(/^\n\s*/, "").trim(), new n.util.request(M, { method: "get", onComplete: G }); function G(N) { var $ = N.responseXML; if (!$ || !$.documentElement) return T && T(null), !1; n.parseSVGDocument($.documentElement, function (Z, O, S, E) { T && T(Z, O, S, E) }, R, X) } }, loadSVGFromString: function (M, T, R, X) { var G = new n.window.DOMParser, N = G.parseFromString(M.trim(), "text/xml"); n.parseSVGDocument(N.documentElement, function ($, Z, O, S) { T($, Z, O, S) }, R, X) } }) }(a), t.ElementsParser = function (u, n, l, h, i, r) { this.elements = u, this.callback = n, this.options = l, this.reviver = h, this.svgUid = l && l.svgUid || 0, this.parsingOptions = i, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = r }, function (u) { u.parse = function () { this.instances = new Array(this.elements.length), this.numElements = this.elements.length, this.createObjects() }, u.createObjects = function () { var n = this; this.elements.forEach(function (l, h) { l.setAttribute("svgUid", n.svgUid), n.createObject(l, h) }) }, u.findTag = function (n) { return t[t.util.string.capitalize(n.tagName.replace("svg:", ""))] }, u.createObject = function (n, l) { var h = this.findTag(n); if (h && h.fromElement) try { h.fromElement(n, this.createCallback(l, n), this.options) } catch (i) { t.log(i) } else this.checkIfDone() }, u.createCallback = function (n, l) { var h = this; return function (i) { var r; h.resolveGradient(i, l, "fill"), h.resolveGradient(i, l, "stroke"), i instanceof t.Image && i._originalElement && (r = i.parsePreserveAspectRatioAttribute(l)), i._removeTransformMatrix(r), h.resolveClipPath(i, l), h.reviver && h.reviver(l, i), h.instances[n] = i, h.checkIfDone() } }, u.extractPropertyDefinition = function (n, l, h) { var i = n[l], r = this.regexUrl; if (r.test(i)) { r.lastIndex = 0; var e = r.exec(i)[1]; return r.lastIndex = 0, t[h][this.svgUid][e] } }, u.resolveGradient = function (n, l, h) { var i = this.extractPropertyDefinition(n, h, "gradientDefs"); if (i) { var r = l.getAttribute(h + "-opacity"), e = t.Gradient.fromElement(i, n, r, this.options); n.set(h, e) } }, u.createClipPathCallback = function (n, l) { return function (h) { h._removeTransformMatrix(), h.fillRule = h.clipRule, l.push(h) } }, u.resolveClipPath = function (n, l) { var h = this.extractPropertyDefinition(n, "clipPath", "clipPaths"), i, r, e, o, c, s; if (h) { o = [], e = t.util.invertTransform(n.calcTransformMatrix()); for (var f = h[0].parentNode, d = l; d.parentNode && d.getAttribute("clip-path") !== n.clipPath;)d = d.parentNode; d.parentNode.appendChild(f); for (var p = 0; p < h.length; p++)i = h[p], r = this.findTag(i), r.fromElement(i, this.createClipPathCallback(n, o), this.options); o.length === 1 ? h = o[0] : h = new t.Group(o), c = t.util.multiplyTransformMatrices(e, h.calcTransformMatrix()), h.clipPath && this.resolveClipPath(h, d); var s = t.util.qrDecompose(c); h.flipX = !1, h.flipY = !1, h.set("scaleX", s.scaleX), h.set("scaleY", s.scaleY), h.angle = s.angle, h.skewX = s.skewX, h.skewY = 0, h.setPositionByOrigin({ x: s.translateX, y: s.translateY }, "center", "center"), n.clipPath = h } else delete n.clipPath }, u.checkIfDone = function () { --this.numElements === 0 && (this.instances = this.instances.filter(function (n) { return n != null }), this.callback(this.instances, this.elements)) } }(t.ElementsParser.prototype), function (u) { var n = u.fabric || (u.fabric = {}); if (n.Point) { n.warn("fabric.Point is already defined"); return } n.Point = l; function l(h, i) { this.x = h, this.y = i } l.prototype = { type: "point", constructor: l, add: function (h) { return new l(this.x + h.x, this.y + h.y) }, addEquals: function (h) { return this.x += h.x, this.y += h.y, this }, scalarAdd: function (h) { return new l(this.x + h, this.y + h) }, scalarAddEquals: function (h) { return this.x += h, this.y += h, this }, subtract: function (h) { return new l(this.x - h.x, this.y - h.y) }, subtractEquals: function (h) { return this.x -= h.x, this.y -= h.y, this }, scalarSubtract: function (h) { return new l(this.x - h, this.y - h) }, scalarSubtractEquals: function (h) { return this.x -= h, this.y -= h, this }, multiply: function (h) { return new l(this.x * h, this.y * h) }, multiplyEquals: function (h) { return this.x *= h, this.y *= h, this }, divide: function (h) { return new l(this.x / h, this.y / h) }, divideEquals: function (h) { return this.x /= h, this.y /= h, this }, eq: function (h) { return this.x === h.x && this.y === h.y }, lt: function (h) { return this.x < h.x && this.y < h.y }, lte: function (h) { return this.x <= h.x && this.y <= h.y }, gt: function (h) { return this.x > h.x && this.y > h.y }, gte: function (h) { return this.x >= h.x && this.y >= h.y }, lerp: function (h, i) { return typeof i > "u" && (i = .5), i = Math.max(Math.min(1, i), 0), new l(this.x + (h.x - this.x) * i, this.y + (h.y - this.y) * i) }, distanceFrom: function (h) { var i = this.x - h.x, r = this.y - h.y; return Math.sqrt(i * i + r * r) }, midPointFrom: function (h) { return this.lerp(h) }, min: function (h) { return new l(Math.min(this.x, h.x), Math.min(this.y, h.y)) }, max: function (h) { return new l(Math.max(this.x, h.x), Math.max(this.y, h.y)) }, toString: function () { return this.x + "," + this.y }, setXY: function (h, i) { return this.x = h, this.y = i, this }, setX: function (h) { return this.x = h, this }, setY: function (h) { return this.y = h, this }, setFromPoint: function (h) { return this.x = h.x, this.y = h.y, this }, swap: function (h) { var i = this.x, r = this.y; this.x = h.x, this.y = h.y, h.x = i, h.y = r }, clone: function () { return new l(this.x, this.y) } } }(a), function (u) { var n = u.fabric || (u.fabric = {}); if (n.Intersection) { n.warn("fabric.Intersection is already defined"); return } function l(h) { this.status = h, this.points = [] } n.Intersection = l, n.Intersection.prototype = { constructor: l, appendPoint: function (h) { return this.points.push(h), this }, appendPoints: function (h) { return this.points = this.points.concat(h), this } }, n.Intersection.intersectLineLine = function (h, i, r, e) { var o, c = (e.x - r.x) * (h.y - r.y) - (e.y - r.y) * (h.x - r.x), s = (i.x - h.x) * (h.y - r.y) - (i.y - h.y) * (h.x - r.x), f = (e.y - r.y) * (i.x - h.x) - (e.x - r.x) * (i.y - h.y); if (f !== 0) { var d = c / f, p = s / f; 0 <= d && d <= 1 && 0 <= p && p <= 1 ? (o = new l("Intersection"), o.appendPoint(new n.Point(h.x + d * (i.x - h.x), h.y + d * (i.y - h.y)))) : o = new l } else c === 0 || s === 0 ? o = new l("Coincident") : o = new l("Parallel"); return o }, n.Intersection.intersectLinePolygon = function (h, i, r) { var e = new l, o = r.length, c, s, f, d; for (d = 0; d < o; d++)c = r[d], s = r[(d + 1) % o], f = l.intersectLineLine(h, i, c, s), e.appendPoints(f.points); return e.points.length > 0 && (e.status = "Intersection"), e }, n.Intersection.intersectPolygonPolygon = function (h, i) { var r = new l, e = h.length, o; for (o = 0; o < e; o++) { var c = h[o], s = h[(o + 1) % e], f = l.intersectLinePolygon(c, s, i); r.appendPoints(f.points) } return r.points.length > 0 && (r.status = "Intersection"), r }, n.Intersection.intersectPolygonRectangle = function (h, i, r) { var e = i.min(r), o = i.max(r), c = new n.Point(o.x, e.y), s = new n.Point(e.x, o.y), f = l.intersectLinePolygon(e, c, h), d = l.intersectLinePolygon(c, o, h), p = l.intersectLinePolygon(o, s, h), m = l.intersectLinePolygon(s, e, h), y = new l; return y.appendPoints(f.points), y.appendPoints(d.points), y.appendPoints(p.points), y.appendPoints(m.points), y.points.length > 0 && (y.status = "Intersection"), y } }(a), function (u) { var n = u.fabric || (u.fabric = {}); if (n.Color) { n.warn("fabric.Color is already defined."); return } function l(i) { i ? this._tryParsingColor(i) : this.setSource([0, 0, 0, 1]) } n.Color = l, n.Color.prototype = { _tryParsingColor: function (i) { var r; i in l.colorNameMap && (i = l.colorNameMap[i]), i === "transparent" && (r = [255, 255, 255, 0]), r || (r = l.sourceFromHex(i)), r || (r = l.sourceFromRgb(i)), r || (r = l.sourceFromHsl(i)), r || (r = [0, 0, 0, 1]), r && this.setSource(r) }, _rgbToHsl: function (i, r, e) { i /= 255, r /= 255, e /= 255; var o, c, s, f = n.util.array.max([i, r, e]), d = n.util.array.min([i, r, e]); if (s = (f + d) / 2, f === d) o = c = 0; else { var p = f - d; switch (c = s > .5 ? p / (2 - f - d) : p / (f + d), f) { case i: o = (r - e) / p + (r < e ? 6 : 0); break; case r: o = (e - i) / p + 2; break; case e: o = (i - r) / p + 4; break }o /= 6 } return [Math.round(o * 360), Math.round(c * 100), Math.round(s * 100)] }, getSource: function () { return this._source }, setSource: function (i) { this._source = i }, toRgb: function () { var i = this.getSource(); return "rgb(" + i[0] + "," + i[1] + "," + i[2] + ")" }, toRgba: function () { var i = this.getSource(); return "rgba(" + i[0] + "," + i[1] + "," + i[2] + "," + i[3] + ")" }, toHsl: function () { var i = this.getSource(), r = this._rgbToHsl(i[0], i[1], i[2]); return "hsl(" + r[0] + "," + r[1] + "%," + r[2] + "%)" }, toHsla: function () { var i = this.getSource(), r = this._rgbToHsl(i[0], i[1], i[2]); return "hsla(" + r[0] + "," + r[1] + "%," + r[2] + "%," + i[3] + ")" }, toHex: function () { var i = this.getSource(), r, e, o; return r = i[0].toString(16), r = r.length === 1 ? "0" + r : r, e = i[1].toString(16), e = e.length === 1 ? "0" + e : e, o = i[2].toString(16), o = o.length === 1 ? "0" + o : o, r.toUpperCase() + e.toUpperCase() + o.toUpperCase() }, toHexa: function () { var i = this.getSource(), r; return r = Math.round(i[3] * 255), r = r.toString(16), r = r.length === 1 ? "0" + r : r, this.toHex() + r.toUpperCase() }, getAlpha: function () { return this.getSource()[3] }, setAlpha: function (i) { var r = this.getSource(); return r[3] = i, this.setSource(r), this }, toGrayscale: function () { var i = this.getSource(), r = parseInt((i[0] * .3 + i[1] * .59 + i[2] * .11).toFixed(0), 10), e = i[3]; return this.setSource([r, r, r, e]), this }, toBlackWhite: function (i) { var r = this.getSource(), e = (r[0] * .3 + r[1] * .59 + r[2] * .11).toFixed(0), o = r[3]; return i = i || 127, e = Number(e) < Number(i) ? 0 : 255, this.setSource([e, e, e, o]), this }, overlayWith: function (i) { i instanceof l || (i = new l(i)); var r = [], e = this.getAlpha(), o = .5, c = this.getSource(), s = i.getSource(), f; for (f = 0; f < 3; f++)r.push(Math.round(c[f] * (1 - o) + s[f] * o)); return r[3] = e, this.setSource(r), this } }, n.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i, n.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i, n.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, n.Color.colorNameMap = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#00FFFF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000000", blanchedalmond: "#FFEBCD", blue: "#0000FF", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#00FFFF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#FF00FF", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#00FF00", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#FF00FF", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#663399", red: "#FF0000", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFFFFF", whitesmoke: "#F5F5F5", yellow: "#FFFF00", yellowgreen: "#9ACD32" }; function h(i, r, e) { return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i + (r - i) * 6 * e : e < 1 / 2 ? r : e < 2 / 3 ? i + (r - i) * (2 / 3 - e) * 6 : i } n.Color.fromRgb = function (i) { return l.fromSource(l.sourceFromRgb(i)) }, n.Color.sourceFromRgb = function (i) { var r = i.match(l.reRGBa); if (r) { var e = parseInt(r[1], 10) / (/%$/.test(r[1]) ? 100 : 1) * (/%$/.test(r[1]) ? 255 : 1), o = parseInt(r[2], 10) / (/%$/.test(r[2]) ? 100 : 1) * (/%$/.test(r[2]) ? 255 : 1), c = parseInt(r[3], 10) / (/%$/.test(r[3]) ? 100 : 1) * (/%$/.test(r[3]) ? 255 : 1); return [parseInt(e, 10), parseInt(o, 10), parseInt(c, 10), r[4] ? parseFloat(r[4]) : 1] } }, n.Color.fromRgba = l.fromRgb, n.Color.fromHsl = function (i) { return l.fromSource(l.sourceFromHsl(i)) }, n.Color.sourceFromHsl = function (i) { var r = i.match(l.reHSLa); if (r) { var e = (parseFloat(r[1]) % 360 + 360) % 360 / 360, o = parseFloat(r[2]) / (/%$/.test(r[2]) ? 100 : 1), c = parseFloat(r[3]) / (/%$/.test(r[3]) ? 100 : 1), s, f, d; if (o === 0) s = f = d = c; else { var p = c <= .5 ? c * (o + 1) : c + o - c * o, m = c * 2 - p; s = h(m, p, e + 1 / 3), f = h(m, p, e), d = h(m, p, e - 1 / 3) } return [Math.round(s * 255), Math.round(f * 255), Math.round(d * 255), r[4] ? parseFloat(r[4]) : 1] } }, n.Color.fromHsla = l.fromHsl, n.Color.fromHex = function (i) { return l.fromSource(l.sourceFromHex(i)) }, n.Color.sourceFromHex = function (i) { if (i.match(l.reHex)) { var r = i.slice(i.indexOf("#") + 1), e = r.length === 3 || r.length === 4, o = r.length === 8 || r.length === 4, c = e ? r.charAt(0) + r.charAt(0) : r.substring(0, 2), s = e ? r.charAt(1) + r.charAt(1) : r.substring(2, 4), f = e ? r.charAt(2) + r.charAt(2) : r.substring(4, 6), d = o ? e ? r.charAt(3) + r.charAt(3) : r.substring(6, 8) : "FF"; return [parseInt(c, 16), parseInt(s, 16), parseInt(f, 16), parseFloat((parseInt(d, 16) / 255).toFixed(2))] } }, n.Color.fromSource = function (i) { var r = new l; return r.setSource(i), r } }(a), function (u) { var n = u.fabric || (u.fabric = {}), l = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], h = ["ns", "nesw", "ew", "nwse"], i = {}, r = "left", e = "top", o = "right", c = "bottom", s = "center", f = { top: c, bottom: e, left: o, right: r, center: s }, d = n.util.radiansToDegrees, p = Math.sign || function (S) { return (S > 0) - (S < 0) || +S }; function m(S, E) { var L = S.angle + d(Math.atan2(E.y, E.x)) + 360; return Math.round(L % 360 / 45) } function y(S, E) { var L = E.transform.target, I = L.canvas, j = n.util.object.clone(E); j.target = L, I && I.fire("object:" + S, j), L.fire(S, E) } function x(S, E) { var L = E.canvas, I = L.uniScaleKey, j = S[I]; return L.uniformScaling && !j || !L.uniformScaling && j } function P(S) { return S.originX === s && S.originY === s } function D(S, E, L) { var I = S.lockScalingX, j = S.lockScalingY; return !!(I && j || !E && (I || j) && L || I && E === "x" || j && E === "y") } function Y(S, E, L) { var I = "not-allowed", j = x(S, L), B = ""; if (E.x !== 0 && E.y === 0 ? B = "x" : E.x === 0 && E.y !== 0 && (B = "y"), D(L, B, j)) return I; var H = m(L, E); return l[H] + "-resize" } function V(S, E, L) { var I = "not-allowed"; if (E.x !== 0 && L.lockSkewingY || E.y !== 0 && L.lockSkewingX) return I; var j = m(L, E) % 4; return h[j] + "-resize" } function J(S, E, L) { return S[L.canvas.altActionKey] ? i.skewCursorStyleHandler(S, E, L) : i.scaleCursorStyleHandler(S, E, L) } function Q(S, E, L) { var I = S[L.canvas.altActionKey]; if (E.x === 0) return I ? "skewX" : "scaleY"; if (E.y === 0) return I ? "skewY" : "scaleX" } function rt(S, E, L) { return L.lockRotation ? "not-allowed" : E.cursorStyle } function tt(S, E, L, I) { return { e: S, transform: E, pointer: { x: L, y: I } } } function it(S) { return function (E, L, I, j) { var B = L.target, H = B.getCenterPoint(), K = B.translateToOriginPoint(H, L.originX, L.originY), z = S(E, L, I, j); return B.setPositionByOrigin(K, L.originX, L.originY), z } } function ot(S, E) { return function (L, I, j, B) { var H = E(L, I, j, B); return H && y(S, tt(L, I, j, B)), H } } function st(S, E, L, I, j) { var B = S.target, H = B.controls[S.corner], K = B.canvas.getZoom(), z = B.padding / K, W = B.toLocalPoint(new n.Point(I, j), E, L); return W.x >= z && (W.x -= z), W.x <= -z && (W.x += z), W.y >= z && (W.y -= z), W.y <= z && (W.y += z), W.x -= H.offsetX, W.y -= H.offsetY, W } function nt(S) { return S.flipX !== S.flipY } function w(S, E, L, I, j) { if (S[E] !== 0) { var B = S._getTransformedDimensions()[I], H = j / B * S[L]; S.set(L, H) } } function F(S, E, L, I) { var j = E.target, B = j._getTransformedDimensions(0, j.skewY), H = st(E, E.originX, E.originY, L, I), K = Math.abs(H.x * 2) - B.x, z = j.skewX, W; K < 2 ? W = 0 : (W = d(Math.atan2(K / j.scaleX, B.y / j.scaleY)), E.originX === r && E.originY === c && (W = -W), E.originX === o && E.originY === e && (W = -W), nt(j) && (W = -W)); var q = z !== W; if (q) { var et = j._getTransformedDimensions().y; j.set("skewX", W), w(j, "skewY", "scaleY", "y", et) } return q } function k(S, E, L, I) { var j = E.target, B = j._getTransformedDimensions(j.skewX, 0), H = st(E, E.originX, E.originY, L, I), K = Math.abs(H.y * 2) - B.y, z = j.skewY, W; K < 2 ? W = 0 : (W = d(Math.atan2(K / j.scaleY, B.x / j.scaleX)), E.originX === r && E.originY === c && (W = -W), E.originX === o && E.originY === e && (W = -W), nt(j) && (W = -W)); var q = z !== W; if (q) { var et = j._getTransformedDimensions().x; j.set("skewY", W), w(j, "skewX", "scaleX", "x", et) } return q } function A(S, E, L, I) { var j = E.target, B = j.skewX, H, K = E.originY; if (j.lockSkewingX) return !1; if (B === 0) { var z = st(E, s, s, L, I); z.x > 0 ? H = r : H = o } else B > 0 && (H = K === e ? r : o), B < 0 && (H = K === e ? o : r), nt(j) && (H = H === r ? o : r); E.originX = H; var W = ot("skewing", it(F)); return W(S, E, L, I) } function U(S, E, L, I) { var j = E.target, B = j.skewY, H, K = E.originX; if (j.lockSkewingY) return !1; if (B === 0) { var z = st(E, s, s, L, I); z.y > 0 ? H = e : H = c } else B > 0 && (H = K === r ? e : c), B < 0 && (H = K === r ? c : e), nt(j) && (H = H === e ? c : e); E.originY = H; var W = ot("skewing", it(k)); return W(S, E, L, I) } function M(S, E, L, I) { var j = E, B = j.target, H = B.translateToOriginPoint(B.getCenterPoint(), j.originX, j.originY); if (B.lockRotation) return !1; var K = Math.atan2(j.ey - H.y, j.ex - H.x), z = Math.atan2(I - H.y, L - H.x), W = d(z - K + j.theta), q = !0; if (B.snapAngle > 0) { var et = B.snapAngle, at = B.snapThreshold || et, lt = Math.ceil(W / et) * et, ht = Math.floor(W / et) * et; Math.abs(W - ht) < at ? W = ht : Math.abs(W - lt) < at && (W = lt) } return W < 0 && (W = 360 + W), W %= 360, q = B.angle !== W, B.angle = W, q } function T(S, E, L, I, j) { j = j || {}; var B = E.target, H = B.lockScalingX, K = B.lockScalingY, z = j.by, W, q, et, at, lt = x(S, B), ht = D(B, z, lt), ut, ft, xt = E.gestureScale; if (ht) return !1; if (xt) q = E.scaleX * xt, et = E.scaleY * xt; else { if (W = st(E, E.originX, E.originY, L, I), ut = z !== "y" ? p(W.x) : 1, ft = z !== "x" ? p(W.y) : 1, E.signX || (E.signX = ut), E.signY || (E.signY = ft), B.lockScalingFlip && (E.signX !== ut || E.signY !== ft)) return !1; if (at = B._getTransformedDimensions(), lt && !z) { var Rt = Math.abs(W.x) + Math.abs(W.y), It = E.original, oe = Math.abs(at.x * It.scaleX / B.scaleX) + Math.abs(at.y * It.scaleY / B.scaleY), Ee = Rt / oe; q = It.scaleX * Ee, et = It.scaleY * Ee } else q = Math.abs(W.x * B.scaleX / at.x), et = Math.abs(W.y * B.scaleY / at.y); P(E) && (q *= 2, et *= 2), E.signX !== ut && z !== "y" && (E.originX = f[E.originX], q *= -1, E.signX = ut), E.signY !== ft && z !== "x" && (E.originY = f[E.originY], et *= -1, E.signY = ft) } var Pt = B.scaleX, Bt = B.scaleY; return z ? (z === "x" && B.set("scaleX", q), z === "y" && B.set("scaleY", et)) : (!H && B.set("scaleX", q), !K && B.set("scaleY", et)), Pt !== B.scaleX || Bt !== B.scaleY } function R(S, E, L, I) { return T(S, E, L, I) } function X(S, E, L, I) { return T(S, E, L, I, { by: "x" }) } function G(S, E, L, I) { return T(S, E, L, I, { by: "y" }) } function N(S, E, L, I) { return S[E.target.canvas.altActionKey] ? i.skewHandlerX(S, E, L, I) : i.scalingY(S, E, L, I) } function $(S, E, L, I) { return S[E.target.canvas.altActionKey] ? i.skewHandlerY(S, E, L, I) : i.scalingX(S, E, L, I) } function Z(S, E, L, I) { var j = E.target, B = st(E, E.originX, E.originY, L, I), H = j.strokeWidth / (j.strokeUniform ? j.scaleX : 1), K = P(E) ? 2 : 1, z = j.width, W = Math.abs(B.x * K / j.scaleX) - H; return j.set("width", Math.max(W, 0)), z !== W } function O(S, E, L, I) { var j = E.target, B = L - E.offsetX, H = I - E.offsetY, K = !j.get("lockMovementX") && j.left !== B, z = !j.get("lockMovementY") && j.top !== H; return K && j.set("left", B), z && j.set("top", H), (K || z) && y("moving", tt(S, E, L, I)), K || z } i.scaleCursorStyleHandler = Y, i.skewCursorStyleHandler = V, i.scaleSkewCursorStyleHandler = J, i.rotationWithSnapping = ot("rotating", it(M)), i.scalingEqually = ot("scaling", it(R)), i.scalingX = ot("scaling", it(X)), i.scalingY = ot("scaling", it(G)), i.scalingYOrSkewingX = N, i.scalingXOrSkewingY = $, i.changeWidth = ot("resizing", it(Z)), i.skewHandlerX = A, i.skewHandlerY = U, i.dragHandler = O, i.scaleOrSkewActionName = Q, i.rotationStyleHandler = rt, i.fireEvent = y, i.wrapWithFixedAnchor = it, i.wrapWithFireEvent = ot, i.getLocalPoint = st, n.controlsUtils = i }(a), function (u) { var n = u.fabric || (u.fabric = {}), l = n.util.degreesToRadians, h = n.controlsUtils; function i(e, o, c, s, f) { s = s || {}; var d = this.sizeX || s.cornerSize || f.cornerSize, p = this.sizeY || s.cornerSize || f.cornerSize, m = typeof s.transparentCorners < "u" ? s.transparentCorners : f.transparentCorners, y = m ? "stroke" : "fill", x = !m && (s.cornerStrokeColor || f.cornerStrokeColor), P = o, D = c, Y; e.save(), e.fillStyle = s.cornerColor || f.cornerColor, e.strokeStyle = s.cornerStrokeColor || f.cornerStrokeColor, d > p ? (Y = d, e.scale(1, p / d), D = c * d / p) : p > d ? (Y = p, e.scale(d / p, 1), P = o * p / d) : Y = d, e.lineWidth = 1, e.beginPath(), e.arc(P, D, Y / 2, 0, 2 * Math.PI, !1), e[y](), x && e.stroke(), e.restore() } function r(e, o, c, s, f) { s = s || {}; var d = this.sizeX || s.cornerSize || f.cornerSize, p = this.sizeY || s.cornerSize || f.cornerSize, m = typeof s.transparentCorners < "u" ? s.transparentCorners : f.transparentCorners, y = m ? "stroke" : "fill", x = !m && (s.cornerStrokeColor || f.cornerStrokeColor), P = d / 2, D = p / 2; e.save(), e.fillStyle = s.cornerColor || f.cornerColor, e.strokeStyle = s.cornerStrokeColor || f.cornerStrokeColor, e.lineWidth = 1, e.translate(o, c), e.rotate(l(f.angle)), e[y + "Rect"](-P, -D, d, p), x && e.strokeRect(-P, -D, d, p), e.restore() } h.renderCircleControl = i, h.renderSquareControl = r }(a), function (u) { var n = u.fabric || (u.fabric = {}); function l(h) { for (var i in h) this[i] = h[i] } n.Control = l, n.Control.prototype = { visible: !0, actionName: "scale", angle: 0, x: 0, y: 0, offsetX: 0, offsetY: 0, sizeX: null, sizeY: null, touchSizeX: null, touchSizeY: null, cursorStyle: "crosshair", withConnection: !1, actionHandler: function () { }, mouseDownHandler: function () { }, mouseUpHandler: function () { }, getActionHandler: function () { return this.actionHandler }, getMouseDownHandler: function () { return this.mouseDownHandler }, getMouseUpHandler: function () { return this.mouseUpHandler }, cursorStyleHandler: function (h, i) { return i.cursorStyle }, getActionName: function (h, i) { return i.actionName }, getVisibility: function (h, i) { var r = h._controlsVisibility; return r && typeof r[i] < "u" ? r[i] : this.visible }, setVisibility: function (h) { this.visible = h }, positionHandler: function (h, i) { var r = n.util.transformPoint({ x: this.x * h.x + this.offsetX, y: this.y * h.y + this.offsetY }, i); return r }, calcCornerCoords: function (h, i, r, e, o) { var c, s, f, d, p = o ? this.touchSizeX : this.sizeX, m = o ? this.touchSizeY : this.sizeY; if (p && m && p !== m) { var y = Math.atan2(m, p), x = Math.sqrt(p * p + m * m) / 2, P = y - n.util.degreesToRadians(h), D = Math.PI / 2 - y - n.util.degreesToRadians(h); c = x * n.util.cos(P), s = x * n.util.sin(P), f = x * n.util.cos(D), d = x * n.util.sin(D) } else { var Y = p && m ? p : i; x = Y * .7071067812; var P = n.util.degreesToRadians(45 - h); c = f = x * n.util.cos(P), s = d = x * n.util.sin(P) } return { tl: { x: r - d, y: e - f }, tr: { x: r + c, y: e - s }, bl: { x: r - c, y: e + s }, br: { x: r + d, y: e + f } } }, render: function (h, i, r, e, o) { switch (e = e || {}, e.cornerStyle || o.cornerStyle) { case "circle": n.controlsUtils.renderCircleControl.call(this, h, i, r, e, o); break; default: n.controlsUtils.renderSquareControl.call(this, h, i, r, e, o) } } } }(a), function () {
    function u(r, e) { var o = r.getAttribute("style"), c = r.getAttribute("offset") || 0, s, f, d, p; if (c = parseFloat(c) / (/%$/.test(c) ? 100 : 1), c = c < 0 ? 0 : c > 1 ? 1 : c, o) { var m = o.split(/\s*;\s*/); for (m[m.length - 1] === "" && m.pop(), p = m.length; p--;) { var y = m[p].split(/\s*:\s*/), x = y[0].trim(), P = y[1].trim(); x === "stop-color" ? s = P : x === "stop-opacity" && (d = P) } } return s || (s = r.getAttribute("stop-color") || "rgb(0,0,0)"), d || (d = r.getAttribute("stop-opacity")), s = new t.Color(s), f = s.getAlpha(), d = isNaN(parseFloat(d)) ? 1 : parseFloat(d), d *= f * e, { offset: c, color: s.toRgb(), opacity: d } } function n(r) { return { x1: r.getAttribute("x1") || 0, y1: r.getAttribute("y1") || 0, x2: r.getAttribute("x2") || "100%", y2: r.getAttribute("y2") || 0 } } function l(r) { return { x1: r.getAttribute("fx") || r.getAttribute("cx") || "50%", y1: r.getAttribute("fy") || r.getAttribute("cy") || "50%", r1: 0, x2: r.getAttribute("cx") || "50%", y2: r.getAttribute("cy") || "50%", r2: r.getAttribute("r") || "50%" } } var h = t.util.object.clone; t.Gradient = t.util.createClass({
        offsetX: 0, offsetY: 0, gradientTransform: null, gradientUnits: "pixels", type: "linear", initialize: function (r) { r || (r = {}), r.coords || (r.coords = {}); var e, o = this; Object.keys(r).forEach(function (c) { o[c] = r[c] }), this.id ? this.id += "_" + t.Object.__uid++ : this.id = t.Object.__uid++, e = { x1: r.coords.x1 || 0, y1: r.coords.y1 || 0, x2: r.coords.x2 || 0, y2: r.coords.y2 || 0 }, this.type === "radial" && (e.r1 = r.coords.r1 || 0, e.r2 = r.coords.r2 || 0), this.coords = e, this.colorStops = r.colorStops.slice() }, addColorStop: function (r) { for (var e in r) { var o = new t.Color(r[e]); this.colorStops.push({ offset: parseFloat(e), color: o.toRgb(), opacity: o.getAlpha() }) } return this }, toObject: function (r) { var e = { type: this.type, coords: this.coords, colorStops: this.colorStops, offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform }; return t.util.populateWithProperties(this, e, r), e }, toSVG: function (r, f) {
            var o = h(this.coords, !0), c, s, f = f || {}, d, p, m = h(this.colorStops, !0), y = o.r1 > o.r2, x = this.gradientTransform ? this.gradientTransform.concat() : t.iMatrix.concat(), P = -this.offsetX, D = -this.offsetY, Y = !!f.additionalTransform, V = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox"; if (m.sort(function (it, ot) { return it.offset - ot.offset }), V === "objectBoundingBox" ? (P /= r.width, D /= r.height) : (P += r.width / 2, D += r.height / 2), r.type === "path" && this.gradientUnits !== "percentage" && (P -= r.pathOffset.x, D -= r.pathOffset.y), x[4] -= P, x[5] -= D, p = 'id="SVGID_' + this.id + '" gradientUnits="' + V + '"', p += ' gradientTransform="' + (Y ? f.additionalTransform + " " : "") + t.util.matrixToSVG(x) + '" ', this.type === "linear" ? d = ["<linearGradient ", p, ' x1="', o.x1, '" y1="', o.y1, '" x2="', o.x2, '" y2="', o.y2, `">
`] : this.type === "radial" && (d = ["<radialGradient ", p, ' cx="', y ? o.x1 : o.x2, '" cy="', y ? o.y1 : o.y2, '" r="', y ? o.r1 : o.r2, '" fx="', y ? o.x2 : o.x1, '" fy="', y ? o.y2 : o.y1, `">
`]), this.type === "radial") { if (y) for (m = m.concat(), m.reverse(), c = 0, s = m.length; c < s; c++)m[c].offset = 1 - m[c].offset; var J = Math.min(o.r1, o.r2); if (J > 0) { var Q = Math.max(o.r1, o.r2), rt = J / Q; for (c = 0, s = m.length; c < s; c++)m[c].offset += rt * (1 - m[c].offset) } } for (c = 0, s = m.length; c < s; c++) {
                var tt = m[c]; d.push("<stop ", 'offset="', tt.offset * 100 + "%", '" style="stop-color:', tt.color, typeof tt.opacity < "u" ? ";stop-opacity: " + tt.opacity : ";", `"/>
`)
            } return d.push(this.type === "linear" ? `</linearGradient>
`: `</radialGradient>
`), d.join("")
        }, toLive: function (r) { var e, o = t.util.object.clone(this.coords), c, s; if (this.type) { for (this.type === "linear" ? e = r.createLinearGradient(o.x1, o.y1, o.x2, o.y2) : this.type === "radial" && (e = r.createRadialGradient(o.x1, o.y1, o.r1, o.x2, o.y2, o.r2)), c = 0, s = this.colorStops.length; c < s; c++) { var f = this.colorStops[c].color, d = this.colorStops[c].opacity, p = this.colorStops[c].offset; typeof d < "u" && (f = new t.Color(f).setAlpha(d).toRgba()), e.addColorStop(p, f) } return e } }
    }), t.util.object.extend(t.Gradient, { fromElement: function (r, e, o, c) { var s = parseFloat(o) / (/%$/.test(o) ? 100 : 1); s = s < 0 ? 0 : s > 1 ? 1 : s, isNaN(s) && (s = 1); var f = r.getElementsByTagName("stop"), d, p = r.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage", m = r.getAttribute("gradientTransform") || "", y = [], x, P, D = 0, Y = 0, V; for (r.nodeName === "linearGradient" || r.nodeName === "LINEARGRADIENT" ? (d = "linear", x = n(r)) : (d = "radial", x = l(r)), P = f.length; P--;)y.push(u(f[P], s)); V = t.parseTransformAttribute(m), i(e, x, c, p), p === "pixels" && (D = -e.left, Y = -e.top); var J = new t.Gradient({ id: r.getAttribute("id"), type: d, coords: x, colorStops: y, gradientUnits: p, gradientTransform: V, offsetX: D, offsetY: Y }); return J } }); function i(r, e, o, c) { var s, f; Object.keys(e).forEach(function (d) { s = e[d], s === "Infinity" ? f = 1 : s === "-Infinity" ? f = 0 : (f = parseFloat(e[d], 10), typeof s == "string" && /^(\d+\.\d+)%|(\d+)%$/.test(s) && (f *= .01, c === "pixels" && ((d === "x1" || d === "x2" || d === "r2") && (f *= o.viewBoxWidth || o.width), (d === "y1" || d === "y2") && (f *= o.viewBoxHeight || o.height)))), e[d] = f }) }
}(), function () {
    var u = t.util.toFixed; t.Pattern = t.util.createClass({
        repeat: "repeat", offsetX: 0, offsetY: 0, crossOrigin: "", patternTransform: null, initialize: function (n, l) { if (n || (n = {}), this.id = t.Object.__uid++, this.setOptions(n), !n.source || n.source && typeof n.source != "string") { l && l(this); return } else { var h = this; this.source = t.util.createImage(), t.util.loadImage(n.source, function (i, r) { h.source = i, l && l(h, r) }, null, this.crossOrigin) } }, toObject: function (n) { var l = t.Object.NUM_FRACTION_DIGITS, h, i; return typeof this.source.src == "string" ? h = this.source.src : typeof this.source == "object" && this.source.toDataURL && (h = this.source.toDataURL()), i = { type: "pattern", source: h, repeat: this.repeat, crossOrigin: this.crossOrigin, offsetX: u(this.offsetX, l), offsetY: u(this.offsetY, l), patternTransform: this.patternTransform ? this.patternTransform.concat() : null }, t.util.populateWithProperties(this, i, n), i }, toSVG: function (n) {
            var l = typeof this.source == "function" ? this.source() : this.source, h = l.width / n.width, i = l.height / n.height, r = this.offsetX / n.width, e = this.offsetY / n.height, o = ""; return (this.repeat === "repeat-x" || this.repeat === "no-repeat") && (i = 1, e && (i += Math.abs(e))), (this.repeat === "repeat-y" || this.repeat === "no-repeat") && (h = 1, r && (h += Math.abs(r))), l.src ? o = l.src : l.toDataURL && (o = l.toDataURL()), '<pattern id="SVGID_' + this.id + '" x="' + r + '" y="' + e + '" width="' + h + '" height="' + i + `">
<image x="0" y="0" width="`+ l.width + '" height="' + l.height + '" xlink:href="' + o + `"></image>
</pattern>
`}, setOptions: function (n) { for (var l in n) this[l] = n[l] }, toLive: function (n) { var l = this.source; return !l || typeof l.src < "u" && (!l.complete || l.naturalWidth === 0 || l.naturalHeight === 0) ? "" : n.createPattern(l, this.repeat) }
    })
}(), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.toFixed; if (n.Shadow) { n.warn("fabric.Shadow is already defined."); return } n.Shadow = n.util.createClass({
        color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1, initialize: function (h) { typeof h == "string" && (h = this._parseShadow(h)); for (var i in h) this[i] = h[i]; this.id = n.Object.__uid++ }, _parseShadow: function (h) { var i = h.trim(), r = n.Shadow.reOffsetsAndBlur.exec(i) || [], e = i.replace(n.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)"; return { color: e.trim(), offsetX: parseFloat(r[1], 10) || 0, offsetY: parseFloat(r[2], 10) || 0, blur: parseFloat(r[3], 10) || 0 } }, toString: function () { return [this.offsetX, this.offsetY, this.blur, this.color].join("px ") }, toSVG: function (h) {
            var i = 40, r = 40, e = n.Object.NUM_FRACTION_DIGITS, o = n.util.rotateVector({ x: this.offsetX, y: this.offsetY }, n.util.degreesToRadians(-h.angle)), c = 20, s = new n.Color(this.color); return h.width && h.height && (i = l((Math.abs(o.x) + this.blur) / h.width, e) * 100 + c, r = l((Math.abs(o.y) + this.blur) / h.height, e) * 100 + c), h.flipX && (o.x *= -1), h.flipY && (o.y *= -1), '<filter id="SVGID_' + this.id + '" y="-' + r + '%" height="' + (100 + 2 * r) + '%" x="-' + i + '%" width="' + (100 + 2 * i) + `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`+ l(this.blur ? this.blur / 2 : 0, e) + `"></feGaussianBlur>
	<feOffset dx="`+ l(o.x, e) + '" dy="' + l(o.y, e) + `" result="oBlur" ></feOffset>
	<feFlood flood-color="`+ s.toRgb() + '" flood-opacity="' + s.getAlpha() + `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`}, toObject: function () { if (this.includeDefaultValues) return { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling }; var h = {}, i = n.Shadow.prototype; return ["color", "blur", "offsetX", "offsetY", "affectStroke", "nonScaling"].forEach(function (r) { this[r] !== i[r] && (h[r] = this[r]) }, this), h }
    }), n.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/
}(a), function () {
    if (t.StaticCanvas) { t.warn("fabric.StaticCanvas is already defined."); return } var u = t.util.object.extend, n = t.util.getElementOffset, l = t.util.removeFromArray, h = t.util.toFixed, i = t.util.transformPoint, r = t.util.invertTransform, e = t.util.getNodeCanvas, o = t.util.createCanvasElement, c = new Error("Could not initialize `canvas` element"); t.StaticCanvas = t.util.createClass(t.CommonMethods, {
        initialize: function (s, f) { f || (f = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(s, f) }, backgroundColor: "", backgroundImage: null, overlayColor: "", overlayImage: null, includeDefaultValues: !0, stateful: !1, renderOnAddRemove: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, imageSmoothingEnabled: !0, viewportTransform: t.iMatrix.concat(), backgroundVpt: !0, overlayVpt: !0, enableRetinaScaling: !0, vptCoords: {}, skipOffscreen: !0, clipPath: void 0, _initStatic: function (s, f) { var d = this.requestRenderAllBound; this._objects = [], this._createLowerCanvas(s), this._initOptions(f), this.interactive || this._initRetinaScaling(), f.overlayImage && this.setOverlayImage(f.overlayImage, d), f.backgroundImage && this.setBackgroundImage(f.backgroundImage, d), f.backgroundColor && this.setBackgroundColor(f.backgroundColor, d), f.overlayColor && this.setOverlayColor(f.overlayColor, d), this.calcOffset() }, _isRetinaScaling: function () { return t.devicePixelRatio > 1 && this.enableRetinaScaling }, getRetinaScaling: function () { return this._isRetinaScaling() ? Math.max(1, t.devicePixelRatio) : 1 }, _initRetinaScaling: function () { if (this._isRetinaScaling()) { var s = t.devicePixelRatio; this.__initRetinaScaling(s, this.lowerCanvasEl, this.contextContainer), this.upperCanvasEl && this.__initRetinaScaling(s, this.upperCanvasEl, this.contextTop) } }, __initRetinaScaling: function (s, f, d) { f.setAttribute("width", this.width * s), f.setAttribute("height", this.height * s), d.scale(s, s) }, calcOffset: function () { return this._offset = n(this.lowerCanvasEl), this }, setOverlayImage: function (s, f, d) { return this.__setBgOverlayImage("overlayImage", s, f, d) }, setBackgroundImage: function (s, f, d) { return this.__setBgOverlayImage("backgroundImage", s, f, d) }, setOverlayColor: function (s, f) { return this.__setBgOverlayColor("overlayColor", s, f) }, setBackgroundColor: function (s, f) { return this.__setBgOverlayColor("backgroundColor", s, f) }, __setBgOverlayImage: function (s, f, d, p) { return typeof f == "string" ? t.util.loadImage(f, function (m, y) { if (m) { var x = new t.Image(m, p); this[s] = x, x.canvas = this } d && d(m, y) }, this, p && p.crossOrigin) : (p && f.setOptions(p), this[s] = f, f && (f.canvas = this), d && d(f, !1)), this }, __setBgOverlayColor: function (s, f, d) { return this[s] = f, this._initGradient(f, s), this._initPattern(f, s, d), this }, _createCanvasElement: function () { var s = o(); if (!s || (s.style || (s.style = {}), typeof s.getContext > "u")) throw c; return s }, _initOptions: function (s) { var f = this.lowerCanvasEl; this._setOptions(s), this.width = this.width || parseInt(f.width, 10) || 0, this.height = this.height || parseInt(f.height, 10) || 0, this.lowerCanvasEl.style && (f.width = this.width, f.height = this.height, f.style.width = this.width + "px", f.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice()) }, _createLowerCanvas: function (s) { s && s.getContext ? this.lowerCanvasEl = s : this.lowerCanvasEl = t.util.getById(s) || this._createCanvasElement(), t.util.addClass(this.lowerCanvasEl, "lower-canvas"), this._originalCanvasStyle = this.lowerCanvasEl.style, this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d") }, getWidth: function () { return this.width }, getHeight: function () { return this.height }, setWidth: function (s, f) { return this.setDimensions({ width: s }, f) }, setHeight: function (s, f) { return this.setDimensions({ height: s }, f) }, setDimensions: function (s, f) { var d; f = f || {}; for (var p in s) d = s[p], f.cssOnly || (this._setBackstoreDimension(p, s[p]), d += "px", this.hasLostContext = !0), f.backstoreOnly || this._setCssDimension(p, d); return this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop), this._initRetinaScaling(), this.calcOffset(), f.cssOnly || this.requestRenderAll(), this }, _setBackstoreDimension: function (s, f) { return this.lowerCanvasEl[s] = f, this.upperCanvasEl && (this.upperCanvasEl[s] = f), this.cacheCanvasEl && (this.cacheCanvasEl[s] = f), this[s] = f, this }, _setCssDimension: function (s, f) { return this.lowerCanvasEl.style[s] = f, this.upperCanvasEl && (this.upperCanvasEl.style[s] = f), this.wrapperEl && (this.wrapperEl.style[s] = f), this }, getZoom: function () { return this.viewportTransform[0] }, setViewportTransform: function (s) { var f = this._activeObject, d = this.backgroundImage, p = this.overlayImage, m, y, x; for (this.viewportTransform = s, y = 0, x = this._objects.length; y < x; y++)m = this._objects[y], m.group || m.setCoords(!0); return f && f.setCoords(), d && d.setCoords(!0), p && p.setCoords(!0), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll(), this }, zoomToPoint: function (s, f) { var d = s, p = this.viewportTransform.slice(0); s = i(s, r(this.viewportTransform)), p[0] = f, p[3] = f; var m = i(s, p); return p[4] += d.x - m.x, p[5] += d.y - m.y, this.setViewportTransform(p) }, setZoom: function (s) { return this.zoomToPoint(new t.Point(0, 0), s), this }, absolutePan: function (s) { var f = this.viewportTransform.slice(0); return f[4] = -s.x, f[5] = -s.y, this.setViewportTransform(f) }, relativePan: function (s) { return this.absolutePan(new t.Point(-s.x - this.viewportTransform[4], -s.y - this.viewportTransform[5])) }, getElement: function () { return this.lowerCanvasEl }, _onObjectAdded: function (s) { this.stateful && s.setupState(), s._set("canvas", this), s.setCoords(), this.fire("object:added", { target: s }), s.fire("added") }, _onObjectRemoved: function (s) { this.fire("object:removed", { target: s }), s.fire("removed"), delete s.canvas }, clearContext: function (s) { return s.clearRect(0, 0, this.width, this.height), this }, getContext: function () { return this.contextContainer }, clear: function () { return this.remove.apply(this, this.getObjects()), this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers && (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = !1), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll(), this }, renderAll: function () { var s = this.contextContainer; return this.renderCanvas(s, this._objects), this }, renderAndReset: function () { this.isRendering = 0, this.renderAll() }, requestRenderAll: function () { return this.isRendering || (this.isRendering = t.util.requestAnimFrame(this.renderAndResetBound)), this }, calcViewportBoundaries: function () { var s = {}, f = this.width, d = this.height, p = r(this.viewportTransform); return s.tl = i({ x: 0, y: 0 }, p), s.br = i({ x: f, y: d }, p), s.tr = new t.Point(s.br.x, s.tl.y), s.bl = new t.Point(s.tl.x, s.br.y), this.vptCoords = s, s }, cancelRequestedRender: function () { this.isRendering && (t.util.cancelAnimFrame(this.isRendering), this.isRendering = 0) }, renderCanvas: function (s, f) { var d = this.viewportTransform, p = this.clipPath; this.cancelRequestedRender(), this.calcViewportBoundaries(), this.clearContext(s), t.util.setImageSmoothing(s, this.imageSmoothingEnabled), this.fire("before:render", { ctx: s }), this._renderBackground(s), s.save(), s.transform(d[0], d[1], d[2], d[3], d[4], d[5]), this._renderObjects(s, f), s.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(s), p && (p.canvas = this, p.shouldCache(), p._transformDone = !0, p.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(s)), this._renderOverlay(s), this.controlsAboveOverlay && this.interactive && this.drawControls(s), this.fire("after:render", { ctx: s }) }, drawClipPathOnCanvas: function (s) { var f = this.viewportTransform, d = this.clipPath; s.save(), s.transform(f[0], f[1], f[2], f[3], f[4], f[5]), s.globalCompositeOperation = "destination-in", d.transform(s), s.scale(1 / d.zoomX, 1 / d.zoomY), s.drawImage(d._cacheCanvas, -d.cacheTranslationX, -d.cacheTranslationY), s.restore() }, _renderObjects: function (s, f) { var d, p; for (d = 0, p = f.length; d < p; ++d)f[d] && f[d].render(s) }, _renderBackgroundOrOverlay: function (s, f) { var d = this[f + "Color"], p = this[f + "Image"], m = this.viewportTransform, y = this[f + "Vpt"]; if (!(!d && !p)) { if (d) { s.save(), s.beginPath(), s.moveTo(0, 0), s.lineTo(this.width, 0), s.lineTo(this.width, this.height), s.lineTo(0, this.height), s.closePath(), s.fillStyle = d.toLive ? d.toLive(s, this) : d, y && s.transform(m[0], m[1], m[2], m[3], m[4], m[5]), s.transform(1, 0, 0, 1, d.offsetX || 0, d.offsetY || 0); var x = d.gradientTransform || d.patternTransform; x && s.transform(x[0], x[1], x[2], x[3], x[4], x[5]), s.fill(), s.restore() } p && (s.save(), y && s.transform(m[0], m[1], m[2], m[3], m[4], m[5]), p.render(s), s.restore()) } }, _renderBackground: function (s) { this._renderBackgroundOrOverlay(s, "background") }, _renderOverlay: function (s) { this._renderBackgroundOrOverlay(s, "overlay") }, getCenter: function () { return { top: this.height / 2, left: this.width / 2 } }, getCenterPoint: function () { return new t.Point(this.width / 2, this.height / 2) }, centerObjectH: function (s) { return this._centerObject(s, new t.Point(this.getCenterPoint().x, s.getCenterPoint().y)) }, centerObjectV: function (s) { return this._centerObject(s, new t.Point(s.getCenterPoint().x, this.getCenterPoint().y)) }, centerObject: function (s) { var f = this.getCenterPoint(); return this._centerObject(s, f) }, viewportCenterObject: function (s) { var f = this.getVpCenter(); return this._centerObject(s, f) }, viewportCenterObjectH: function (s) { var f = this.getVpCenter(); return this._centerObject(s, new t.Point(f.x, s.getCenterPoint().y)), this }, viewportCenterObjectV: function (s) { var f = this.getVpCenter(); return this._centerObject(s, new t.Point(s.getCenterPoint().x, f.y)) }, getVpCenter: function () { var s = this.getCenterPoint(), f = r(this.viewportTransform); return i(s, f) }, _centerObject: function (s, f) { return s.setPositionByOrigin(f, "center", "center"), s.setCoords(), this.renderOnAddRemove && this.requestRenderAll(), this }, toDatalessJSON: function (s) { return this.toDatalessObject(s) }, toObject: function (s) { return this._toObjectMethod("toObject", s) }, toDatalessObject: function (s) { return this._toObjectMethod("toDatalessObject", s) }, _toObjectMethod: function (s, f) { var d = this.clipPath, p = { version: t.version, objects: this._toObjects(s, f) }; return d && !d.excludeFromExport && (p.clipPath = this._toObject(this.clipPath, s, f)), u(p, this.__serializeBgOverlay(s, f)), t.util.populateWithProperties(this, p, f), p }, _toObjects: function (s, f) { return this._objects.filter(function (d) { return !d.excludeFromExport }).map(function (d) { return this._toObject(d, s, f) }, this) }, _toObject: function (s, f, d) { var p; this.includeDefaultValues || (p = s.includeDefaultValues, s.includeDefaultValues = !1); var m = s[f](d); return this.includeDefaultValues || (s.includeDefaultValues = p), m }, __serializeBgOverlay: function (s, f) { var d = {}, p = this.backgroundImage, m = this.overlayImage, y = this.backgroundColor, x = this.overlayColor; return y && y.toObject ? y.excludeFromExport || (d.background = y.toObject(f)) : y && (d.background = y), x && x.toObject ? x.excludeFromExport || (d.overlay = x.toObject(f)) : x && (d.overlay = x), p && !p.excludeFromExport && (d.backgroundImage = this._toObject(p, s, f)), m && !m.excludeFromExport && (d.overlayImage = this._toObject(m, s, f)), d }, svgViewportTransformation: !0, toSVG: function (s, f) {
            s || (s = {}), s.reviver = f; var d = []; return this._setSVGPreamble(d, s), this._setSVGHeader(d, s), this.clipPath && d.push('<g clip-path="url(#' + this.clipPath.clipPathId + `)" >
`), this._setSVGBgOverlayColor(d, "background"), this._setSVGBgOverlayImage(d, "backgroundImage", f), this._setSVGObjects(d, f), this.clipPath && d.push(`</g>
`), this._setSVGBgOverlayColor(d, "overlay"), this._setSVGBgOverlayImage(d, "overlayImage", f), d.push("</svg>"), d.join("")
        }, _setSVGPreamble: function (s, f) {
            f.suppressPreamble || s.push('<?xml version="1.0" encoding="', f.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`)
        }, _setSVGHeader: function (s, f) {
            var d = f.width || this.width, p = f.height || this.height, m, y = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', x = t.Object.NUM_FRACTION_DIGITS; f.viewBox ? y = 'viewBox="' + f.viewBox.x + " " + f.viewBox.y + " " + f.viewBox.width + " " + f.viewBox.height + '" ' : this.svgViewportTransformation && (m = this.viewportTransform, y = 'viewBox="' + h(-m[4] / m[0], x) + " " + h(-m[5] / m[3], x) + " " + h(this.width / m[0], x) + " " + h(this.height / m[3], x) + '" '), s.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', d, '" ', 'height="', p, '" ', y, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", t.version, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(f), `</defs>
`)
        }, createSVGClipPathMarkup: function (s) {
            var f = this.clipPath; return f ? (f.clipPathId = "CLIPPATH_" + t.Object.__uid++, '<clipPath id="' + f.clipPathId + `" >
`+ this.clipPath.toClipPathSVG(s.reviver) + `</clipPath>
`) : ""
        }, createSVGRefElementsMarkup: function () { var s = this, f = ["background", "overlay"].map(function (d) { var p = s[d + "Color"]; if (p && p.toLive) { var m = s[d + "Vpt"], y = s.viewportTransform, x = { width: s.width / (m ? y[0] : 1), height: s.height / (m ? y[3] : 1) }; return p.toSVG(x, { additionalTransform: m ? t.util.matrixToSVG(y) : "" }) } }); return f.join("") }, createSVGFontFacesMarkup: function () {
            var s = "", f = {}, d, p, m, y, x, P, D, Y, V, J = t.fontPaths, Q = []; for (this._objects.forEach(function tt(it) { Q.push(it), it._objects && it._objects.forEach(tt) }), Y = 0, V = Q.length; Y < V; Y++)if (d = Q[Y], p = d.fontFamily, !(d.type.indexOf("text") === -1 || f[p] || !J[p]) && (f[p] = !0, !!d.styles)) { m = d.styles; for (x in m) { y = m[x]; for (D in y) P = y[D], p = P.fontFamily, !f[p] && J[p] && (f[p] = !0) } } for (var rt in f) s += [`		@font-face {
`, "			font-family: '", rt, `';
`, "			src: url('", J[rt], `');
`, `		}
`].join(""); return s && (s = ['	<style type="text/css">', `<![CDATA[
`, s, "]]>", `</style>
`].join("")), s
        }, _setSVGObjects: function (s, f) { var d, p, m, y = this._objects; for (p = 0, m = y.length; p < m; p++)d = y[p], !d.excludeFromExport && this._setSVGObject(s, d, f) }, _setSVGObject: function (s, f, d) { s.push(f.toSVG(d)) }, _setSVGBgOverlayImage: function (s, f, d) { this[f] && !this[f].excludeFromExport && this[f].toSVG && s.push(this[f].toSVG(d)) }, _setSVGBgOverlayColor: function (s, f) {
            var d = this[f + "Color"], p = this.viewportTransform, m = this.width, y = this.height; if (d) if (d.toLive) {
                var x = d.repeat, P = t.util.invertTransform(p), D = this[f + "Vpt"], Y = D ? t.util.matrixToSVG(P) : ""; s.push('<rect transform="' + Y + " translate(", m / 2, ",", y / 2, ')"', ' x="', d.offsetX - m / 2, '" y="', d.offsetY - y / 2, '" ', 'width="', x === "repeat-y" || x === "no-repeat" ? d.source.width : m, '" height="', x === "repeat-x" || x === "no-repeat" ? d.source.height : y, '" fill="url(#SVGID_' + d.id + ')"', `></rect>
`)
            } else s.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', d, '"', `></rect>
`)
        }, sendToBack: function (s) { if (!s) return this; var f = this._activeObject, d, p, m; if (s === f && s.type === "activeSelection") for (m = f._objects, d = m.length; d--;)p = m[d], l(this._objects, p), this._objects.unshift(p); else l(this._objects, s), this._objects.unshift(s); return this.renderOnAddRemove && this.requestRenderAll(), this }, bringToFront: function (s) { if (!s) return this; var f = this._activeObject, d, p, m; if (s === f && s.type === "activeSelection") for (m = f._objects, d = 0; d < m.length; d++)p = m[d], l(this._objects, p), this._objects.push(p); else l(this._objects, s), this._objects.push(s); return this.renderOnAddRemove && this.requestRenderAll(), this }, sendBackwards: function (s, f) { if (!s) return this; var d = this._activeObject, p, m, y, x, P, D = 0; if (s === d && s.type === "activeSelection") for (P = d._objects, p = 0; p < P.length; p++)m = P[p], y = this._objects.indexOf(m), y > 0 + D && (x = y - 1, l(this._objects, m), this._objects.splice(x, 0, m)), D++; else y = this._objects.indexOf(s), y !== 0 && (x = this._findNewLowerIndex(s, y, f), l(this._objects, s), this._objects.splice(x, 0, s)); return this.renderOnAddRemove && this.requestRenderAll(), this }, _findNewLowerIndex: function (s, f, d) { var p, m; if (d) for (p = f, m = f - 1; m >= 0; --m) { var y = s.intersectsWithObject(this._objects[m]) || s.isContainedWithinObject(this._objects[m]) || this._objects[m].isContainedWithinObject(s); if (y) { p = m; break } } else p = f - 1; return p }, bringForward: function (s, f) { if (!s) return this; var d = this._activeObject, p, m, y, x, P, D = 0; if (s === d && s.type === "activeSelection") for (P = d._objects, p = P.length; p--;)m = P[p], y = this._objects.indexOf(m), y < this._objects.length - 1 - D && (x = y + 1, l(this._objects, m), this._objects.splice(x, 0, m)), D++; else y = this._objects.indexOf(s), y !== this._objects.length - 1 && (x = this._findNewUpperIndex(s, y, f), l(this._objects, s), this._objects.splice(x, 0, s)); return this.renderOnAddRemove && this.requestRenderAll(), this }, _findNewUpperIndex: function (s, f, d) { var p, m, y; if (d) for (p = f, m = f + 1, y = this._objects.length; m < y; ++m) { var x = s.intersectsWithObject(this._objects[m]) || s.isContainedWithinObject(this._objects[m]) || this._objects[m].isContainedWithinObject(s); if (x) { p = m; break } } else p = f + 1; return p }, moveTo: function (s, f) { return l(this._objects, s), this._objects.splice(f, 0, s), this.renderOnAddRemove && this.requestRenderAll() }, dispose: function () { return this.isRendering && (t.util.cancelAnimFrame(this.isRendering), this.isRendering = 0), this.forEachObject(function (s) { s.dispose && s.dispose() }), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, this.lowerCanvasEl.classList.remove("lower-canvas"), t.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle), delete this._originalCanvasStyle, this.lowerCanvasEl.setAttribute("width", this.width), this.lowerCanvasEl.setAttribute("height", this.height), t.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this }, toString: function () { return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>" }
    }), u(t.StaticCanvas.prototype, t.Observable), u(t.StaticCanvas.prototype, t.Collection), u(t.StaticCanvas.prototype, t.DataURLExporter), u(t.StaticCanvas, { EMPTY_JSON: '{"objects": [], "background": "white"}', supports: function (s) { var f = o(); if (!f || !f.getContext) return null; var d = f.getContext("2d"); if (!d) return null; switch (s) { case "setLineDash": return typeof d.setLineDash < "u"; default: return null } } }), t.StaticCanvas.prototype.toJSON = t.StaticCanvas.prototype.toObject, t.isLikelyNode && (t.StaticCanvas.prototype.createPNGStream = function () { var s = e(this.lowerCanvasEl); return s && s.createPNGStream() }, t.StaticCanvas.prototype.createJPEGStream = function (s) { var f = e(this.lowerCanvasEl); return f && f.createJPEGStream(s) })
}(), t.BaseBrush = t.util.createClass({ color: "rgb(0, 0, 0)", width: 1, shadow: null, strokeLineCap: "round", strokeLineJoin: "round", strokeMiterLimit: 10, strokeDashArray: null, limitedToCanvasSize: !1, _setBrushStyles: function (u) { u.strokeStyle = this.color, u.lineWidth = this.width, u.lineCap = this.strokeLineCap, u.miterLimit = this.strokeMiterLimit, u.lineJoin = this.strokeLineJoin, u.setLineDash(this.strokeDashArray || []) }, _saveAndTransform: function (u) { var n = this.canvas.viewportTransform; u.save(), u.transform(n[0], n[1], n[2], n[3], n[4], n[5]) }, _setShadow: function () { if (this.shadow) { var u = this.canvas, n = this.shadow, l = u.contextTop, h = u.getZoom(); u && u._isRetinaScaling() && (h *= t.devicePixelRatio), l.shadowColor = n.color, l.shadowBlur = n.blur * h, l.shadowOffsetX = n.offsetX * h, l.shadowOffsetY = n.offsetY * h } }, needsFullRender: function () { var u = new t.Color(this.color); return u.getAlpha() < 1 || !!this.shadow }, _resetShadow: function () { var u = this.canvas.contextTop; u.shadowColor = "", u.shadowBlur = u.shadowOffsetX = u.shadowOffsetY = 0 }, _isOutSideCanvas: function (u) { return u.x < 0 || u.x > this.canvas.getWidth() || u.y < 0 || u.y > this.canvas.getHeight() } }), function () { t.PencilBrush = t.util.createClass(t.BaseBrush, { decimate: .4, drawStraightLine: !1, straightLineKey: "shiftKey", initialize: function (u) { this.canvas = u, this._points = [] }, needsFullRender: function () { return this.callSuper("needsFullRender") || this._hasStraightLine }, _drawSegment: function (u, n, l) { var h = n.midPointFrom(l); return u.quadraticCurveTo(n.x, n.y, h.x, h.y), h }, onMouseDown: function (u, n) { this.canvas._isMainEvent(n.e) && (this.drawStraightLine = n.e[this.straightLineKey], this._prepareForDrawing(u), this._captureDrawingPath(u), this._render()) }, onMouseMove: function (u, n) { if (this.canvas._isMainEvent(n.e) && (this.drawStraightLine = n.e[this.straightLineKey], !(this.limitedToCanvasSize === !0 && this._isOutSideCanvas(u)) && this._captureDrawingPath(u) && this._points.length > 1)) if (this.needsFullRender()) this.canvas.clearContext(this.canvas.contextTop), this._render(); else { var l = this._points, h = l.length, i = this.canvas.contextTop; this._saveAndTransform(i), this.oldEnd && (i.beginPath(), i.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = this._drawSegment(i, l[h - 2], l[h - 1], !0), i.stroke(), i.restore() } }, onMouseUp: function (u) { return this.canvas._isMainEvent(u.e) ? (this.drawStraightLine = !1, this.oldEnd = void 0, this._finalizeAndAddPath(), !1) : !0 }, _prepareForDrawing: function (u) { var n = new t.Point(u.x, u.y); this._reset(), this._addPoint(n), this.canvas.contextTop.moveTo(n.x, n.y) }, _addPoint: function (u) { return this._points.length > 1 && u.eq(this._points[this._points.length - 1]) ? !1 : (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = !0, this._points.pop()), this._points.push(u), !0) }, _reset: function () { this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = !1 }, _captureDrawingPath: function (u) { var n = new t.Point(u.x, u.y); return this._addPoint(n) }, _render: function (u) { var n, l, h = this._points[0], i = this._points[1]; if (u = u || this.canvas.contextTop, this._saveAndTransform(u), u.beginPath(), this._points.length === 2 && h.x === i.x && h.y === i.y) { var r = this.width / 1e3; h = new t.Point(h.x, h.y), i = new t.Point(i.x, i.y), h.x -= r, i.x += r } for (u.moveTo(h.x, h.y), n = 1, l = this._points.length; n < l; n++)this._drawSegment(u, h, i), h = this._points[n], i = this._points[n + 1]; u.lineTo(h.x, h.y), u.stroke(), u.restore() }, convertPointsToSVGPath: function (u) { var n = this.width / 1e3; return t.util.getSmoothPathFromPoints(u, n) }, _isEmptySVGPath: function (u) { var n = t.util.joinPath(u); return n === "M 0 0 Q 0 0 0 0 L 0 0" }, createPath: function (u) { var n = new t.Path(u, { fill: null, stroke: this.color, strokeWidth: this.width, strokeLineCap: this.strokeLineCap, strokeMiterLimit: this.strokeMiterLimit, strokeLineJoin: this.strokeLineJoin, strokeDashArray: this.strokeDashArray }); return this.shadow && (this.shadow.affectStroke = !0, n.shadow = new t.Shadow(this.shadow)), n }, decimatePoints: function (u, n) { if (u.length <= 2) return u; var l = this.canvas.getZoom(), h = Math.pow(n / l, 2), i, r = u.length - 1, e = u[0], o = [e], c; for (i = 1; i < r - 1; i++)c = Math.pow(e.x - u[i].x, 2) + Math.pow(e.y - u[i].y, 2), c >= h && (e = u[i], o.push(e)); return o.push(u[r]), o }, _finalizeAndAddPath: function () { var u = this.canvas.contextTop; u.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate)); var n = this.convertPointsToSVGPath(this._points); if (this._isEmptySVGPath(n)) { this.canvas.requestRenderAll(); return } var l = this.createPath(n); this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", { path: l }), this.canvas.add(l), this.canvas.requestRenderAll(), l.setCoords(), this._resetShadow(), this.canvas.fire("path:created", { path: l }) } }) }(), t.CircleBrush = t.util.createClass(t.BaseBrush, { width: 10, initialize: function (u) { this.canvas = u, this.points = [] }, drawDot: function (u) { var n = this.addPoint(u), l = this.canvas.contextTop; this._saveAndTransform(l), this.dot(l, n), l.restore() }, dot: function (u, n) { u.fillStyle = n.fill, u.beginPath(), u.arc(n.x, n.y, n.radius, 0, Math.PI * 2, !1), u.closePath(), u.fill() }, onMouseDown: function (u) { this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(u) }, _render: function () { var u = this.canvas.contextTop, n, l, h = this.points; for (this._saveAndTransform(u), n = 0, l = h.length; n < l; n++)this.dot(u, h[n]); u.restore() }, onMouseMove: function (u) { this.limitedToCanvasSize === !0 && this._isOutSideCanvas(u) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(u), this._render()) : this.drawDot(u)) }, onMouseUp: function () { var u = this.canvas.renderOnAddRemove, n, l; this.canvas.renderOnAddRemove = !1; var h = []; for (n = 0, l = this.points.length; n < l; n++) { var i = this.points[n], r = new t.Circle({ radius: i.radius, left: i.x, top: i.y, originX: "center", originY: "center", fill: i.fill }); this.shadow && (r.shadow = new t.Shadow(this.shadow)), h.push(r) } var e = new t.Group(h); e.canvas = this.canvas, this.canvas.fire("before:path:created", { path: e }), this.canvas.add(e), this.canvas.fire("path:created", { path: e }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = u, this.canvas.requestRenderAll() }, addPoint: function (u) { var n = new t.Point(u.x, u.y), l = t.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, h = new t.Color(this.color).setAlpha(t.util.getRandomInt(0, 100) / 100).toRgba(); return n.radius = l, n.fill = h, this.points.push(n), n } }), t.SprayBrush = t.util.createClass(t.BaseBrush, { width: 10, density: 20, dotWidth: 1, dotWidthVariance: 1, randomOpacity: !1, optimizeOverlapping: !0, initialize: function (u) { this.canvas = u, this.sprayChunks = [] }, onMouseDown: function (u) { this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(u), this.render(this.sprayChunkPoints) }, onMouseMove: function (u) { this.limitedToCanvasSize === !0 && this._isOutSideCanvas(u) || (this.addSprayChunk(u), this.render(this.sprayChunkPoints)) }, onMouseUp: function () { var u = this.canvas.renderOnAddRemove; this.canvas.renderOnAddRemove = !1; for (var n = [], l = 0, h = this.sprayChunks.length; l < h; l++)for (var i = this.sprayChunks[l], r = 0, e = i.length; r < e; r++) { var o = new t.Rect({ width: i[r].width, height: i[r].width, left: i[r].x + 1, top: i[r].y + 1, originX: "center", originY: "center", fill: this.color }); n.push(o) } this.optimizeOverlapping && (n = this._getOptimizedRects(n)); var c = new t.Group(n); this.shadow && c.set("shadow", new t.Shadow(this.shadow)), this.canvas.fire("before:path:created", { path: c }), this.canvas.add(c), this.canvas.fire("path:created", { path: c }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = u, this.canvas.requestRenderAll() }, _getOptimizedRects: function (u) { var n = {}, l, h, i; for (h = 0, i = u.length; h < i; h++)l = u[h].left + "" + u[h].top, n[l] || (n[l] = u[h]); var r = []; for (l in n) r.push(n[l]); return r }, render: function (u) { var n = this.canvas.contextTop, l, h; for (n.fillStyle = this.color, this._saveAndTransform(n), l = 0, h = u.length; l < h; l++) { var i = u[l]; typeof i.opacity < "u" && (n.globalAlpha = i.opacity), n.fillRect(i.x, i.y, i.width, i.width) } n.restore() }, _render: function () { var u = this.canvas.contextTop, n, l; for (u.fillStyle = this.color, this._saveAndTransform(u), n = 0, l = this.sprayChunks.length; n < l; n++)this.render(this.sprayChunks[n]); u.restore() }, addSprayChunk: function (u) { this.sprayChunkPoints = []; var n, l, h, i = this.width / 2, r; for (r = 0; r < this.density; r++) { n = t.util.getRandomInt(u.x - i, u.x + i), l = t.util.getRandomInt(u.y - i, u.y + i), this.dotWidthVariance ? h = t.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : h = this.dotWidth; var e = new t.Point(n, l); e.width = h, this.randomOpacity && (e.opacity = t.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(e) } this.sprayChunks.push(this.sprayChunkPoints) } }), t.PatternBrush = t.util.createClass(t.PencilBrush, { getPatternSrc: function () { var u = 20, n = 5, l = t.util.createCanvasElement(), h = l.getContext("2d"); return l.width = l.height = u + n, h.fillStyle = this.color, h.beginPath(), h.arc(u / 2, u / 2, u / 2, 0, Math.PI * 2, !1), h.closePath(), h.fill(), l }, getPatternSrcFunction: function () { return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"') }, getPattern: function (u) { return u.createPattern(this.source || this.getPatternSrc(), "repeat") }, _setBrushStyles: function (u) { this.callSuper("_setBrushStyles", u), u.strokeStyle = this.getPattern(u) }, createPath: function (u) { var n = this.callSuper("createPath", u), l = n._getLeftTopCoords().scalarAdd(n.strokeWidth / 2); return n.stroke = new t.Pattern({ source: this.source || this.getPatternSrcFunction(), offsetX: -l.x, offsetY: -l.y }), n } }), function () { var u = t.util.getPointer, n = t.util.degreesToRadians, l = t.util.isTouchEvent; t.Canvas = t.util.createClass(t.StaticCanvas, { initialize: function (i, r) { r || (r = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(i, r), this._initInteractive(), this._createCacheCanvas() }, uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", interactive: !0, selection: !0, selectionKey: "shiftKey", altSelectionKey: null, selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", containerClass: "canvas-container", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, isDrawingMode: !1, preserveObjectStacking: !1, snapAngle: 0, snapThreshold: null, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, targets: [], enablePointerEvents: !1, _hoveredTarget: null, _hoveredTargets: [], _initInteractive: function () { this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = t.PencilBrush && new t.PencilBrush(this), this.calcOffset() }, _chooseObjectsToRender: function () { var i = this.getActiveObjects(), r, e, o; if (i.length > 0 && !this.preserveObjectStacking) { e = [], o = []; for (var c = 0, s = this._objects.length; c < s; c++)r = this._objects[c], i.indexOf(r) === -1 ? e.push(r) : o.push(r); i.length > 1 && (this._activeObject._objects = o), e.push.apply(e, o) } else e = this._objects; return e }, renderAll: function () { this.contextTopDirty && !this._groupSelector && !this.isDrawingMode && (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1); var i = this.contextContainer; return this.renderCanvas(i, this._chooseObjectsToRender()), this }, renderTopLayer: function (i) { i.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(i), this.contextTopDirty = !0), i.restore() }, renderTop: function () { var i = this.contextTop; return this.clearContext(i), this.renderTopLayer(i), this.fire("after:render"), this }, _normalizePointer: function (i, r) { var e = i.calcTransformMatrix(), o = t.util.invertTransform(e), c = this.restorePointerVpt(r); return t.util.transformPoint(c, o) }, isTargetTransparent: function (i, r, e) { if (i.shouldCache() && i._cacheCanvas && i !== this._activeObject) { var o = this._normalizePointer(i, { x: r, y: e }), c = Math.max(i.cacheTranslationX + o.x * i.zoomX, 0), s = Math.max(i.cacheTranslationY + o.y * i.zoomY, 0), m = t.util.isTransparent(i._cacheContext, Math.round(c), Math.round(s), this.targetFindTolerance); return m } var f = this.contextCache, d = i.selectionBackgroundColor, p = this.viewportTransform; i.selectionBackgroundColor = "", this.clearContext(f), f.save(), f.transform(p[0], p[1], p[2], p[3], p[4], p[5]), i.render(f), f.restore(), i.selectionBackgroundColor = d; var m = t.util.isTransparent(f, r, e, this.targetFindTolerance); return m }, _isSelectionKeyPressed: function (i) { var r = !1; return Array.isArray(this.selectionKey) ? r = !!this.selectionKey.find(function (e) { return i[e] === !0 }) : r = i[this.selectionKey], r }, _shouldClearSelection: function (i, r) { var e = this.getActiveObjects(), o = this._activeObject; return !r || r && o && e.length > 1 && e.indexOf(r) === -1 && o !== r && !this._isSelectionKeyPressed(i) || r && !r.evented || r && !r.selectable && o && o !== r }, _shouldCenterTransform: function (i, r, e) { if (i) { var o; return r === "scale" || r === "scaleX" || r === "scaleY" || r === "resizing" ? o = this.centeredScaling || i.centeredScaling : r === "rotate" && (o = this.centeredRotation || i.centeredRotation), o ? !e : e } }, _getOriginFromCorner: function (i, r) { var e = { x: i.originX, y: i.originY }; return r === "ml" || r === "tl" || r === "bl" ? e.x = "right" : (r === "mr" || r === "tr" || r === "br") && (e.x = "left"), r === "tl" || r === "mt" || r === "tr" ? e.y = "bottom" : (r === "bl" || r === "mb" || r === "br") && (e.y = "top"), e }, _getActionFromCorner: function (i, r, e, o) { if (!r || !i) return "drag"; var c = o.controls[r]; return c.getActionName(e, c, o) }, _setupCurrentTransform: function (i, r, e) { if (r) { var o = this.getPointer(i), c = r.__corner, s = r.controls[c], f = e && c ? s.getActionHandler(i, r, s) : t.controlsUtils.dragHandler, d = this._getActionFromCorner(e, c, i, r), p = this._getOriginFromCorner(r, c), m = i[this.centeredKey], y = { target: r, action: d, actionHandler: f, corner: c, scaleX: r.scaleX, scaleY: r.scaleY, skewX: r.skewX, skewY: r.skewY, offsetX: o.x - r.left, offsetY: o.y - r.top, originX: p.x, originY: p.y, ex: o.x, ey: o.y, lastX: o.x, lastY: o.y, theta: n(r.angle), width: r.width * r.scaleX, shiftKey: i.shiftKey, altKey: m, original: t.util.saveObjectTransform(r) }; this._shouldCenterTransform(r, d, m) && (y.originX = "center", y.originY = "center"), y.original.originX = p.x, y.original.originY = p.y, this._currentTransform = y, this._beforeTransform(i) } }, setCursor: function (i) { this.upperCanvasEl.style.cursor = i }, _drawSelection: function (i) { var r = this._groupSelector, e = new t.Point(r.ex, r.ey), o = t.util.transformPoint(e, this.viewportTransform), c = new t.Point(r.ex + r.left, r.ey + r.top), s = t.util.transformPoint(c, this.viewportTransform), f = Math.min(o.x, s.x), d = Math.min(o.y, s.y), p = Math.max(o.x, s.x), m = Math.max(o.y, s.y), y = this.selectionLineWidth / 2; this.selectionColor && (i.fillStyle = this.selectionColor, i.fillRect(f, d, p - f, m - d)), !(!this.selectionLineWidth || !this.selectionBorderColor) && (i.lineWidth = this.selectionLineWidth, i.strokeStyle = this.selectionBorderColor, f += y, d += y, p -= y, m -= y, t.Object.prototype._setLineDash.call(this, i, this.selectionDashArray), i.strokeRect(f, d, p - f, m - d)) }, findTarget: function (i, r) { if (!this.skipTargetFind) { var e = !0, o = this.getPointer(i, e), c = this._activeObject, s = this.getActiveObjects(), f, d, p = l(i), m = s.length > 1 && !r || s.length === 1; if (this.targets = [], m && c._findTargetCorner(o, p) || s.length > 1 && !r && c === this._searchPossibleTargets([c], o)) return c; if (s.length === 1 && c === this._searchPossibleTargets([c], o)) if (this.preserveObjectStacking) f = c, d = this.targets, this.targets = []; else return c; var y = this._searchPossibleTargets(this._objects, o); return i[this.altSelectionKey] && y && f && y !== f && (y = f, this.targets = d), y } }, _checkTarget: function (i, r, e) { if (r && r.visible && r.evented && r.containsPoint(i)) if ((this.perPixelTargetFind || r.perPixelTargetFind) && !r.isEditing) { var o = this.isTargetTransparent(r, e.x, e.y); if (!o) return !0 } else return !0 }, _searchPossibleTargets: function (i, r) { for (var e, o = i.length, c; o--;) { var s = i[o], f = s.group ? this._normalizePointer(s.group, r) : r; if (this._checkTarget(f, s, r)) { e = i[o], e.subTargetCheck && e instanceof t.Group && (c = this._searchPossibleTargets(e._objects, r), c && this.targets.push(c)); break } } return e }, restorePointerVpt: function (i) { return t.util.transformPoint(i, t.util.invertTransform(this.viewportTransform)) }, getPointer: function (i, r) { if (this._absolutePointer && !r) return this._absolutePointer; if (this._pointer && r) return this._pointer; var e = u(i), o = this.upperCanvasEl, c = o.getBoundingClientRect(), s = c.width || 0, f = c.height || 0, d; (!s || !f) && ("top" in c && "bottom" in c && (f = Math.abs(c.top - c.bottom)), "right" in c && "left" in c && (s = Math.abs(c.right - c.left))), this.calcOffset(), e.x = e.x - this._offset.left, e.y = e.y - this._offset.top, r || (e = this.restorePointerVpt(e)); var p = this.getRetinaScaling(); return p !== 1 && (e.x /= p, e.y /= p), s === 0 || f === 0 ? d = { width: 1, height: 1 } : d = { width: o.width / s, height: o.height / f }, { x: e.x * d.width, y: e.y * d.height } }, _createUpperCanvas: function () { var i = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""), r = this.lowerCanvasEl, e = this.upperCanvasEl; e ? e.className = "" : (e = this._createCanvasElement(), this.upperCanvasEl = e), t.util.addClass(e, "upper-canvas " + i), this.wrapperEl.appendChild(e), this._copyCanvasStyle(r, e), this._applyCanvasStyle(e), this.contextTop = e.getContext("2d") }, getTopContext: function () { return this.contextTop }, _createCacheCanvas: function () { this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d") }, _initWrapperElement: function () { this.wrapperEl = t.util.wrapElement(this.lowerCanvasEl, "div", { class: this.containerClass }), t.util.setStyle(this.wrapperEl, { width: this.width + "px", height: this.height + "px", position: "relative" }), t.util.makeElementUnselectable(this.wrapperEl) }, _applyCanvasStyle: function (i) { var r = this.width || i.width, e = this.height || i.height; t.util.setStyle(i, { position: "absolute", width: r + "px", height: e + "px", left: 0, top: 0, "touch-action": this.allowTouchScrolling ? "manipulation" : "none", "-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none" }), i.width = r, i.height = e, t.util.makeElementUnselectable(i) }, _copyCanvasStyle: function (i, r) { r.style.cssText = i.style.cssText }, getSelectionContext: function () { return this.contextTop }, getSelectionElement: function () { return this.upperCanvasEl }, getActiveObject: function () { return this._activeObject }, getActiveObjects: function () { var i = this._activeObject; return i ? i.type === "activeSelection" && i._objects ? i._objects.slice(0) : [i] : [] }, _onObjectRemoved: function (i) { i === this._activeObject && (this.fire("before:selection:cleared", { target: i }), this._discardActiveObject(), this.fire("selection:cleared", { target: i }), i.fire("deselected")), i === this._hoveredTarget && (this._hoveredTarget = null, this._hoveredTargets = []), this.callSuper("_onObjectRemoved", i) }, _fireSelectionEvents: function (i, r) { var e = !1, o = this.getActiveObjects(), c = [], s = []; i.forEach(function (f) { o.indexOf(f) === -1 && (e = !0, f.fire("deselected", { e: r, target: f }), s.push(f)) }), o.forEach(function (f) { i.indexOf(f) === -1 && (e = !0, f.fire("selected", { e: r, target: f }), c.push(f)) }), i.length > 0 && o.length > 0 ? e && this.fire("selection:updated", { e: r, selected: c, deselected: s }) : o.length > 0 ? this.fire("selection:created", { e: r, selected: c }) : i.length > 0 && this.fire("selection:cleared", { e: r, deselected: s }) }, setActiveObject: function (i, r) { var e = this.getActiveObjects(); return this._setActiveObject(i, r), this._fireSelectionEvents(e, r), this }, _setActiveObject: function (i, r) { return this._activeObject === i || !this._discardActiveObject(r, i) || i.onSelect({ e: r }) ? !1 : (this._activeObject = i, !0) }, _discardActiveObject: function (i, r) { var e = this._activeObject; if (e) { if (e.onDeselect({ e: i, object: r })) return !1; this._activeObject = null } return !0 }, discardActiveObject: function (i) { var r = this.getActiveObjects(), e = this.getActiveObject(); return r.length && this.fire("before:selection:cleared", { target: e, e: i }), this._discardActiveObject(i), this._fireSelectionEvents(r, i), this }, dispose: function () { var i = this.wrapperEl; return this.removeListeners(), i.removeChild(this.upperCanvasEl), i.removeChild(this.lowerCanvasEl), this.contextCache = null, this.contextTop = null, ["upperCanvasEl", "cacheCanvasEl"].forEach(function (r) { t.util.cleanUpJsdomNode(this[r]), this[r] = void 0 }.bind(this)), i.parentNode && i.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, t.StaticCanvas.prototype.dispose.call(this), this }, clear: function () { return this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear") }, drawControls: function (i) { var r = this._activeObject; r && r._renderControls(i) }, _toObject: function (i, r, e) { var o = this._realizeGroupTransformOnObject(i), c = this.callSuper("_toObject", i, r, e); return this._unwindGroupTransformOnObject(i, o), c }, _realizeGroupTransformOnObject: function (i) { if (i.group && i.group.type === "activeSelection" && this._activeObject === i.group) { var r = ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"], e = {}; return r.forEach(function (o) { e[o] = i[o] }), t.util.addTransformToObject(i, this._activeObject.calcOwnMatrix()), e } else return null }, _unwindGroupTransformOnObject: function (i, r) { r && i.set(r) }, _setSVGObject: function (i, r, e) { var o = this._realizeGroupTransformOnObject(r); this.callSuper("_setSVGObject", i, r, e), this._unwindGroupTransformOnObject(r, o) }, setViewportTransform: function (i) { this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing && this._activeObject.clearContextTop(), t.StaticCanvas.prototype.setViewportTransform.call(this, i) } }); for (var h in t.StaticCanvas) h !== "prototype" && (t.Canvas[h] = t.StaticCanvas[h]) }(), function () { var u = t.util.addListener, n = t.util.removeListener, l = 3, h = 2, i = 1, r = { passive: !1 }; function e(o, c) { return o.button && o.button === c - 1 } t.util.object.extend(t.Canvas.prototype, { mainTouchId: null, _initEventListeners: function () { this.removeListeners(), this._bindEvents(), this.addOrRemove(u, "add") }, _getEventPrefix: function () { return this.enablePointerEvents ? "pointer" : "mouse" }, addOrRemove: function (o, c) { var s = this.upperCanvasEl, f = this._getEventPrefix(); o(t.window, "resize", this._onResize), o(s, f + "down", this._onMouseDown), o(s, f + "move", this._onMouseMove, r), o(s, f + "out", this._onMouseOut), o(s, f + "enter", this._onMouseEnter), o(s, "wheel", this._onMouseWheel), o(s, "contextmenu", this._onContextMenu), o(s, "dblclick", this._onDoubleClick), o(s, "dragover", this._onDragOver), o(s, "dragenter", this._onDragEnter), o(s, "dragleave", this._onDragLeave), o(s, "drop", this._onDrop), this.enablePointerEvents || o(s, "touchstart", this._onTouchStart, r), typeof eventjs < "u" && c in eventjs && (eventjs[c](s, "gesture", this._onGesture), eventjs[c](s, "drag", this._onDrag), eventjs[c](s, "orientation", this._onOrientationChange), eventjs[c](s, "shake", this._onShake), eventjs[c](s, "longpress", this._onLongPress)) }, removeListeners: function () { this.addOrRemove(n, "remove"); var o = this._getEventPrefix(); n(t.document, o + "up", this._onMouseUp), n(t.document, "touchend", this._onTouchEnd, r), n(t.document, o + "move", this._onMouseMove, r), n(t.document, "touchmove", this._onMouseMove, r) }, _bindEvents: function () { this.eventsBound || (this._onMouseDown = this._onMouseDown.bind(this), this._onTouchStart = this._onTouchStart.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this._onDoubleClick = this._onDoubleClick.bind(this), this._onDragOver = this._onDragOver.bind(this), this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter"), this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave"), this._onDrop = this._onDrop.bind(this), this.eventsBound = !0) }, _onGesture: function (o, c) { this.__onTransformGesture && this.__onTransformGesture(o, c) }, _onDrag: function (o, c) { this.__onDrag && this.__onDrag(o, c) }, _onMouseWheel: function (o) { this.__onMouseWheel(o) }, _onMouseOut: function (o) { var c = this._hoveredTarget; this.fire("mouse:out", { target: c, e: o }), this._hoveredTarget = null, c && c.fire("mouseout", { e: o }); var s = this; this._hoveredTargets.forEach(function (f) { s.fire("mouse:out", { target: c, e: o }), f && c.fire("mouseout", { e: o }) }), this._hoveredTargets = [] }, _onMouseEnter: function (o) { !this._currentTransform && !this.findTarget(o) && (this.fire("mouse:over", { target: null, e: o }), this._hoveredTarget = null, this._hoveredTargets = []) }, _onOrientationChange: function (o, c) { this.__onOrientationChange && this.__onOrientationChange(o, c) }, _onShake: function (o, c) { this.__onShake && this.__onShake(o, c) }, _onLongPress: function (o, c) { this.__onLongPress && this.__onLongPress(o, c) }, _onDragOver: function (o) { o.preventDefault(); var c = this._simpleEventHandler("dragover", o); this._fireEnterLeaveEvents(c, o) }, _onDrop: function (o) { return this._simpleEventHandler("drop:before", o), this._simpleEventHandler("drop", o) }, _onContextMenu: function (o) { return this.stopContextMenu && (o.stopPropagation(), o.preventDefault()), !1 }, _onDoubleClick: function (o) { this._cacheTransformEventData(o), this._handleEvent(o, "dblclick"), this._resetTransformEventData(o) }, getPointerId: function (o) { var c = o.changedTouches; return c ? c[0] && c[0].identifier : this.enablePointerEvents ? o.pointerId : -1 }, _isMainEvent: function (o) { return o.isPrimary === !0 ? !0 : o.isPrimary === !1 ? !1 : o.type === "touchend" && o.touches.length === 0 ? !0 : o.changedTouches ? o.changedTouches[0].identifier === this.mainTouchId : !0 }, _onTouchStart: function (o) { o.preventDefault(), this.mainTouchId === null && (this.mainTouchId = this.getPointerId(o)), this.__onMouseDown(o), this._resetTransformEventData(); var c = this.upperCanvasEl, s = this._getEventPrefix(); u(t.document, "touchend", this._onTouchEnd, r), u(t.document, "touchmove", this._onMouseMove, r), n(c, s + "down", this._onMouseDown) }, _onMouseDown: function (o) { this.__onMouseDown(o), this._resetTransformEventData(); var c = this.upperCanvasEl, s = this._getEventPrefix(); n(c, s + "move", this._onMouseMove, r), u(t.document, s + "up", this._onMouseUp), u(t.document, s + "move", this._onMouseMove, r) }, _onTouchEnd: function (o) { if (!(o.touches.length > 0)) { this.__onMouseUp(o), this._resetTransformEventData(), this.mainTouchId = null; var c = this._getEventPrefix(); n(t.document, "touchend", this._onTouchEnd, r), n(t.document, "touchmove", this._onMouseMove, r); var s = this; this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(function () { u(s.upperCanvasEl, c + "down", s._onMouseDown), s._willAddMouseDown = 0 }, 400) } }, _onMouseUp: function (o) { this.__onMouseUp(o), this._resetTransformEventData(); var c = this.upperCanvasEl, s = this._getEventPrefix(); this._isMainEvent(o) && (n(t.document, s + "up", this._onMouseUp), n(t.document, s + "move", this._onMouseMove, r), u(c, s + "move", this._onMouseMove, r)) }, _onMouseMove: function (o) { !this.allowTouchScrolling && o.preventDefault && o.preventDefault(), this.__onMouseMove(o) }, _onResize: function () { this.calcOffset() }, _shouldRender: function (o) { var c = this._activeObject; return !!c != !!o || c && o && c !== o ? !0 : (c && c.isEditing, !1) }, __onMouseUp: function (o) { var c, s = this._currentTransform, f = this._groupSelector, d = !1, p = !f || f.left === 0 && f.top === 0; if (this._cacheTransformEventData(o), c = this._target, this._handleEvent(o, "up:before"), e(o, l)) { this.fireRightClick && this._handleEvent(o, "up", l, p); return } if (e(o, h)) { this.fireMiddleClick && this._handleEvent(o, "up", h, p), this._resetTransformEventData(); return } if (this.isDrawingMode && this._isCurrentlyDrawing) { this._onMouseUpInDrawingMode(o); return } if (this._isMainEvent(o)) { if (s && (this._finalizeCurrentTransform(o), d = s.actionPerformed), !p) { var m = c === this._activeObject; this._maybeGroupObjects(o), d || (d = this._shouldRender(c) || !m && c === this._activeObject) } var y, x; if (c) { if (y = c._findTargetCorner(this.getPointer(o, !0), t.util.isTouchEvent(o)), c.selectable && c !== this._activeObject && c.activeOn === "up") this.setActiveObject(c, o), d = !0; else { var P = c.controls[y], D = P && P.getMouseUpHandler(o, c, P); D && (x = this.getPointer(o), D(o, s, x.x, x.y)) } c.isMoving = !1 } if (s && (s.target !== c || s.corner !== y)) { var Y = s.target && s.target.controls[s.corner], V = Y && Y.getMouseUpHandler(o, c, P); x = x || this.getPointer(o), V && V(o, s, x.x, x.y) } this._setCursorFromEvent(o, c), this._handleEvent(o, "up", i, p), this._groupSelector = null, this._currentTransform = null, c && (c.__corner = 0), d ? this.requestRenderAll() : p || this.renderTop() } }, _simpleEventHandler: function (o, c) { var s = this.findTarget(c), f = this.targets, d = { e: c, target: s, subTargets: f }; if (this.fire(o, d), s && s.fire(o, d), !f) return s; for (var p = 0; p < f.length; p++)f[p].fire(o, d); return s }, _handleEvent: function (o, c, s, f) { var d = this._target, p = this.targets || [], m = { e: o, target: d, subTargets: p, button: s || i, isClick: f || !1, pointer: this._pointer, absolutePointer: this._absolutePointer, transform: this._currentTransform }; c === "up" && (m.currentTarget = this.findTarget(o), m.currentSubTargets = this.targets), this.fire("mouse:" + c, m), d && d.fire("mouse" + c, m); for (var y = 0; y < p.length; y++)p[y].fire("mouse" + c, m) }, _finalizeCurrentTransform: function (o) { var c = this._currentTransform, s = c.target, f = { e: o, target: s, transform: c, action: c.action }; s._scaling && (s._scaling = !1), s.setCoords(), (c.actionPerformed || this.stateful && s.hasStateChanged()) && this._fire("modified", f) }, _onMouseDownInDrawingMode: function (o) { this._isCurrentlyDrawing = !0, this.getActiveObject() && this.discardActiveObject(o).requestRenderAll(); var c = this.getPointer(o); this.freeDrawingBrush.onMouseDown(c, { e: o, pointer: c }), this._handleEvent(o, "down") }, _onMouseMoveInDrawingMode: function (o) { if (this._isCurrentlyDrawing) { var c = this.getPointer(o); this.freeDrawingBrush.onMouseMove(c, { e: o, pointer: c }) } this.setCursor(this.freeDrawingCursor), this._handleEvent(o, "move") }, _onMouseUpInDrawingMode: function (o) { var c = this.getPointer(o); this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: o, pointer: c }), this._handleEvent(o, "up") }, __onMouseDown: function (o) { this._cacheTransformEventData(o), this._handleEvent(o, "down:before"); var c = this._target; if (e(o, l)) { this.fireRightClick && this._handleEvent(o, "down", l); return } if (e(o, h)) { this.fireMiddleClick && this._handleEvent(o, "down", h); return } if (this.isDrawingMode) { this._onMouseDownInDrawingMode(o); return } if (this._isMainEvent(o) && !this._currentTransform) { var s = this._pointer; this._previousPointer = s; var f = this._shouldRender(c), d = this._shouldGroup(o, c); if (this._shouldClearSelection(o, c) ? this.discardActiveObject(o) : d && (this._handleGrouping(o, c), c = this._activeObject), this.selection && (!c || !c.selectable && !c.isEditing && c !== this._activeObject) && (this._groupSelector = { ex: this._absolutePointer.x, ey: this._absolutePointer.y, top: 0, left: 0 }), c) { var p = c === this._activeObject; c.selectable && c.activeOn === "down" && this.setActiveObject(c, o); var m = c._findTargetCorner(this.getPointer(o, !0), t.util.isTouchEvent(o)); if (c.__corner = m, c === this._activeObject && (m || !d)) { this._setupCurrentTransform(o, c, p); var y = c.controls[m], s = this.getPointer(o), x = y && y.getMouseDownHandler(o, c, y); x && x(o, this._currentTransform, s.x, s.y) } } this._handleEvent(o, "down"), (f || d) && this.requestRenderAll() } }, _resetTransformEventData: function () { this._target = null, this._pointer = null, this._absolutePointer = null }, _cacheTransformEventData: function (o) { this._resetTransformEventData(), this._pointer = this.getPointer(o, !0), this._absolutePointer = this.restorePointerVpt(this._pointer), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(o) || null }, _beforeTransform: function (o) { var c = this._currentTransform; this.stateful && c.target.saveState(), this.fire("before:transform", { e: o, transform: c }) }, __onMouseMove: function (o) { this._handleEvent(o, "move:before"), this._cacheTransformEventData(o); var c, s; if (this.isDrawingMode) { this._onMouseMoveInDrawingMode(o); return } if (this._isMainEvent(o)) { var f = this._groupSelector; f ? (s = this._absolutePointer, f.left = s.x - f.ex, f.top = s.y - f.ey, this.renderTop()) : this._currentTransform ? this._transformObject(o) : (c = this.findTarget(o) || null, this._setCursorFromEvent(o, c), this._fireOverOutEvents(c, o)), this._handleEvent(o, "move"), this._resetTransformEventData() } }, _fireOverOutEvents: function (o, c) { var s = this._hoveredTarget, f = this._hoveredTargets, d = this.targets, p = Math.max(f.length, d.length); this.fireSyntheticInOutEvents(o, c, { oldTarget: s, evtOut: "mouseout", canvasEvtOut: "mouse:out", evtIn: "mouseover", canvasEvtIn: "mouse:over" }); for (var m = 0; m < p; m++)this.fireSyntheticInOutEvents(d[m], c, { oldTarget: f[m], evtOut: "mouseout", evtIn: "mouseover" }); this._hoveredTarget = o, this._hoveredTargets = this.targets.concat() }, _fireEnterLeaveEvents: function (o, c) { var s = this._draggedoverTarget, f = this._hoveredTargets, d = this.targets, p = Math.max(f.length, d.length); this.fireSyntheticInOutEvents(o, c, { oldTarget: s, evtOut: "dragleave", evtIn: "dragenter" }); for (var m = 0; m < p; m++)this.fireSyntheticInOutEvents(d[m], c, { oldTarget: f[m], evtOut: "dragleave", evtIn: "dragenter" }); this._draggedoverTarget = o }, fireSyntheticInOutEvents: function (o, c, s) { var f, d, p = s.oldTarget, m, y, x = p !== o, P = s.canvasEvtIn, D = s.canvasEvtOut; x && (f = { e: c, target: o, previousTarget: p }, d = { e: c, target: p, nextTarget: o }), y = o && x, m = p && x, m && (D && this.fire(D, d), p.fire(s.evtOut, d)), y && (P && this.fire(P, f), o.fire(s.evtIn, f)) }, __onMouseWheel: function (o) { this._cacheTransformEventData(o), this._handleEvent(o, "wheel"), this._resetTransformEventData() }, _transformObject: function (o) { var c = this.getPointer(o), s = this._currentTransform; s.reset = !1, s.shiftKey = o.shiftKey, s.altKey = o[this.centeredKey], this._performTransformAction(o, s, c), s.actionPerformed && this.requestRenderAll() }, _performTransformAction: function (o, c, s) { var f = s.x, d = s.y, p = c.action, m = !1, y = c.actionHandler; y && (m = y(o, c, f, d)), p === "drag" && m && (c.target.isMoving = !0, this.setCursor(c.target.moveCursor || this.moveCursor)), c.actionPerformed = c.actionPerformed || m }, _fire: t.controlsUtils.fireEvent, _setCursorFromEvent: function (o, c) { if (!c) return this.setCursor(this.defaultCursor), !1; var s = c.hoverCursor || this.hoverCursor, f = this._activeObject && this._activeObject.type === "activeSelection" ? this._activeObject : null, d = (!f || !f.contains(c)) && c._findTargetCorner(this.getPointer(o, !0)); d ? this.setCursor(this.getCornerCursor(d, c, o)) : (c.subTargetCheck && this.targets.concat().reverse().map(function (p) { s = p.hoverCursor || s }), this.setCursor(s)) }, getCornerCursor: function (o, c, s) { var f = c.controls[o]; return f.cursorStyleHandler(s, f, c) } }) }(), function () { var u = Math.min, n = Math.max; t.util.object.extend(t.Canvas.prototype, { _shouldGroup: function (l, h) { var i = this._activeObject; return i && this._isSelectionKeyPressed(l) && h && h.selectable && this.selection && (i !== h || i.type === "activeSelection") && !h.onSelect({ e: l }) }, _handleGrouping: function (l, h) { var i = this._activeObject; i.__corner || h === i && (h = this.findTarget(l, !0), !h || !h.selectable) || (i && i.type === "activeSelection" ? this._updateActiveSelection(h, l) : this._createActiveSelection(h, l)) }, _updateActiveSelection: function (l, h) { var i = this._activeObject, r = i._objects.slice(0); i.contains(l) ? (i.removeWithUpdate(l), this._hoveredTarget = l, this._hoveredTargets = this.targets.concat(), i.size() === 1 && this._setActiveObject(i.item(0), h)) : (i.addWithUpdate(l), this._hoveredTarget = i, this._hoveredTargets = this.targets.concat()), this._fireSelectionEvents(r, h) }, _createActiveSelection: function (l, h) { var i = this.getActiveObjects(), r = this._createGroup(l); this._hoveredTarget = r, this._setActiveObject(r, h), this._fireSelectionEvents(i, h) }, _createGroup: function (l) { var h = this._objects, i = h.indexOf(this._activeObject) < h.indexOf(l), r = i ? [this._activeObject, l] : [l, this._activeObject]; return this._activeObject.isEditing && this._activeObject.exitEditing(), new t.ActiveSelection(r, { canvas: this }) }, _groupSelectedObjects: function (l) { var h = this._collectObjects(l), i; h.length === 1 ? this.setActiveObject(h[0], l) : h.length > 1 && (i = new t.ActiveSelection(h.reverse(), { canvas: this }), this.setActiveObject(i, l)) }, _collectObjects: function (l) { for (var h = [], i, r = this._groupSelector.ex, e = this._groupSelector.ey, o = r + this._groupSelector.left, c = e + this._groupSelector.top, s = new t.Point(u(r, o), u(e, c)), f = new t.Point(n(r, o), n(e, c)), d = !this.selectionFullyContained, p = r === o && e === c, m = this._objects.length; m-- && (i = this._objects[m], !(!(!i || !i.selectable || !i.visible) && (d && i.intersectsWithRect(s, f, !0) || i.isContainedWithinRect(s, f, !0) || d && i.containsPoint(s, null, !0) || d && i.containsPoint(f, null, !0)) && (h.push(i), p)));); return h.length > 1 && (h = h.filter(function (y) { return !y.onSelect({ e: l }) })), h }, _maybeGroupObjects: function (l) { this.selection && this._groupSelector && this._groupSelectedObjects(l), this.setCursor(this.defaultCursor), this._groupSelector = null } }) }(), function () { t.util.object.extend(t.StaticCanvas.prototype, { toDataURL: function (u) { u || (u = {}); var n = u.format || "png", l = u.quality || 1, h = (u.multiplier || 1) * (u.enableRetinaScaling ? this.getRetinaScaling() : 1), i = this.toCanvasElement(h, u); return t.util.toDataURL(i, n, l) }, toCanvasElement: function (u, n) { u = u || 1, n = n || {}; var l = (n.width || this.width) * u, h = (n.height || this.height) * u, i = this.getZoom(), r = this.width, e = this.height, o = i * u, c = this.viewportTransform, s = (c[4] - (n.left || 0)) * u, f = (c[5] - (n.top || 0)) * u, d = this.interactive, p = [o, 0, 0, o, s, f], m = this.enableRetinaScaling, y = t.util.createCanvasElement(), x = this.contextTop; return y.width = l, y.height = h, this.contextTop = null, this.enableRetinaScaling = !1, this.interactive = !1, this.viewportTransform = p, this.width = l, this.height = h, this.calcViewportBoundaries(), this.renderCanvas(y.getContext("2d"), this._objects), this.viewportTransform = c, this.width = r, this.height = e, this.calcViewportBoundaries(), this.interactive = d, this.enableRetinaScaling = m, this.contextTop = x, y } }) }(), t.util.object.extend(t.StaticCanvas.prototype, { loadFromJSON: function (u, n, l) { if (u) { var h = typeof u == "string" ? JSON.parse(u) : t.util.object.clone(u), i = this, r = h.clipPath, e = this.renderOnAddRemove; return this.renderOnAddRemove = !1, delete h.clipPath, this._enlivenObjects(h.objects, function (o) { i.clear(), i._setBgOverlay(h, function () { r ? i._enlivenObjects([r], function (c) { i.clipPath = c[0], i.__setupCanvas.call(i, h, o, e, n) }) : i.__setupCanvas.call(i, h, o, e, n) }) }, l), this } }, __setupCanvas: function (u, n, l, h) { var i = this; n.forEach(function (r, e) { i.insertAt(r, e) }), this.renderOnAddRemove = l, delete u.objects, delete u.backgroundImage, delete u.overlayImage, delete u.background, delete u.overlay, this._setOptions(u), this.renderAll(), h && h() }, _setBgOverlay: function (u, n) { var l = { backgroundColor: !1, overlayColor: !1, backgroundImage: !1, overlayImage: !1 }; if (!u.backgroundImage && !u.overlayImage && !u.background && !u.overlay) { n && n(); return } var h = function () { l.backgroundImage && l.overlayImage && l.backgroundColor && l.overlayColor && n && n() }; this.__setBgOverlay("backgroundImage", u.backgroundImage, l, h), this.__setBgOverlay("overlayImage", u.overlayImage, l, h), this.__setBgOverlay("backgroundColor", u.background, l, h), this.__setBgOverlay("overlayColor", u.overlay, l, h) }, __setBgOverlay: function (u, n, l, h) { var i = this; if (!n) { l[u] = !0, h && h(); return } u === "backgroundImage" || u === "overlayImage" ? t.util.enlivenObjects([n], function (r) { i[u] = r[0], l[u] = !0, h && h() }) : this["set" + t.util.string.capitalize(u, !0)](n, function () { l[u] = !0, h && h() }) }, _enlivenObjects: function (u, n, l) { if (!u || u.length === 0) { n && n([]); return } t.util.enlivenObjects(u, function (h) { n && n(h) }, null, l) }, _toDataURL: function (u, n) { this.clone(function (l) { n(l.toDataURL(u)) }) }, _toDataURLWithMultiplier: function (u, n, l) { this.clone(function (h) { l(h.toDataURLWithMultiplier(u, n)) }) }, clone: function (u, n) { var l = JSON.stringify(this.toJSON(n)); this.cloneWithoutData(function (h) { h.loadFromJSON(l, function () { u && u(h) }) }) }, cloneWithoutData: function (u) { var n = t.util.createCanvasElement(); n.width = this.width, n.height = this.height; var l = new t.Canvas(n); this.backgroundImage ? (l.setBackgroundImage(this.backgroundImage.src, function () { l.renderAll(), u && u(l) }), l.backgroundImageOpacity = this.backgroundImageOpacity, l.backgroundImageStretch = this.backgroundImageStretch) : u && u(l) } }), function (u) { var n = u.fabric || (u.fabric = {}), l = n.util.object.extend, h = n.util.object.clone, i = n.util.toFixed, r = n.util.string.capitalize, e = n.util.degreesToRadians, o = !n.isLikelyNode, c = 2; n.Object || (n.Object = n.util.createClass(n.CommonMethods, { type: "object", originX: "left", originY: "top", top: 0, left: 0, width: 0, height: 0, scaleX: 1, scaleY: 1, flipX: !1, flipY: !1, opacity: 1, angle: 0, skewX: 0, skewY: 0, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, hoverCursor: null, moveCursor: null, padding: 0, borderColor: "rgb(178,204,255)", borderDashArray: null, cornerColor: "rgb(178,204,255)", cornerStrokeColor: null, cornerStyle: "rect", cornerDashArray: null, centeredScaling: !1, centeredRotation: !0, fill: "rgb(0,0,0)", fillRule: "nonzero", globalCompositeOperation: "source-over", backgroundColor: "", selectionBackgroundColor: "", stroke: null, strokeWidth: 1, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, shadow: null, borderOpacityWhenMoving: .4, borderScaleFactor: 1, minScaleLimit: 0, selectable: !0, evented: !0, visible: !0, hasControls: !0, hasBorders: !0, perPixelTargetFind: !1, includeDefaultValues: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, excludeFromExport: !1, objectCaching: o, statefullCache: !1, noScaleCache: !0, strokeUniform: !1, dirty: !0, __corner: 0, paintFirst: "fill", activeOn: "down", stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "), cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "), colorProperties: "fill stroke backgroundColor".split(" "), clipPath: void 0, inverted: !1, absolutePositioned: !1, initialize: function (s) { s && this.setOptions(s) }, _createCacheCanvas: function () { this._cacheProperties = {}, this._cacheCanvas = n.util.createCanvasElement(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0 }, _limitCacheSize: function (s) { var f = n.perfLimitSizeTotal, d = s.width, p = s.height, m = n.maxCacheSideLimit, y = n.minCacheSideLimit; if (d <= m && p <= m && d * p <= f) return d < y && (s.width = y), p < y && (s.height = y), s; var x = d / p, P = n.util.limitDimsByArea(x, f), D = n.util.capValue, Y = D(y, P.x, m), V = D(y, P.y, m); return d > Y && (s.zoomX /= d / Y, s.width = Y, s.capped = !0), p > V && (s.zoomY /= p / V, s.height = V, s.capped = !0), s }, _getCacheCanvasDimensions: function () { var s = this.getTotalObjectScaling(), f = this._getTransformedDimensions(0, 0), d = f.x * s.scaleX / this.scaleX, p = f.y * s.scaleY / this.scaleY; return { width: d + c, height: p + c, zoomX: s.scaleX, zoomY: s.scaleY, x: d, y: p } }, _updateCacheCanvas: function () { var s = this.canvas; if (this.noScaleCache && s && s._currentTransform) { var f = s._currentTransform.target, d = s._currentTransform.action; if (this === f && d.slice && d.slice(0, 5) === "scale") return !1 } var p = this._cacheCanvas, m = this._limitCacheSize(this._getCacheCanvasDimensions()), y = n.minCacheSideLimit, x = m.width, P = m.height, D, Y, V = m.zoomX, J = m.zoomY, Q = x !== this.cacheWidth || P !== this.cacheHeight, rt = this.zoomX !== V || this.zoomY !== J, tt = Q || rt, it = 0, ot = 0, st = !1; if (Q) { var nt = this._cacheCanvas.width, w = this._cacheCanvas.height, F = x > nt || P > w, k = (x < nt * .9 || P < w * .9) && nt > y && w > y; st = F || k, F && !m.capped && (x > y || P > y) && (it = x * .1, ot = P * .1) } return this instanceof n.Text && this.path && (tt = !0, st = !0, it += this.getHeightOfLine(0) * this.zoomX, ot += this.getHeightOfLine(0) * this.zoomY), tt ? (st ? (p.width = Math.ceil(x + it), p.height = Math.ceil(P + ot)) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, p.width, p.height)), D = m.x / 2, Y = m.y / 2, this.cacheTranslationX = Math.round(p.width / 2 - D) + D, this.cacheTranslationY = Math.round(p.height / 2 - Y) + Y, this.cacheWidth = x, this.cacheHeight = P, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(V, J), this.zoomX = V, this.zoomY = J, !0) : !1 }, setOptions: function (s) { this._setOptions(s), this._initGradient(s.fill, "fill"), this._initGradient(s.stroke, "stroke"), this._initPattern(s.fill, "fill"), this._initPattern(s.stroke, "stroke") }, transform: function (s) { var f = this.group && !this.group._transformDone || this.group && this.canvas && s === this.canvas.contextTop, d = this.calcTransformMatrix(!f); s.transform(d[0], d[1], d[2], d[3], d[4], d[5]) }, toObject: function (s) { var f = n.Object.NUM_FRACTION_DIGITS, d = { type: this.type, version: n.version, originX: this.originX, originY: this.originY, left: i(this.left, f), top: i(this.top, f), width: i(this.width, f), height: i(this.height, f), fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill, stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke, strokeWidth: i(this.strokeWidth, f), strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray, strokeLineCap: this.strokeLineCap, strokeDashOffset: this.strokeDashOffset, strokeLineJoin: this.strokeLineJoin, strokeUniform: this.strokeUniform, strokeMiterLimit: i(this.strokeMiterLimit, f), scaleX: i(this.scaleX, f), scaleY: i(this.scaleY, f), angle: i(this.angle, f), flipX: this.flipX, flipY: this.flipY, opacity: i(this.opacity, f), shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow, visible: this.visible, backgroundColor: this.backgroundColor, fillRule: this.fillRule, paintFirst: this.paintFirst, globalCompositeOperation: this.globalCompositeOperation, skewX: i(this.skewX, f), skewY: i(this.skewY, f) }; return this.clipPath && !this.clipPath.excludeFromExport && (d.clipPath = this.clipPath.toObject(s), d.clipPath.inverted = this.clipPath.inverted, d.clipPath.absolutePositioned = this.clipPath.absolutePositioned), n.util.populateWithProperties(this, d, s), this.includeDefaultValues || (d = this._removeDefaultValues(d)), d }, toDatalessObject: function (s) { return this.toObject(s) }, _removeDefaultValues: function (s) { var f = n.util.getKlass(s.type).prototype, d = f.stateProperties; return d.forEach(function (p) { p === "left" || p === "top" || (s[p] === f[p] && delete s[p], Array.isArray(s[p]) && Array.isArray(f[p]) && s[p].length === 0 && f[p].length === 0 && delete s[p]) }), s }, toString: function () { return "#<fabric." + r(this.type) + ">" }, getObjectScaling: function () { if (!this.group) return { scaleX: this.scaleX, scaleY: this.scaleY }; var s = n.util.qrDecompose(this.calcTransformMatrix()); return { scaleX: Math.abs(s.scaleX), scaleY: Math.abs(s.scaleY) } }, getTotalObjectScaling: function () { var s = this.getObjectScaling(), f = s.scaleX, d = s.scaleY; if (this.canvas) { var p = this.canvas.getZoom(), m = this.canvas.getRetinaScaling(); f *= p * m, d *= p * m } return { scaleX: f, scaleY: d } }, getObjectOpacity: function () { var s = this.opacity; return this.group && (s *= this.group.getObjectOpacity()), s }, _set: function (s, f) { var d = s === "scaleX" || s === "scaleY", p = this[s] !== f, m = !1; return d && (f = this._constrainScale(f)), s === "scaleX" && f < 0 ? (this.flipX = !this.flipX, f *= -1) : s === "scaleY" && f < 0 ? (this.flipY = !this.flipY, f *= -1) : s === "shadow" && f && !(f instanceof n.Shadow) ? f = new n.Shadow(f) : s === "dirty" && this.group && this.group.set("dirty", f), this[s] = f, p && (m = this.group && this.group.isOnACache(), this.cacheProperties.indexOf(s) > -1 ? (this.dirty = !0, m && this.group.set("dirty", !0)) : m && this.stateProperties.indexOf(s) > -1 && this.group.set("dirty", !0)), this }, setOnGroup: function () { }, getViewportTransform: function () { return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : n.iMatrix.concat() }, isNotVisible: function () { return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible }, render: function (s) { this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (s.save(), this._setupCompositeOperation(s), this.drawSelectionBackground(s), this.transform(s), this._setOpacity(s), this._setShadow(s, this), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(s)) : (this._removeCacheCanvas(), this.dirty = !1, this.drawObject(s), this.objectCaching && this.statefullCache && this.saveState({ propertySet: "cacheProperties" })), s.restore()) }, renderCache: function (s) { s = s || {}, (!this._cacheCanvas || !this._cacheContext) && this._createCacheCanvas(), this.isCacheDirty() && (this.statefullCache && this.saveState({ propertySet: "cacheProperties" }), this.drawObject(this._cacheContext, s.forClipping), this.dirty = !1) }, _removeCacheCanvas: function () { this._cacheCanvas = null, this._cacheContext = null, this.cacheWidth = 0, this.cacheHeight = 0 }, hasStroke: function () { return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0 }, hasFill: function () { return this.fill && this.fill !== "transparent" }, needsItsOwnCache: function () { return !!(this.paintFirst === "stroke" && this.hasFill() && this.hasStroke() && typeof this.shadow == "object" || this.clipPath) }, shouldCache: function () { return this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache()), this.ownCaching }, willDrawShadow: function () { return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0) }, drawClipPathOnCache: function (s, f) { if (s.save(), f.inverted ? s.globalCompositeOperation = "destination-out" : s.globalCompositeOperation = "destination-in", f.absolutePositioned) { var d = n.util.invertTransform(this.calcTransformMatrix()); s.transform(d[0], d[1], d[2], d[3], d[4], d[5]) } f.transform(s), s.scale(1 / f.zoomX, 1 / f.zoomY), s.drawImage(f._cacheCanvas, -f.cacheTranslationX, -f.cacheTranslationY), s.restore() }, drawObject: function (s, f) { var d = this.fill, p = this.stroke; f ? (this.fill = "black", this.stroke = "", this._setClippingProperties(s)) : this._renderBackground(s), this._render(s), this._drawClipPath(s, this.clipPath), this.fill = d, this.stroke = p }, _drawClipPath: function (s, f) { f && (f.canvas = this.canvas, f.shouldCache(), f._transformDone = !0, f.renderCache({ forClipping: !0 }), this.drawClipPathOnCache(s, f)) }, drawCacheOnCanvas: function (s) { s.scale(1 / this.zoomX, 1 / this.zoomY), s.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY) }, isCacheDirty: function (s) { if (this.isNotVisible()) return !1; if (this._cacheCanvas && this._cacheContext && !s && this._updateCacheCanvas()) return !0; if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) { if (this._cacheCanvas && this._cacheContext && !s) { var f = this.cacheWidth / this.zoomX, d = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-f / 2, -d / 2, f, d) } return !0 } return !1 }, _renderBackground: function (s) { if (this.backgroundColor) { var f = this._getNonTransformedDimensions(); s.fillStyle = this.backgroundColor, s.fillRect(-f.x / 2, -f.y / 2, f.x, f.y), this._removeShadow(s) } }, _setOpacity: function (s) { this.group && !this.group._transformDone ? s.globalAlpha = this.getObjectOpacity() : s.globalAlpha *= this.opacity }, _setStrokeStyles: function (s, f) { var d = f.stroke; d && (s.lineWidth = f.strokeWidth, s.lineCap = f.strokeLineCap, s.lineDashOffset = f.strokeDashOffset, s.lineJoin = f.strokeLineJoin, s.miterLimit = f.strokeMiterLimit, d.toLive ? d.gradientUnits === "percentage" || d.gradientTransform || d.patternTransform ? this._applyPatternForTransformedGradient(s, d) : (s.strokeStyle = d.toLive(s, this), this._applyPatternGradientTransform(s, d)) : s.strokeStyle = f.stroke) }, _setFillStyles: function (s, f) { var d = f.fill; d && (d.toLive ? (s.fillStyle = d.toLive(s, this), this._applyPatternGradientTransform(s, f.fill)) : s.fillStyle = d) }, _setClippingProperties: function (s) { s.globalAlpha = 1, s.strokeStyle = "transparent", s.fillStyle = "#000000" }, _setLineDash: function (s, f) { !f || f.length === 0 || (1 & f.length && f.push.apply(f, f), s.setLineDash(f)) }, _renderControls: function (s, f) { var d = this.getViewportTransform(), p = this.calcTransformMatrix(), m, y, x; f = f || {}, y = typeof f.hasBorders < "u" ? f.hasBorders : this.hasBorders, x = typeof f.hasControls < "u" ? f.hasControls : this.hasControls, p = n.util.multiplyTransformMatrices(d, p), m = n.util.qrDecompose(p), s.save(), s.translate(m.translateX, m.translateY), s.lineWidth = 1 * this.borderScaleFactor, this.group || (s.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (m.angle -= 180), s.rotate(e(this.group ? m.angle : this.angle)), f.forActiveSelection || this.group ? y && this.drawBordersInGroup(s, m, f) : y && this.drawBorders(s, f), x && this.drawControls(s, f), s.restore() }, _setShadow: function (s) { if (this.shadow) { var f = this.shadow, d = this.canvas, p, m = d && d.viewportTransform[0] || 1, y = d && d.viewportTransform[3] || 1; f.nonScaling ? p = { scaleX: 1, scaleY: 1 } : p = this.getObjectScaling(), d && d._isRetinaScaling() && (m *= n.devicePixelRatio, y *= n.devicePixelRatio), s.shadowColor = f.color, s.shadowBlur = f.blur * n.browserShadowBlurConstant * (m + y) * (p.scaleX + p.scaleY) / 4, s.shadowOffsetX = f.offsetX * m * p.scaleX, s.shadowOffsetY = f.offsetY * y * p.scaleY } }, _removeShadow: function (s) { this.shadow && (s.shadowColor = "", s.shadowBlur = s.shadowOffsetX = s.shadowOffsetY = 0) }, _applyPatternGradientTransform: function (s, f) { if (!f || !f.toLive) return { offsetX: 0, offsetY: 0 }; var d = f.gradientTransform || f.patternTransform, p = -this.width / 2 + f.offsetX || 0, m = -this.height / 2 + f.offsetY || 0; return f.gradientUnits === "percentage" ? s.transform(this.width, 0, 0, this.height, p, m) : s.transform(1, 0, 0, 1, p, m), d && s.transform(d[0], d[1], d[2], d[3], d[4], d[5]), { offsetX: p, offsetY: m } }, _renderPaintInOrder: function (s) { this.paintFirst === "stroke" ? (this._renderStroke(s), this._renderFill(s)) : (this._renderFill(s), this._renderStroke(s)) }, _render: function () { }, _renderFill: function (s) { this.fill && (s.save(), this._setFillStyles(s, this), this.fillRule === "evenodd" ? s.fill("evenodd") : s.fill(), s.restore()) }, _renderStroke: function (s) { if (!(!this.stroke || this.strokeWidth === 0)) { if (this.shadow && !this.shadow.affectStroke && this._removeShadow(s), s.save(), this.strokeUniform && this.group) { var f = this.getObjectScaling(); s.scale(1 / f.scaleX, 1 / f.scaleY) } else this.strokeUniform && s.scale(1 / this.scaleX, 1 / this.scaleY); this._setLineDash(s, this.strokeDashArray), this._setStrokeStyles(s, this), s.stroke(), s.restore() } }, _applyPatternForTransformedGradient: function (s, f) { var d = this._limitCacheSize(this._getCacheCanvasDimensions()), p = n.util.createCanvasElement(), m, y = this.canvas.getRetinaScaling(), x = d.x / this.scaleX / y, P = d.y / this.scaleY / y; p.width = x, p.height = P, m = p.getContext("2d"), m.beginPath(), m.moveTo(0, 0), m.lineTo(x, 0), m.lineTo(x, P), m.lineTo(0, P), m.closePath(), m.translate(x / 2, P / 2), m.scale(d.zoomX / this.scaleX / y, d.zoomY / this.scaleY / y), this._applyPatternGradientTransform(m, f), m.fillStyle = f.toLive(s), m.fill(), s.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), s.scale(y * this.scaleX / d.zoomX, y * this.scaleY / d.zoomY), s.strokeStyle = m.createPattern(p, "no-repeat") }, _findCenterFromElement: function () { return { x: this.left + this.width / 2, y: this.top + this.height / 2 } }, _assignTransformMatrixProps: function () { if (this.transformMatrix) { var s = n.util.qrDecompose(this.transformMatrix); this.flipX = !1, this.flipY = !1, this.set("scaleX", s.scaleX), this.set("scaleY", s.scaleY), this.angle = s.angle, this.skewX = s.skewX, this.skewY = 0 } }, _removeTransformMatrix: function (s) { var f = this._findCenterFromElement(); this.transformMatrix && (this._assignTransformMatrixProps(), f = n.util.transformPoint(f, this.transformMatrix)), this.transformMatrix = null, s && (this.scaleX *= s.scaleX, this.scaleY *= s.scaleY, this.cropX = s.cropX, this.cropY = s.cropY, f.x += s.offsetLeft, f.y += s.offsetTop, this.width = s.width, this.height = s.height), this.setPositionByOrigin(f, "center", "center") }, clone: function (s, f) { var d = this.toObject(f); this.constructor.fromObject ? this.constructor.fromObject(d, s) : n.Object._fromObject("Object", d, s) }, cloneAsImage: function (s, f) { var d = this.toCanvasElement(f); return s && s(new n.Image(d)), this }, toCanvasElement: function (s) { s || (s = {}); var f = n.util, d = f.saveObjectTransform(this), p = this.group, m = this.shadow, y = Math.abs, x = (s.multiplier || 1) * (s.enableRetinaScaling ? n.devicePixelRatio : 1); delete this.group, s.withoutTransform && f.resetObjectTransform(this), s.withoutShadow && (this.shadow = null); var P = n.util.createCanvasElement(), D = this.getBoundingRect(!0, !0), Y = this.shadow, V, J = { x: 0, y: 0 }, Q, rt, tt; Y && (Q = Y.blur, Y.nonScaling ? V = { scaleX: 1, scaleY: 1 } : V = this.getObjectScaling(), J.x = 2 * Math.round(y(Y.offsetX) + Q) * y(V.scaleX), J.y = 2 * Math.round(y(Y.offsetY) + Q) * y(V.scaleY)), rt = D.width + J.x, tt = D.height + J.y, P.width = Math.ceil(rt), P.height = Math.ceil(tt); var it = new n.StaticCanvas(P, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }); s.format === "jpeg" && (it.backgroundColor = "#fff"), this.setPositionByOrigin(new n.Point(it.width / 2, it.height / 2), "center", "center"); var ot = this.canvas; it.add(this); var st = it.toCanvasElement(x || 1, s); return this.shadow = m, this.set("canvas", ot), p && (this.group = p), this.set(d).setCoords(), it._objects = [], it.dispose(), it = null, st }, toDataURL: function (s) { return s || (s = {}), n.util.toDataURL(this.toCanvasElement(s), s.format || "png", s.quality || 1) }, isType: function (s) { return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === s }, complexity: function () { return 1 }, toJSON: function (s) { return this.toObject(s) }, rotate: function (s) { var f = (this.originX !== "center" || this.originY !== "center") && this.centeredRotation; return f && this._setOriginToCenter(), this.set("angle", s), f && this._resetOrigin(), this }, centerH: function () { return this.canvas && this.canvas.centerObjectH(this), this }, viewportCenterH: function () { return this.canvas && this.canvas.viewportCenterObjectH(this), this }, centerV: function () { return this.canvas && this.canvas.centerObjectV(this), this }, viewportCenterV: function () { return this.canvas && this.canvas.viewportCenterObjectV(this), this }, center: function () { return this.canvas && this.canvas.centerObject(this), this }, viewportCenter: function () { return this.canvas && this.canvas.viewportCenterObject(this), this }, getLocalPointer: function (s, f) { f = f || this.canvas.getPointer(s); var d = new n.Point(f.x, f.y), p = this._getLeftTopCoords(); return this.angle && (d = n.util.rotatePoint(d, p, e(-this.angle))), { x: d.x - p.x, y: d.y - p.y } }, _setupCompositeOperation: function (s) { this.globalCompositeOperation && (s.globalCompositeOperation = this.globalCompositeOperation) }, dispose: function () { n.runningAnimations && n.runningAnimations.cancelByTarget(this) } }), n.util.createAccessors && n.util.createAccessors(n.Object), l(n.Object.prototype, n.Observable), n.Object.NUM_FRACTION_DIGITS = 2, n.Object.ENLIVEN_PROPS = ["clipPath"], n.Object._fromObject = function (s, f, d, p) { var m = n[s]; f = h(f, !0), n.util.enlivenPatterns([f.fill, f.stroke], function (y) { typeof y[0] < "u" && (f.fill = y[0]), typeof y[1] < "u" && (f.stroke = y[1]), n.util.enlivenObjectEnlivables(f, f, function () { var x = p ? new m(f[p], f) : new m(f); d && d(x) }) }) }, n.Object.__uid = 0) }(a), function () { var u = t.util.degreesToRadians, n = { left: -.5, center: 0, right: .5 }, l = { top: -.5, center: 0, bottom: .5 }; t.util.object.extend(t.Object.prototype, { translateToGivenOrigin: function (h, i, r, e, o) { var c = h.x, s = h.y, f, d, p; return typeof i == "string" ? i = n[i] : i -= .5, typeof e == "string" ? e = n[e] : e -= .5, f = e - i, typeof r == "string" ? r = l[r] : r -= .5, typeof o == "string" ? o = l[o] : o -= .5, d = o - r, (f || d) && (p = this._getTransformedDimensions(), c = h.x + f * p.x, s = h.y + d * p.y), new t.Point(c, s) }, translateToCenterPoint: function (h, i, r) { var e = this.translateToGivenOrigin(h, i, r, "center", "center"); return this.angle ? t.util.rotatePoint(e, h, u(this.angle)) : e }, translateToOriginPoint: function (h, i, r) { var e = this.translateToGivenOrigin(h, "center", "center", i, r); return this.angle ? t.util.rotatePoint(e, h, u(this.angle)) : e }, getCenterPoint: function () { var h = new t.Point(this.left, this.top); return this.translateToCenterPoint(h, this.originX, this.originY) }, getPointByOrigin: function (h, i) { var r = this.getCenterPoint(); return this.translateToOriginPoint(r, h, i) }, toLocalPoint: function (h, i, r) { var e = this.getCenterPoint(), o, c; return typeof i < "u" && typeof r < "u" ? o = this.translateToGivenOrigin(e, "center", "center", i, r) : o = new t.Point(this.left, this.top), c = new t.Point(h.x, h.y), this.angle && (c = t.util.rotatePoint(c, e, -u(this.angle))), c.subtractEquals(o) }, setPositionByOrigin: function (h, i, r) { var e = this.translateToCenterPoint(h, i, r), o = this.translateToOriginPoint(e, this.originX, this.originY); this.set("left", o.x), this.set("top", o.y) }, adjustPosition: function (h) { var i = u(this.angle), r = this.getScaledWidth(), e = t.util.cos(i) * r, o = t.util.sin(i) * r, c, s; typeof this.originX == "string" ? c = n[this.originX] : c = this.originX - .5, typeof h == "string" ? s = n[h] : s = h - .5, this.left += e * (s - c), this.top += o * (s - c), this.setCoords(), this.originX = h }, _setOriginToCenter: function () { this._originalOriginX = this.originX, this._originalOriginY = this.originY; var h = this.getCenterPoint(); this.originX = "center", this.originY = "center", this.left = h.x, this.top = h.y }, _resetOrigin: function () { var h = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY); this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = h.x, this.top = h.y, this._originalOriginX = null, this._originalOriginY = null }, _getLeftTopCoords: function () { return this.translateToOriginPoint(this.getCenterPoint(), "left", "top") } }) }(), function () { function u(r) { return [new t.Point(r.tl.x, r.tl.y), new t.Point(r.tr.x, r.tr.y), new t.Point(r.br.x, r.br.y), new t.Point(r.bl.x, r.bl.y)] } var n = t.util, l = n.degreesToRadians, h = n.multiplyTransformMatrices, i = n.transformPoint; n.object.extend(t.Object.prototype, { oCoords: null, aCoords: null, lineCoords: null, ownMatrixCache: null, matrixCache: null, controls: {}, _getCoords: function (r, e) { return e ? r ? this.calcACoords() : this.calcLineCoords() : ((!this.aCoords || !this.lineCoords) && this.setCoords(!0), r ? this.aCoords : this.lineCoords) }, getCoords: function (r, e) { return u(this._getCoords(r, e)) }, intersectsWithRect: function (r, e, o, c) { var s = this.getCoords(o, c), f = t.Intersection.intersectPolygonRectangle(s, r, e); return f.status === "Intersection" }, intersectsWithObject: function (r, e, o) { var c = t.Intersection.intersectPolygonPolygon(this.getCoords(e, o), r.getCoords(e, o)); return c.status === "Intersection" || r.isContainedWithinObject(this, e, o) || this.isContainedWithinObject(r, e, o) }, isContainedWithinObject: function (r, e, o) { for (var c = this.getCoords(e, o), s = e ? r.aCoords : r.lineCoords, f = 0, d = r._getImageLines(s); f < 4; f++)if (!r.containsPoint(c[f], d)) return !1; return !0 }, isContainedWithinRect: function (r, e, o, c) { var s = this.getBoundingRect(o, c); return s.left >= r.x && s.left + s.width <= e.x && s.top >= r.y && s.top + s.height <= e.y }, containsPoint: function (r, f, o, c) { var s = this._getCoords(o, c), f = f || this._getImageLines(s), d = this._findCrossPoints(r, f); return d !== 0 && d % 2 === 1 }, isOnScreen: function (r) { if (!this.canvas) return !1; var e = this.canvas.vptCoords.tl, o = this.canvas.vptCoords.br, c = this.getCoords(!0, r); return c.some(function (s) { return s.x <= o.x && s.x >= e.x && s.y <= o.y && s.y >= e.y }) || this.intersectsWithRect(e, o, !0, r) ? !0 : this._containsCenterOfCanvas(e, o, r) }, _containsCenterOfCanvas: function (r, e, o) { var c = { x: (r.x + e.x) / 2, y: (r.y + e.y) / 2 }; return !!this.containsPoint(c, null, !0, o) }, isPartiallyOnScreen: function (r) { if (!this.canvas) return !1; var e = this.canvas.vptCoords.tl, o = this.canvas.vptCoords.br; if (this.intersectsWithRect(e, o, !0, r)) return !0; var c = this.getCoords(!0, r).every(function (s) { return (s.x >= o.x || s.x <= e.x) && (s.y >= o.y || s.y <= e.y) }); return c && this._containsCenterOfCanvas(e, o, r) }, _getImageLines: function (r) { var e = { topline: { o: r.tl, d: r.tr }, rightline: { o: r.tr, d: r.br }, bottomline: { o: r.br, d: r.bl }, leftline: { o: r.bl, d: r.tl } }; return e }, _findCrossPoints: function (r, e) { var o, c, s, f, d, p = 0, m; for (var y in e) if (m = e[y], !(m.o.y < r.y && m.d.y < r.y) && !(m.o.y >= r.y && m.d.y >= r.y) && (m.o.x === m.d.x && m.o.x >= r.x ? d = m.o.x : (o = 0, c = (m.d.y - m.o.y) / (m.d.x - m.o.x), s = r.y - o * r.x, f = m.o.y - c * m.o.x, d = -(s - f) / (o - c)), d >= r.x && (p += 1), p === 2)) break; return p }, getBoundingRect: function (r, e) { var o = this.getCoords(r, e); return n.makeBoundingBoxFromPoints(o) }, getScaledWidth: function () { return this._getTransformedDimensions().x }, getScaledHeight: function () { return this._getTransformedDimensions().y }, _constrainScale: function (r) { return Math.abs(r) < this.minScaleLimit ? r < 0 ? -this.minScaleLimit : this.minScaleLimit : r === 0 ? 1e-4 : r }, scale: function (r) { return this._set("scaleX", r), this._set("scaleY", r), this.setCoords() }, scaleToWidth: function (r, e) { var o = this.getBoundingRect(e).width / this.getScaledWidth(); return this.scale(r / this.width / o) }, scaleToHeight: function (r, e) { var o = this.getBoundingRect(e).height / this.getScaledHeight(); return this.scale(r / this.height / o) }, calcLineCoords: function () { var r = this.getViewportTransform(), e = this.padding, o = l(this.angle), c = n.cos(o), s = n.sin(o), f = c * e, d = s * e, p = f + d, m = f - d, y = this.calcACoords(), x = { tl: i(y.tl, r), tr: i(y.tr, r), bl: i(y.bl, r), br: i(y.br, r) }; return e && (x.tl.x -= m, x.tl.y -= p, x.tr.x += p, x.tr.y -= m, x.bl.x -= p, x.bl.y += m, x.br.x += m, x.br.y += p), x }, calcOCoords: function () { var r = this._calcRotateMatrix(), e = this._calcTranslateMatrix(), o = this.getViewportTransform(), c = h(o, e), s = h(c, r), s = h(s, [1 / o[0], 0, 0, 1 / o[3], 0, 0]), f = this._calculateCurrentDimensions(), d = {}; return this.forEachControl(function (p, m, y) { d[m] = p.positionHandler(f, s, y) }), d }, calcACoords: function () { var r = this._calcRotateMatrix(), e = this._calcTranslateMatrix(), o = h(e, r), c = this._getTransformedDimensions(), s = c.x / 2, f = c.y / 2; return { tl: i({ x: -s, y: -f }, o), tr: i({ x: s, y: -f }, o), bl: i({ x: -s, y: f }, o), br: i({ x: s, y: f }, o) } }, setCoords: function (r) { return this.aCoords = this.calcACoords(), this.lineCoords = this.group ? this.aCoords : this.calcLineCoords(), r ? this : (this.oCoords = this.calcOCoords(), this._setCornerCoords && this._setCornerCoords(), this) }, _calcRotateMatrix: function () { return n.calcRotateMatrix(this) }, _calcTranslateMatrix: function () { var r = this.getCenterPoint(); return [1, 0, 0, 1, r.x, r.y] }, transformMatrixKey: function (r) { var e = "_", o = ""; return !r && this.group && (o = this.group.transformMatrixKey(r) + e), o + this.top + e + this.left + e + this.scaleX + e + this.scaleY + e + this.skewX + e + this.skewY + e + this.angle + e + this.originX + e + this.originY + e + this.width + e + this.height + e + this.strokeWidth + this.flipX + this.flipY }, calcTransformMatrix: function (r) { var e = this.calcOwnMatrix(); if (r || !this.group) return e; var o = this.transformMatrixKey(r), c = this.matrixCache || (this.matrixCache = {}); return c.key === o ? c.value : (this.group && (e = h(this.group.calcTransformMatrix(!1), e)), c.key = o, c.value = e, e) }, calcOwnMatrix: function () { var r = this.transformMatrixKey(!0), e = this.ownMatrixCache || (this.ownMatrixCache = {}); if (e.key === r) return e.value; var o = this._calcTranslateMatrix(), c = { angle: this.angle, translateX: o[4], translateY: o[5], scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }; return e.key = r, e.value = n.composeMatrix(c), e.value }, _getNonTransformedDimensions: function () { var r = this.strokeWidth, e = this.width + r, o = this.height + r; return { x: e, y: o } }, _getTransformedDimensions: function (r, e) { typeof r > "u" && (r = this.skewX), typeof e > "u" && (e = this.skewY); var o, c, s, f = r === 0 && e === 0; if (this.strokeUniform ? (c = this.width, s = this.height) : (o = this._getNonTransformedDimensions(), c = o.x, s = o.y), f) return this._finalizeDimensions(c * this.scaleX, s * this.scaleY); var d = n.sizeAfterTransform(c, s, { scaleX: this.scaleX, scaleY: this.scaleY, skewX: r, skewY: e }); return this._finalizeDimensions(d.x, d.y) }, _finalizeDimensions: function (r, e) { return this.strokeUniform ? { x: r + this.strokeWidth, y: e + this.strokeWidth } : { x: r, y: e } }, _calculateCurrentDimensions: function () { var r = this.getViewportTransform(), e = this._getTransformedDimensions(), o = i(e, r, !0); return o.scalarAdd(2 * this.padding) } }) }(), t.util.object.extend(t.Object.prototype, { sendToBack: function () { return this.group ? t.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas && this.canvas.sendToBack(this), this }, bringToFront: function () { return this.group ? t.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas && this.canvas.bringToFront(this), this }, sendBackwards: function (u) { return this.group ? t.StaticCanvas.prototype.sendBackwards.call(this.group, this, u) : this.canvas && this.canvas.sendBackwards(this, u), this }, bringForward: function (u) { return this.group ? t.StaticCanvas.prototype.bringForward.call(this.group, this, u) : this.canvas && this.canvas.bringForward(this, u), this }, moveTo: function (u) { return this.group && this.group.type !== "activeSelection" ? t.StaticCanvas.prototype.moveTo.call(this.group, this, u) : this.canvas && this.canvas.moveTo(this, u), this } }), function () {
    function u(l, h) { if (h) { if (h.toLive) return l + ": url(#SVGID_" + h.id + "); "; var i = new t.Color(h), r = l + ": " + i.toRgb() + "; ", e = i.getAlpha(); return e !== 1 && (r += l + "-opacity: " + e.toString() + "; "), r } else return l + ": none; " } var n = t.util.toFixed; t.util.object.extend(t.Object.prototype, {
        getSvgStyles: function (l) { var h = this.fillRule ? this.fillRule : "nonzero", i = this.strokeWidth ? this.strokeWidth : "0", r = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", e = this.strokeDashOffset ? this.strokeDashOffset : "0", o = this.strokeLineCap ? this.strokeLineCap : "butt", c = this.strokeLineJoin ? this.strokeLineJoin : "miter", s = this.strokeMiterLimit ? this.strokeMiterLimit : "4", f = typeof this.opacity < "u" ? this.opacity : "1", d = this.visible ? "" : " visibility: hidden;", p = l ? "" : this.getSvgFilter(), m = u("fill", this.fill), y = u("stroke", this.stroke); return [y, "stroke-width: ", i, "; ", "stroke-dasharray: ", r, "; ", "stroke-linecap: ", o, "; ", "stroke-dashoffset: ", e, "; ", "stroke-linejoin: ", c, "; ", "stroke-miterlimit: ", s, "; ", m, "fill-rule: ", h, "; ", "opacity: ", f, ";", p, d].join("") }, getSvgSpanStyles: function (l, h) { var i = "; ", e = l.fontFamily ? "font-family: " + (l.fontFamily.indexOf("'") === -1 && l.fontFamily.indexOf('"') === -1 ? "'" + l.fontFamily + "'" : l.fontFamily) + i : "", r = l.strokeWidth ? "stroke-width: " + l.strokeWidth + i : "", e = e, o = l.fontSize ? "font-size: " + l.fontSize + "px" + i : "", c = l.fontStyle ? "font-style: " + l.fontStyle + i : "", s = l.fontWeight ? "font-weight: " + l.fontWeight + i : "", f = l.fill ? u("fill", l.fill) : "", d = l.stroke ? u("stroke", l.stroke) : "", p = this.getSvgTextDecoration(l), m = l.deltaY ? "baseline-shift: " + -l.deltaY + "; " : ""; return p && (p = "text-decoration: " + p + i), [d, r, e, o, c, s, p, f, m, h ? "white-space: pre; " : ""].join("") }, getSvgTextDecoration: function (l) { return ["overline", "underline", "line-through"].filter(function (h) { return l[h.replace("-", "")] }).join(" ") }, getSvgFilter: function () { return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "" }, getSvgCommons: function () { return [this.id ? 'id="' + this.id + '" ' : "", this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : ""].join("") }, getSvgTransform: function (l, h) { var i = l ? this.calcTransformMatrix() : this.calcOwnMatrix(), r = 'transform="' + t.util.matrixToSVG(i); return r + (h || "") + '" ' }, _setSVGBg: function (l) {
            if (this.backgroundColor) {
                var h = t.Object.NUM_FRACTION_DIGITS; l.push("		<rect ", this._getFillAttributes(this.backgroundColor), ' x="', n(-this.width / 2, h), '" y="', n(-this.height / 2, h), '" width="', n(this.width, h), '" height="', n(this.height, h), `"></rect>
`)
            }
        }, toSVG: function (l) { return this._createBaseSVGMarkup(this._toSVG(l), { reviver: l }) }, toClipPathSVG: function (l) { return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(l), { reviver: l }) }, _createBaseClipPathSVGMarkup: function (l, h) { h = h || {}; var i = h.reviver, r = h.additionalTransform || "", e = [this.getSvgTransform(!0, r), this.getSvgCommons()].join(""), o = l.indexOf("COMMON_PARTS"); return l[o] = e, i ? i(l.join("")) : l.join("") }, _createBaseSVGMarkup: function (l, h) {
            h = h || {}; var i = h.noStyle, r = h.reviver, e = i ? "" : 'style="' + this.getSvgStyles() + '" ', o = h.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "", c = this.clipPath, s = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", f = c && c.absolutePositioned, d = this.stroke, p = this.fill, m = this.shadow, y, x = [], P, D = l.indexOf("COMMON_PARTS"), Y = h.additionalTransform; return c && (c.clipPathId = "CLIPPATH_" + t.Object.__uid++, P = '<clipPath id="' + c.clipPathId + `" >
`+ c.toClipPathSVG(r) + `</clipPath>
`), f && x.push("<g ", o, this.getSvgCommons(), ` >
`), x.push("<g ", this.getSvgTransform(!1), f ? "" : o + this.getSvgCommons(), ` >
`), y = [e, s, i ? "" : this.addPaintOrder(), " ", Y ? 'transform="' + Y + '" ' : ""].join(""), l[D] = y, p && p.toLive && x.push(p.toSVG(this)), d && d.toLive && x.push(d.toSVG(this)), m && x.push(m.toSVG(this)), c && x.push(P), x.push(l.join("")), x.push(`</g>
`), f && x.push(`</g>
`), r ? r(x.join("")) : x.join("")
        }, addPaintOrder: function () { return this.paintFirst !== "fill" ? ' paint-order="' + this.paintFirst + '" ' : "" }
    })
}(), function () { var u = t.util.object.extend, n = "stateProperties"; function l(i, r, e) { var o = {}, c = !0; e.forEach(function (s) { o[s] = i[s] }), u(i[r], o, c) } function h(i, r, e) { if (i === r) return !0; if (Array.isArray(i)) { if (!Array.isArray(r) || i.length !== r.length) return !1; for (var o = 0, c = i.length; o < c; o++)if (!h(i[o], r[o])) return !1; return !0 } else if (i && typeof i == "object") { var s = Object.keys(i), f; if (!r || typeof r != "object" || !e && s.length !== Object.keys(r).length) return !1; for (var o = 0, c = s.length; o < c; o++)if (f = s[o], !(f === "canvas" || f === "group") && !h(i[f], r[f])) return !1; return !0 } } t.util.object.extend(t.Object.prototype, { hasStateChanged: function (i) { i = i || n; var r = "_" + i; return Object.keys(this[r]).length < this[i].length ? !0 : !h(this[r], this, !0) }, saveState: function (i) { var r = i && i.propertySet || n, e = "_" + r; return this[e] ? (l(this, e, this[r]), i && i.stateProperties && l(this, e, i.stateProperties), this) : this.setupState(i) }, setupState: function (i) { i = i || {}; var r = i.propertySet || n; return i.propertySet = r, this["_" + r] = {}, this.saveState(i), this } }) }(), function () { var u = t.util.degreesToRadians; t.util.object.extend(t.Object.prototype, { _findTargetCorner: function (n, l) { if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) return !1; var h = n.x, i = n.y, r, e, o = Object.keys(this.oCoords), c = o.length - 1, s; for (this.__corner = 0; c >= 0; c--)if (s = o[c], !!this.isControlVisible(s) && (e = this._getImageLines(l ? this.oCoords[s].touchCorner : this.oCoords[s].corner), r = this._findCrossPoints({ x: h, y: i }, e), r !== 0 && r % 2 === 1)) return this.__corner = s, s; return !1 }, forEachControl: function (n) { for (var l in this.controls) n(this.controls[l], l, this) }, _setCornerCoords: function () { var n = this.oCoords; for (var l in n) { var h = this.controls[l]; n[l].corner = h.calcCornerCoords(this.angle, this.cornerSize, n[l].x, n[l].y, !1), n[l].touchCorner = h.calcCornerCoords(this.angle, this.touchCornerSize, n[l].x, n[l].y, !0) } }, drawSelectionBackground: function (n) { if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) return this; n.save(); var l = this.getCenterPoint(), h = this._calculateCurrentDimensions(), i = this.canvas.viewportTransform; return n.translate(l.x, l.y), n.scale(1 / i[0], 1 / i[3]), n.rotate(u(this.angle)), n.fillStyle = this.selectionBackgroundColor, n.fillRect(-h.x / 2, -h.y / 2, h.x, h.y), n.restore(), this }, drawBorders: function (n, l) { l = l || {}; var h = this._calculateCurrentDimensions(), i = this.borderScaleFactor, r = h.x + i, e = h.y + i, o = typeof l.hasControls < "u" ? l.hasControls : this.hasControls, c = !1; return n.save(), n.strokeStyle = l.borderColor || this.borderColor, this._setLineDash(n, l.borderDashArray || this.borderDashArray), n.strokeRect(-r / 2, -e / 2, r, e), o && (n.beginPath(), this.forEachControl(function (s, f, d) { s.withConnection && s.getVisibility(d, f) && (c = !0, n.moveTo(s.x * r, s.y * e), n.lineTo(s.x * r + s.offsetX, s.y * e + s.offsetY)) }), c && n.stroke()), n.restore(), this }, drawBordersInGroup: function (n, l, h) { h = h || {}; var i = t.util.sizeAfterTransform(this.width, this.height, l), r = this.strokeWidth, e = this.strokeUniform, o = this.borderScaleFactor, c = i.x + r * (e ? this.canvas.getZoom() : l.scaleX) + o, s = i.y + r * (e ? this.canvas.getZoom() : l.scaleY) + o; return n.save(), this._setLineDash(n, h.borderDashArray || this.borderDashArray), n.strokeStyle = h.borderColor || this.borderColor, n.strokeRect(-c / 2, -s / 2, c, s), n.restore(), this }, drawControls: function (n, l) { l = l || {}, n.save(); var h = this.canvas.getRetinaScaling(), i, r; return n.setTransform(h, 0, 0, h, 0, 0), n.strokeStyle = n.fillStyle = l.cornerColor || this.cornerColor, this.transparentCorners || (n.strokeStyle = l.cornerStrokeColor || this.cornerStrokeColor), this._setLineDash(n, l.cornerDashArray || this.cornerDashArray), this.setCoords(), this.group && (i = this.group.calcTransformMatrix()), this.forEachControl(function (e, o, c) { r = c.oCoords[o], e.getVisibility(c, o) && (i && (r = t.util.transformPoint(r, i)), e.render(n, r.x, r.y, l, c)) }), n.restore(), this }, isControlVisible: function (n) { return this.controls[n] && this.controls[n].getVisibility(this, n) }, setControlVisible: function (n, l) { return this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[n] = l, this }, setControlsVisibility: function (n) { n || (n = {}); for (var l in n) this.setControlVisible(l, n[l]); return this }, onDeselect: function () { }, onSelect: function () { } }) }(), t.util.object.extend(t.StaticCanvas.prototype, { FX_DURATION: 500, fxCenterObjectH: function (u, n) { n = n || {}; var l = function () { }, h = n.onComplete || l, i = n.onChange || l, r = this; return t.util.animate({ target: this, startValue: u.left, endValue: this.getCenterPoint().x, duration: this.FX_DURATION, onChange: function (e) { u.set("left", e), r.requestRenderAll(), i() }, onComplete: function () { u.setCoords(), h() } }) }, fxCenterObjectV: function (u, n) { n = n || {}; var l = function () { }, h = n.onComplete || l, i = n.onChange || l, r = this; return t.util.animate({ target: this, startValue: u.top, endValue: this.getCenterPoint().y, duration: this.FX_DURATION, onChange: function (e) { u.set("top", e), r.requestRenderAll(), i() }, onComplete: function () { u.setCoords(), h() } }) }, fxRemove: function (u, n) { n = n || {}; var l = function () { }, h = n.onComplete || l, i = n.onChange || l, r = this; return t.util.animate({ target: this, startValue: u.opacity, endValue: 0, duration: this.FX_DURATION, onChange: function (e) { u.set("opacity", e), r.requestRenderAll(), i() }, onComplete: function () { r.remove(u), h() } }) } }), t.util.object.extend(t.Object.prototype, { animate: function () { if (arguments[0] && typeof arguments[0] == "object") { var u = [], n, l, h = []; for (n in arguments[0]) u.push(n); for (var i = 0, r = u.length; i < r; i++)n = u[i], l = i !== r - 1, h.push(this._animate(n, arguments[0][n], arguments[1], l)); return h } else return this._animate.apply(this, arguments) }, _animate: function (u, n, l, h) { var i = this, r; n = n.toString(), l ? l = t.util.object.clone(l) : l = {}, ~u.indexOf(".") && (r = u.split(".")); var e = i.colorProperties.indexOf(u) > -1 || r && i.colorProperties.indexOf(r[1]) > -1, o = r ? this.get(r[0])[r[1]] : this.get(u); "from" in l || (l.from = o), e || (~n.indexOf("=") ? n = o + parseFloat(n.replace("=", "")) : n = parseFloat(n)); var c = { target: this, startValue: l.from, endValue: n, byValue: l.by, easing: l.easing, duration: l.duration, abort: l.abort && function (s, f, d) { return l.abort.call(i, s, f, d) }, onChange: function (s, f, d) { r ? i[r[0]][r[1]] = s : i.set(u, s), !h && l.onChange && l.onChange(s, f, d) }, onComplete: function (s, f, d) { h || (i.setCoords(), l.onComplete && l.onComplete(s, f, d)) } }; return e ? t.util.animateColor(c.startValue, c.endValue, c.duration, c) : t.util.animate(c) } }), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.object.extend, h = n.util.object.clone, i = { x1: 1, x2: 1, y1: 1, y2: 1 }; if (n.Line) { n.warn("fabric.Line is already defined"); return } n.Line = n.util.createClass(n.Object, {
        type: "line", x1: 0, y1: 0, x2: 0, y2: 0, cacheProperties: n.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"), initialize: function (e, o) { e || (e = [0, 0, 0, 0]), this.callSuper("initialize", o), this.set("x1", e[0]), this.set("y1", e[1]), this.set("x2", e[2]), this.set("y2", e[3]), this._setWidthHeight(o) }, _setWidthHeight: function (e) { e || (e = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in e ? e.left : this._getLeftToOriginX(), this.top = "top" in e ? e.top : this._getTopToOriginY() }, _set: function (e, o) { return this.callSuper("_set", e, o), typeof i[e] < "u" && this._setWidthHeight(), this }, _getLeftToOriginX: r({ origin: "originX", axis1: "x1", axis2: "x2", dimension: "width" }, { nearest: "left", center: "center", farthest: "right" }), _getTopToOriginY: r({ origin: "originY", axis1: "y1", axis2: "y2", dimension: "height" }, { nearest: "top", center: "center", farthest: "bottom" }), _render: function (e) { e.beginPath(); var o = this.calcLinePoints(); e.moveTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineWidth = this.strokeWidth; var c = e.strokeStyle; e.strokeStyle = this.stroke || e.fillStyle, this.stroke && this._renderStroke(e), e.strokeStyle = c }, _findCenterFromElement: function () { return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 } }, toObject: function (e) { return l(this.callSuper("toObject", e), this.calcLinePoints()) }, _getNonTransformedDimensions: function () { var e = this.callSuper("_getNonTransformedDimensions"); return this.strokeLineCap === "butt" && (this.width === 0 && (e.y -= this.strokeWidth), this.height === 0 && (e.x -= this.strokeWidth)), e }, calcLinePoints: function () { var e = this.x1 <= this.x2 ? -1 : 1, o = this.y1 <= this.y2 ? -1 : 1, c = e * this.width * .5, s = o * this.height * .5, f = e * this.width * -.5, d = o * this.height * -.5; return { x1: c, x2: f, y1: s, y2: d } }, _toSVG: function () {
            var e = this.calcLinePoints(); return ["<line ", "COMMON_PARTS", 'x1="', e.x1, '" y1="', e.y1, '" x2="', e.x2, '" y2="', e.y2, `" />
`]
        }
    }), n.Line.ATTRIBUTE_NAMES = n.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), n.Line.fromElement = function (e, o, c) { c = c || {}; var s = n.parseAttributes(e, n.Line.ATTRIBUTE_NAMES), f = [s.x1 || 0, s.y1 || 0, s.x2 || 0, s.y2 || 0]; o(new n.Line(f, l(s, c))) }, n.Line.fromObject = function (e, o) { function c(f) { delete f.points, o && o(f) } var s = h(e, !0); s.points = [e.x1, e.y1, e.x2, e.y2], n.Object._fromObject("Line", s, c, "points") }; function r(e, o) { var c = e.origin, s = e.axis1, f = e.axis2, d = e.dimension, p = o.nearest, m = o.center, y = o.farthest; return function () { switch (this.get(c)) { case p: return Math.min(this.get(s), this.get(f)); case m: return Math.min(this.get(s), this.get(f)) + .5 * this.get(d); case y: return Math.max(this.get(s), this.get(f)) } } }
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.degreesToRadians; if (n.Circle) { n.warn("fabric.Circle is already defined."); return } n.Circle = n.util.createClass(n.Object, {
        type: "circle", radius: 0, startAngle: 0, endAngle: 360, cacheProperties: n.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"), _set: function (i, r) { return this.callSuper("_set", i, r), i === "radius" && this.setRadius(r), this }, toObject: function (i) { return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(i)) }, _toSVG: function () {
            var i, r = 0, e = 0, o = (this.endAngle - this.startAngle) % 360; if (o === 0) i = ["<circle ", "COMMON_PARTS", 'cx="' + r + '" cy="' + e + '" ', 'r="', this.radius, `" />
`]; else {
                var c = l(this.startAngle), s = l(this.endAngle), f = this.radius, d = n.util.cos(c) * f, p = n.util.sin(c) * f, m = n.util.cos(s) * f, y = n.util.sin(s) * f, x = o > 180 ? "1" : "0"; i = ['<path d="M ' + d + " " + p, " A " + f + " " + f, " 0 ", +x + " 1", " " + m + " " + y, '" ', "COMMON_PARTS", ` />
`]
            } return i
        }, _render: function (i) { i.beginPath(), i.arc(0, 0, this.radius, l(this.startAngle), l(this.endAngle), !1), this._renderPaintInOrder(i) }, getRadiusX: function () { return this.get("radius") * this.get("scaleX") }, getRadiusY: function () { return this.get("radius") * this.get("scaleY") }, setRadius: function (i) { return this.radius = i, this.set("width", i * 2).set("height", i * 2) }
    }), n.Circle.ATTRIBUTE_NAMES = n.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), n.Circle.fromElement = function (i, r) { var e = n.parseAttributes(i, n.Circle.ATTRIBUTE_NAMES); if (!h(e)) throw new Error("value of `r` attribute is required and can not be negative"); e.left = (e.left || 0) - e.radius, e.top = (e.top || 0) - e.radius, r(new n.Circle(e)) }; function h(i) { return "radius" in i && i.radius >= 0 } n.Circle.fromObject = function (i, r) { n.Object._fromObject("Circle", i, r) }
}(a), function (u) { var n = u.fabric || (u.fabric = {}); if (n.Triangle) { n.warn("fabric.Triangle is already defined"); return } n.Triangle = n.util.createClass(n.Object, { type: "triangle", width: 100, height: 100, _render: function (l) { var h = this.width / 2, i = this.height / 2; l.beginPath(), l.moveTo(-h, i), l.lineTo(0, -i), l.lineTo(h, i), l.closePath(), this._renderPaintInOrder(l) }, _toSVG: function () { var l = this.width / 2, h = this.height / 2, i = [-l + " " + h, "0 " + -h, l + " " + h].join(","); return ["<polygon ", "COMMON_PARTS", 'points="', i, '" />'] } }), n.Triangle.fromObject = function (l, h) { return n.Object._fromObject("Triangle", l, h) } }(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = Math.PI * 2; if (n.Ellipse) { n.warn("fabric.Ellipse is already defined."); return } n.Ellipse = n.util.createClass(n.Object, {
        type: "ellipse", rx: 0, ry: 0, cacheProperties: n.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function (h) { this.callSuper("initialize", h), this.set("rx", h && h.rx || 0), this.set("ry", h && h.ry || 0) }, _set: function (h, i) { switch (this.callSuper("_set", h, i), h) { case "rx": this.rx = i, this.set("width", i * 2); break; case "ry": this.ry = i, this.set("height", i * 2); break }return this }, getRx: function () { return this.get("rx") * this.get("scaleX") }, getRy: function () { return this.get("ry") * this.get("scaleY") }, toObject: function (h) { return this.callSuper("toObject", ["rx", "ry"].concat(h)) }, _toSVG: function () {
            return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" ', 'rx="', this.rx, '" ry="', this.ry, `" />
`]
        }, _render: function (h) { h.beginPath(), h.save(), h.transform(1, 0, 0, this.ry / this.rx, 0, 0), h.arc(0, 0, this.rx, 0, l, !1), h.restore(), this._renderPaintInOrder(h) }
    }), n.Ellipse.ATTRIBUTE_NAMES = n.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), n.Ellipse.fromElement = function (h, i) { var r = n.parseAttributes(h, n.Ellipse.ATTRIBUTE_NAMES); r.left = (r.left || 0) - r.rx, r.top = (r.top || 0) - r.ry, i(new n.Ellipse(r)) }, n.Ellipse.fromObject = function (h, i) { n.Object._fromObject("Ellipse", h, i) }
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.object.extend; if (n.Rect) { n.warn("fabric.Rect is already defined"); return } n.Rect = n.util.createClass(n.Object, {
        stateProperties: n.Object.prototype.stateProperties.concat("rx", "ry"), type: "rect", rx: 0, ry: 0, cacheProperties: n.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function (h) { this.callSuper("initialize", h), this._initRxRy() }, _initRxRy: function () { this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry) }, _render: function (h) { var i = this.rx ? Math.min(this.rx, this.width / 2) : 0, r = this.ry ? Math.min(this.ry, this.height / 2) : 0, e = this.width, o = this.height, c = -this.width / 2, s = -this.height / 2, f = i !== 0 || r !== 0, d = 1 - .5522847498; h.beginPath(), h.moveTo(c + i, s), h.lineTo(c + e - i, s), f && h.bezierCurveTo(c + e - d * i, s, c + e, s + d * r, c + e, s + r), h.lineTo(c + e, s + o - r), f && h.bezierCurveTo(c + e, s + o - d * r, c + e - d * i, s + o, c + e - i, s + o), h.lineTo(c + i, s + o), f && h.bezierCurveTo(c + d * i, s + o, c, s + o - d * r, c, s + o - r), h.lineTo(c, s + r), f && h.bezierCurveTo(c, s + d * r, c + d * i, s, c + i, s), h.closePath(), this._renderPaintInOrder(h) }, toObject: function (h) { return this.callSuper("toObject", ["rx", "ry"].concat(h)) }, _toSVG: function () {
            var h = -this.width / 2, i = -this.height / 2; return ["<rect ", "COMMON_PARTS", 'x="', h, '" y="', i, '" rx="', this.rx, '" ry="', this.ry, '" width="', this.width, '" height="', this.height, `" />
`]
        }
    }), n.Rect.ATTRIBUTE_NAMES = n.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), n.Rect.fromElement = function (h, i, r) { if (!h) return i(null); r = r || {}; var e = n.parseAttributes(h, n.Rect.ATTRIBUTE_NAMES); e.left = e.left || 0, e.top = e.top || 0, e.height = e.height || 0, e.width = e.width || 0; var o = new n.Rect(l(r ? n.util.object.clone(r) : {}, e)); o.visible = o.visible && o.width > 0 && o.height > 0, i(o) }, n.Rect.fromObject = function (h, i) { return n.Object._fromObject("Rect", h, i) }
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.object.extend, h = n.util.array.min, i = n.util.array.max, r = n.util.toFixed, e = n.util.projectStrokeOnPoints; if (n.Polyline) { n.warn("fabric.Polyline is already defined"); return } n.Polyline = n.util.createClass(n.Object, {
        type: "polyline", points: null, exactBoundingBox: !1, cacheProperties: n.Object.prototype.cacheProperties.concat("points"), initialize: function (o, c) { c = c || {}, this.points = o || [], this.callSuper("initialize", c), this._setPositionDimensions(c) }, _projectStrokeOnPoints: function () { return e(this.points, this, !0) }, _setPositionDimensions: function (o) { var c = this._calcDimensions(o), s, f = this.exactBoundingBox ? this.strokeWidth : 0; this.width = c.width - f, this.height = c.height - f, o.fromSVG || (s = this.translateToGivenOrigin({ x: c.left - this.strokeWidth / 2 + f / 2, y: c.top - this.strokeWidth / 2 + f / 2 }, "left", "top", this.originX, this.originY)), typeof o.left > "u" && (this.left = o.fromSVG ? c.left : s.x), typeof o.top > "u" && (this.top = o.fromSVG ? c.top : s.y), this.pathOffset = { x: c.left + this.width / 2 + f / 2, y: c.top + this.height / 2 + f / 2 } }, _calcDimensions: function () { var o = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, c = h(o, "x") || 0, s = h(o, "y") || 0, f = i(o, "x") || 0, d = i(o, "y") || 0, p = f - c, m = d - s; return { left: c, top: s, width: p, height: m } }, toObject: function (o) { return l(this.callSuper("toObject", o), { points: this.points.concat() }) }, _toSVG: function () {
            for (var o = [], c = this.pathOffset.x, s = this.pathOffset.y, f = n.Object.NUM_FRACTION_DIGITS, d = 0, p = this.points.length; d < p; d++)o.push(r(this.points[d].x - c, f), ",", r(this.points[d].y - s, f), " "); return ["<" + this.type + " ", "COMMON_PARTS", 'points="', o.join(""), `" />
`]
        }, commonRender: function (o) { var c, s = this.points.length, f = this.pathOffset.x, d = this.pathOffset.y; if (!s || isNaN(this.points[s - 1].y)) return !1; o.beginPath(), o.moveTo(this.points[0].x - f, this.points[0].y - d); for (var p = 0; p < s; p++)c = this.points[p], o.lineTo(c.x - f, c.y - d); return !0 }, _render: function (o) { this.commonRender(o) && this._renderPaintInOrder(o) }, complexity: function () { return this.get("points").length }
    }), n.Polyline.ATTRIBUTE_NAMES = n.SHARED_ATTRIBUTES.concat(), n.Polyline.fromElementGenerator = function (o) { return function (c, s, f) { if (!c) return s(null); f || (f = {}); var d = n.parsePointsAttribute(c.getAttribute("points")), p = n.parseAttributes(c, n[o].ATTRIBUTE_NAMES); p.fromSVG = !0, s(new n[o](d, l(p, f))) } }, n.Polyline.fromElement = n.Polyline.fromElementGenerator("Polyline"), n.Polyline.fromObject = function (o, c) { return n.Object._fromObject("Polyline", o, c, "points") }
}(a), function (u) { var n = u.fabric || (u.fabric = {}), l = n.util.projectStrokeOnPoints; if (n.Polygon) { n.warn("fabric.Polygon is already defined"); return } n.Polygon = n.util.createClass(n.Polyline, { type: "polygon", _projectStrokeOnPoints: function () { return l(this.points, this) }, _render: function (h) { this.commonRender(h) && (h.closePath(), this._renderPaintInOrder(h)) } }), n.Polygon.ATTRIBUTE_NAMES = n.SHARED_ATTRIBUTES.concat(), n.Polygon.fromElement = n.Polyline.fromElementGenerator("Polygon"), n.Polygon.fromObject = function (h, i) { n.Object._fromObject("Polygon", h, i, "points") } }(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.array.min, h = n.util.array.max, i = n.util.object.extend, r = n.util.object.clone, e = n.util.toFixed; if (n.Path) { n.warn("fabric.Path is already defined"); return } n.Path = n.util.createClass(n.Object, {
        type: "path", path: null, cacheProperties: n.Object.prototype.cacheProperties.concat("path", "fillRule"), stateProperties: n.Object.prototype.stateProperties.concat("path"), initialize: function (o, c) { c = r(c || {}), delete c.path, this.callSuper("initialize", c), this._setPath(o || [], c) }, _setPath: function (o, c) { this.path = n.util.makePathSimpler(Array.isArray(o) ? o : n.util.parsePath(o)), n.Polyline.prototype._setPositionDimensions.call(this, c || {}) }, _renderPathCommands: function (o) { var c, s = 0, f = 0, d = 0, p = 0, m = 0, y = 0, x = -this.pathOffset.x, P = -this.pathOffset.y; o.beginPath(); for (var D = 0, Y = this.path.length; D < Y; ++D)switch (c = this.path[D], c[0]) { case "L": d = c[1], p = c[2], o.lineTo(d + x, p + P); break; case "M": d = c[1], p = c[2], s = d, f = p, o.moveTo(d + x, p + P); break; case "C": d = c[5], p = c[6], m = c[3], y = c[4], o.bezierCurveTo(c[1] + x, c[2] + P, m + x, y + P, d + x, p + P); break; case "Q": o.quadraticCurveTo(c[1] + x, c[2] + P, c[3] + x, c[4] + P), d = c[3], p = c[4], m = c[1], y = c[2]; break; case "z": case "Z": d = s, p = f, o.closePath(); break } }, _render: function (o) { this._renderPathCommands(o), this._renderPaintInOrder(o) }, toString: function () { return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>" }, toObject: function (o) { return i(this.callSuper("toObject", o), { path: this.path.map(function (c) { return c.slice() }) }) }, toDatalessObject: function (o) { var c = this.toObject(["sourcePath"].concat(o)); return c.sourcePath && delete c.path, c }, _toSVG: function () {
            var o = n.util.joinPath(this.path); return ["<path ", "COMMON_PARTS", 'd="', o, '" stroke-linecap="round" ', `/>
`]
        }, _getOffsetTransform: function () { var o = n.Object.NUM_FRACTION_DIGITS; return " translate(" + e(-this.pathOffset.x, o) + ", " + e(-this.pathOffset.y, o) + ")" }, toClipPathSVG: function (o) { var c = this._getOffsetTransform(); return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: o, additionalTransform: c }) }, toSVG: function (o) { var c = this._getOffsetTransform(); return this._createBaseSVGMarkup(this._toSVG(), { reviver: o, additionalTransform: c }) }, complexity: function () { return this.path.length }, _calcDimensions: function () { for (var o = [], c = [], s, f = 0, d = 0, p = 0, m = 0, y, x = 0, P = this.path.length; x < P; ++x) { switch (s = this.path[x], s[0]) { case "L": p = s[1], m = s[2], y = []; break; case "M": p = s[1], m = s[2], f = p, d = m, y = []; break; case "C": y = n.util.getBoundsOfCurve(p, m, s[1], s[2], s[3], s[4], s[5], s[6]), p = s[5], m = s[6]; break; case "Q": y = n.util.getBoundsOfCurve(p, m, s[1], s[2], s[1], s[2], s[3], s[4]), p = s[3], m = s[4]; break; case "z": case "Z": p = f, m = d; break }y.forEach(function (tt) { o.push(tt.x), c.push(tt.y) }), o.push(p), c.push(m) } var D = l(o) || 0, Y = l(c) || 0, V = h(o) || 0, J = h(c) || 0, Q = V - D, rt = J - Y; return { left: D, top: Y, width: Q, height: rt } }
    }), n.Path.fromObject = function (o, c) { if (typeof o.sourcePath == "string") { var s = o.sourcePath; n.loadSVGFromURL(s, function (f) { var d = f[0]; d.setOptions(o), o.clipPath ? n.util.enlivenObjects([o.clipPath], function (p) { d.clipPath = p[0], c && c(d) }) : c && c(d) }) } else n.Object._fromObject("Path", o, c, "path") }, n.Path.ATTRIBUTE_NAMES = n.SHARED_ATTRIBUTES.concat(["d"]), n.Path.fromElement = function (o, c, s) { var f = n.parseAttributes(o, n.Path.ATTRIBUTE_NAMES); f.fromSVG = !0, c(new n.Path(f.d, i(f, s))) }
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.array.min, h = n.util.array.max; n.Group || (n.Group = n.util.createClass(n.Object, n.Collection, {
        type: "group", strokeWidth: 0, subTargetCheck: !1, cacheProperties: [], useSetOnGroup: !1, initialize: function (i, r, e) { r = r || {}, this._objects = [], e && this.callSuper("initialize", r), this._objects = i || []; for (var o = this._objects.length; o--;)this._objects[o].group = this; if (e) this._updateObjectsACoords(); else { var c = r && r.centerPoint; r.originX !== void 0 && (this.originX = r.originX), r.originY !== void 0 && (this.originY = r.originY), c || this._calcBounds(), this._updateObjectsCoords(c), delete r.centerPoint, this.callSuper("initialize", r) } this.setCoords() }, _updateObjectsACoords: function () { for (var i = !0, r = this._objects.length; r--;)this._objects[r].setCoords(i) }, _updateObjectsCoords: function (r) { for (var r = r || this.getCenterPoint(), e = this._objects.length; e--;)this._updateObjectCoords(this._objects[e], r) }, _updateObjectCoords: function (i, r) { var e = i.left, o = i.top, c = !0; i.set({ left: e - r.x, top: o - r.y }), i.group = this, i.setCoords(c) }, toString: function () { return "#<fabric.Group: (" + this.complexity() + ")>" }, addWithUpdate: function (i) { var r = !!this.group; return this._restoreObjectsState(), n.util.resetObjectTransform(this), i && (r && n.util.removeTransformFromObject(i, this.group.calcTransformMatrix()), this._objects.push(i), i.group = this, i._set("canvas", this.canvas)), this._calcBounds(), this._updateObjectsCoords(), this.dirty = !0, r ? this.group.addWithUpdate() : this.setCoords(), this }, removeWithUpdate: function (i) { return this._restoreObjectsState(), n.util.resetObjectTransform(this), this.remove(i), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this }, _onObjectAdded: function (i) { this.dirty = !0, i.group = this, i._set("canvas", this.canvas) }, _onObjectRemoved: function (i) { this.dirty = !0, delete i.group }, _set: function (i, r) { var e = this._objects.length; if (this.useSetOnGroup) for (; e--;)this._objects[e].setOnGroup(i, r); if (i === "canvas") for (; e--;)this._objects[e]._set(i, r); n.Object.prototype._set.call(this, i, r) }, toObject: function (i) { var r = this.includeDefaultValues, e = this._objects.filter(function (c) { return !c.excludeFromExport }).map(function (c) { var s = c.includeDefaultValues; c.includeDefaultValues = r; var f = c.toObject(i); return c.includeDefaultValues = s, f }), o = n.Object.prototype.toObject.call(this, i); return o.objects = e, o }, toDatalessObject: function (i) { var r, e = this.sourcePath; if (e) r = e; else { var o = this.includeDefaultValues; r = this._objects.map(function (s) { var f = s.includeDefaultValues; s.includeDefaultValues = o; var d = s.toDatalessObject(i); return s.includeDefaultValues = f, d }) } var c = n.Object.prototype.toDatalessObject.call(this, i); return c.objects = r, c }, render: function (i) { this._transformDone = !0, this.callSuper("render", i), this._transformDone = !1 }, shouldCache: function () { var i = n.Object.prototype.shouldCache.call(this); if (i) { for (var r = 0, e = this._objects.length; r < e; r++)if (this._objects[r].willDrawShadow()) return this.ownCaching = !1, !1 } return i }, willDrawShadow: function () { if (n.Object.prototype.willDrawShadow.call(this)) return !0; for (var i = 0, r = this._objects.length; i < r; i++)if (this._objects[i].willDrawShadow()) return !0; return !1 }, isOnACache: function () { return this.ownCaching || this.group && this.group.isOnACache() }, drawObject: function (i) { for (var r = 0, e = this._objects.length; r < e; r++)this._objects[r].render(i); this._drawClipPath(i, this.clipPath) }, isCacheDirty: function (i) { if (this.callSuper("isCacheDirty", i)) return !0; if (!this.statefullCache) return !1; for (var r = 0, e = this._objects.length; r < e; r++)if (this._objects[r].isCacheDirty(!0)) { if (this._cacheCanvas) { var o = this.cacheWidth / this.zoomX, c = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-o / 2, -c / 2, o, c) } return !0 } return !1 }, _restoreObjectsState: function () { var i = this.calcOwnMatrix(); return this._objects.forEach(function (r) { n.util.addTransformToObject(r, i), delete r.group, r.setCoords() }), this }, destroy: function () { return this._objects.forEach(function (i) { i.set("dirty", !0) }), this._restoreObjectsState() }, dispose: function () { this.callSuper("dispose"), this.forEachObject(function (i) { i.dispose && i.dispose() }), this._objects = [] }, toActiveSelection: function () { if (this.canvas) { var i = this._objects, r = this.canvas; this._objects = []; var e = this.toObject(); delete e.objects; var o = new n.ActiveSelection([]); return o.set(e), o.type = "activeSelection", r.remove(this), i.forEach(function (c) { c.group = o, c.dirty = !0, r.add(c) }), o.canvas = r, o._objects = i, r._activeObject = o, o.setCoords(), o } }, ungroupOnCanvas: function () { return this._restoreObjectsState() }, setObjectsCoords: function () { var i = !0; return this.forEachObject(function (r) { r.setCoords(i) }), this }, _calcBounds: function (i) { for (var r = [], e = [], o, c, s, f = ["tr", "br", "bl", "tl"], d = 0, p = this._objects.length, m, y = f.length; d < p; ++d) { for (o = this._objects[d], s = o.calcACoords(), m = 0; m < y; m++)c = f[m], r.push(s[c].x), e.push(s[c].y); o.aCoords = s } this._getBounds(r, e, i) }, _getBounds: function (i, r, e) { var o = new n.Point(l(i), l(r)), c = new n.Point(h(i), h(r)), s = o.y || 0, f = o.x || 0, d = c.x - o.x || 0, p = c.y - o.y || 0; this.width = d, this.height = p, e || this.setPositionByOrigin({ x: f, y: s }, "left", "top") }, _toSVG: function (i) {
            for (var r = ["<g ", "COMMON_PARTS", ` >
`], e = 0, o = this._objects.length; e < o; e++)r.push("		", this._objects[e].toSVG(i)); return r.push(`</g>
`), r
        }, getSvgStyles: function () { var i = typeof this.opacity < "u" && this.opacity !== 1 ? "opacity: " + this.opacity + ";" : "", r = this.visible ? "" : " visibility: hidden;"; return [i, this.getSvgFilter(), r].join("") }, toClipPathSVG: function (i) { for (var r = [], e = 0, o = this._objects.length; e < o; e++)r.push("	", this._objects[e].toClipPathSVG(i)); return this._createBaseClipPathSVGMarkup(r, { reviver: i }) }
    }), n.Group.fromObject = function (i, r) { var e = i.objects, o = n.util.object.clone(i, !0); if (delete o.objects, typeof e == "string") { n.loadSVGFromURL(e, function (c) { var s = n.util.groupSVGElements(c, i, e), f = o.clipPath; delete o.clipPath, s.set(o), f ? n.util.enlivenObjects([f], function (d) { s.clipPath = d[0], r && r(s) }) : r && r(s) }); return } n.util.enlivenObjects(e, function (c) { n.util.enlivenObjectEnlivables(i, o, function () { r && r(new n.Group(c, o, !0)) }) }) })
}(a), function (u) { var n = u.fabric || (u.fabric = {}); n.ActiveSelection || (n.ActiveSelection = n.util.createClass(n.Group, { type: "activeSelection", initialize: function (l, h) { h = h || {}, this._objects = l || []; for (var i = this._objects.length; i--;)this._objects[i].group = this; h.originX && (this.originX = h.originX), h.originY && (this.originY = h.originY), this._calcBounds(), this._updateObjectsCoords(), n.Object.prototype.initialize.call(this, h), this.setCoords() }, toGroup: function () { var l = this._objects.concat(); this._objects = []; var h = n.Object.prototype.toObject.call(this), i = new n.Group([]); if (delete h.type, i.set(h), l.forEach(function (e) { e.canvas.remove(e), e.group = i }), i._objects = l, !this.canvas) return i; var r = this.canvas; return r.add(i), r._activeObject = i, i.setCoords(), i }, onDeselect: function () { return this.destroy(), !1 }, toString: function () { return "#<fabric.ActiveSelection: (" + this.complexity() + ")>" }, shouldCache: function () { return !1 }, isOnACache: function () { return !1 }, _renderControls: function (l, h, i) { l.save(), l.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper("_renderControls", l, h), i = i || {}, typeof i.hasControls > "u" && (i.hasControls = !1), i.forActiveSelection = !0; for (var r = 0, e = this._objects.length; r < e; r++)this._objects[r]._renderControls(l, i); l.restore() } }), n.ActiveSelection.fromObject = function (l, h) { n.util.enlivenObjects(l.objects, function (i) { delete l.objects, h && h(new n.ActiveSelection(i, l, !0)) }) }) }(a), function (u) {
    var n = t.util.object.extend; if (u.fabric || (u.fabric = {}), u.fabric.Image) { t.warn("fabric.Image is already defined."); return } t.Image = t.util.createClass(t.Object, {
        type: "image", strokeWidth: 0, srcFromAttribute: !1, _lastScaleX: 1, _lastScaleY: 1, _filterScalingX: 1, _filterScalingY: 1, minimumScaleTrigger: .5, stateProperties: t.Object.prototype.stateProperties.concat("cropX", "cropY"), cacheProperties: t.Object.prototype.cacheProperties.concat("cropX", "cropY"), cacheKey: "", cropX: 0, cropY: 0, imageSmoothing: !0, initialize: function (l, h) { h || (h = {}), this.filters = [], this.cacheKey = "texture" + t.Object.__uid++, this.callSuper("initialize", h), this._initElement(l, h) }, getElement: function () { return this._element || {} }, setElement: function (l, h) { return this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._element = l, this._originalElement = l, this._initConfig(h), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters(), this }, removeTexture: function (l) { var h = t.filterBackend; h && h.evictCachesForKey && h.evictCachesForKey(l) }, dispose: function () { this.callSuper("dispose"), this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._cacheContext = void 0, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach(function (l) { t.util.cleanUpJsdomNode(this[l]), this[l] = void 0 }.bind(this)) }, getCrossOrigin: function () { return this._originalElement && (this._originalElement.crossOrigin || null) }, getOriginalSize: function () { var l = this.getElement(); return { width: l.naturalWidth || l.width, height: l.naturalHeight || l.height } }, _stroke: function (l) { if (!(!this.stroke || this.strokeWidth === 0)) { var h = this.width / 2, i = this.height / 2; l.beginPath(), l.moveTo(-h, -i), l.lineTo(h, -i), l.lineTo(h, i), l.lineTo(-h, i), l.lineTo(-h, -i), l.closePath() } }, toObject: function (l) { var h = []; this.filters.forEach(function (r) { r && h.push(r.toObject()) }); var i = n(this.callSuper("toObject", ["cropX", "cropY"].concat(l)), { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: h }); return this.resizeFilter && (i.resizeFilter = this.resizeFilter.toObject()), i }, hasCrop: function () { return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height }, _toSVG: function () {
            var l = [], h = [], i, r = this._element, e = -this.width / 2, o = -this.height / 2, c = "", s = ""; if (!r) return []; if (this.hasCrop()) {
                var f = t.Object.__uid++; l.push('<clipPath id="imageCrop_' + f + `">
`, '	<rect x="' + e + '" y="' + o + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), c = ' clip-path="url(#imageCrop_' + f + ')" '
            } if (this.imageSmoothing || (s = '" image-rendering="optimizeSpeed'), h.push("	<image ", "COMMON_PARTS", 'xlink:href="', this.getSvgSrc(!0), '" x="', e - this.cropX, '" y="', o - this.cropY, '" width="', r.width || r.naturalWidth, '" height="', r.height || r.height, s, '"', c, `></image>
`), this.stroke || this.strokeDashArray) {
                var d = this.fill; this.fill = null, i = ["	<rect ", 'x="', e, '" y="', o, '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), `"/>
`], this.fill = d
            } return this.paintFirst !== "fill" ? l = l.concat(i, h) : l = l.concat(h, i), l
        }, getSrc: function (l) { var h = l ? this._element : this._originalElement; return h ? h.toDataURL ? h.toDataURL() : this.srcFromAttribute ? h.getAttribute("src") : h.src : this.src || "" }, setSrc: function (l, h, i) { return t.util.loadImage(l, function (r, e) { this.setElement(r, i), this._setWidthHeight(), h && h(this, e) }, this, i && i.crossOrigin), this }, toString: function () { return '#<fabric.Image: { src: "' + this.getSrc() + '" }>' }, applyResizeFilters: function () { var l = this.resizeFilter, h = this.minimumScaleTrigger, i = this.getTotalObjectScaling(), r = i.scaleX, e = i.scaleY, o = this._filteredEl || this._originalElement; if (this.group && this.set("dirty", !0), !l || r > h && e > h) { this._element = o, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = r, this._lastScaleY = e; return } t.filterBackend || (t.filterBackend = t.initFilterBackend()); var c = t.util.createCanvasElement(), s = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey, f = o.width, d = o.height; c.width = f, c.height = d, this._element = c, this._lastScaleX = l.scaleX = r, this._lastScaleY = l.scaleY = e, t.filterBackend.applyFilters([l], o, f, d, this._element, s), this._filterScalingX = c.width / this._originalElement.width, this._filterScalingY = c.height / this._originalElement.height }, applyFilters: function (l) { if (l = l || this.filters || [], l = l.filter(function (o) { return o && !o.isNeutralState() }), this.set("dirty", !0), this.removeTexture(this.cacheKey + "_filtered"), l.length === 0) return this._element = this._originalElement, this._filteredEl = null, this._filterScalingX = 1, this._filterScalingY = 1, this; var h = this._originalElement, i = h.naturalWidth || h.width, r = h.naturalHeight || h.height; if (this._element === this._originalElement) { var e = t.util.createCanvasElement(); e.width = i, e.height = r, this._element = e, this._filteredEl = e } else this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, i, r), this._lastScaleX = 1, this._lastScaleY = 1; return t.filterBackend || (t.filterBackend = t.initFilterBackend()), t.filterBackend.applyFilters(l, this._originalElement, i, r, this._element, this.cacheKey), (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) && (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height), this }, _render: function (l) { t.util.setImageSmoothing(l, this.imageSmoothing), this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(l), this._renderPaintInOrder(l) }, drawCacheOnCanvas: function (l) { t.util.setImageSmoothing(l, this.imageSmoothing), t.Object.prototype.drawCacheOnCanvas.call(this, l) }, shouldCache: function () { return this.needsItsOwnCache() }, _renderFill: function (l) { var h = this._element; if (h) { var i = this._filterScalingX, r = this._filterScalingY, e = this.width, o = this.height, c = Math.min, s = Math.max, f = s(this.cropX, 0), d = s(this.cropY, 0), p = h.naturalWidth || h.width, m = h.naturalHeight || h.height, y = f * i, x = d * r, P = c(e * i, p - y), D = c(o * r, m - x), Y = -e / 2, V = -o / 2, J = c(e, p / i - f), Q = c(o, m / r - d); h && l.drawImage(h, y, x, P, D, Y, V, J, Q) } }, _needsResize: function () { var l = this.getTotalObjectScaling(); return l.scaleX !== this._lastScaleX || l.scaleY !== this._lastScaleY }, _resetWidthHeight: function () { this.set(this.getOriginalSize()) }, _initElement: function (l, h) { this.setElement(t.util.getById(l), h), t.util.addClass(this.getElement(), t.Image.CSS_CANVAS) }, _initConfig: function (l) { l || (l = {}), this.setOptions(l), this._setWidthHeight(l) }, _initFilters: function (l, h) { l && l.length ? t.util.enlivenObjects(l, function (i) { h && h(i) }, "fabric.Image.filters") : h && h() }, _setWidthHeight: function (l) { l || (l = {}); var h = this.getElement(); this.width = l.width || h.naturalWidth || h.width || 0, this.height = l.height || h.naturalHeight || h.height || 0 }, parsePreserveAspectRatioAttribute: function () { var l = t.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""), h = this._element.width, i = this._element.height, r = 1, e = 1, o = 0, c = 0, s = 0, f = 0, d, p = this.width, m = this.height, y = { width: p, height: m }; return l && (l.alignX !== "none" || l.alignY !== "none") ? (l.meetOrSlice === "meet" && (r = e = t.util.findScaleToFit(this._element, y), d = (p - h * r) / 2, l.alignX === "Min" && (o = -d), l.alignX === "Max" && (o = d), d = (m - i * e) / 2, l.alignY === "Min" && (c = -d), l.alignY === "Max" && (c = d)), l.meetOrSlice === "slice" && (r = e = t.util.findScaleToCover(this._element, y), d = h - p / r, l.alignX === "Mid" && (s = d / 2), l.alignX === "Max" && (s = d), d = i - m / e, l.alignY === "Mid" && (f = d / 2), l.alignY === "Max" && (f = d), h = p / r, i = m / e)) : (r = p / h, e = m / i), { width: h, height: i, scaleX: r, scaleY: e, offsetLeft: o, offsetTop: c, cropX: s, cropY: f } }
    }), t.Image.CSS_CANVAS = "canvas-img", t.Image.prototype.getSvgSrc = t.Image.prototype.getSrc, t.Image.fromObject = function (l, h) { var i = t.util.object.clone(l); t.util.loadImage(i.src, function (r, e) { if (e) { h && h(null, !0); return } t.Image.prototype._initFilters.call(i, i.filters, function (o) { i.filters = o || [], t.Image.prototype._initFilters.call(i, [i.resizeFilter], function (c) { i.resizeFilter = c[0], t.util.enlivenObjectEnlivables(i, i, function () { var s = new t.Image(r, i); h(s, !1) }) }) }) }, null, i.crossOrigin) }, t.Image.fromURL = function (l, h, i) { t.util.loadImage(l, function (r, e) { h && h(new t.Image(r, i), e) }, null, i && i.crossOrigin) }, t.Image.ATTRIBUTE_NAMES = t.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")), t.Image.fromElement = function (l, h, i) { var r = t.parseAttributes(l, t.Image.ATTRIBUTE_NAMES); t.Image.fromURL(r["xlink:href"], h, n(i ? t.util.object.clone(i) : {}, r)) }
}(a), t.util.object.extend(t.Object.prototype, { _getAngleValueForStraighten: function () { var u = this.angle % 360; return u > 0 ? Math.round((u - 1) / 90) * 90 : Math.round(u / 90) * 90 }, straighten: function () { return this.rotate(this._getAngleValueForStraighten()) }, fxStraighten: function (u) { u = u || {}; var n = function () { }, l = u.onComplete || n, h = u.onChange || n, i = this; return t.util.animate({ target: this, startValue: this.get("angle"), endValue: this._getAngleValueForStraighten(), duration: this.FX_DURATION, onChange: function (r) { i.rotate(r), h() }, onComplete: function () { i.setCoords(), l() } }) } }), t.util.object.extend(t.StaticCanvas.prototype, { straightenObject: function (u) { return u.straighten(), this.requestRenderAll(), this }, fxStraightenObject: function (u) { return u.fxStraighten({ onChange: this.requestRenderAllBound }) } }), function () {
    function u(l, h) {
        var i = "precision " + h + ` float;
void main(){}`, r = l.createShader(l.FRAGMENT_SHADER); return l.shaderSource(r, i), l.compileShader(r), !!l.getShaderParameter(r, l.COMPILE_STATUS)
    } t.isWebglSupported = function (l) { if (t.isLikelyNode) return !1; l = l || t.WebglFilterBackend.prototype.tileSize; var h = document.createElement("canvas"), i = h.getContext("webgl") || h.getContext("experimental-webgl"), r = !1; if (i) { t.maxTextureSize = i.getParameter(i.MAX_TEXTURE_SIZE), r = t.maxTextureSize >= l; for (var e = ["highp", "mediump", "lowp"], o = 0; o < 3; o++)if (u(i, e[o])) { t.webGlPrecision = e[o]; break } } return this.isSupported = r, r }, t.WebglFilterBackend = n; function n(l) { l && l.tileSize && (this.tileSize = l.tileSize), this.setupGLContext(this.tileSize, this.tileSize), this.captureGPUInfo() } n.prototype = { tileSize: 2048, resources: {}, setupGLContext: function (l, h) { this.dispose(), this.createWebGLCanvas(l, h), this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), this.chooseFastestCopyGLTo2DMethod(l, h) }, chooseFastestCopyGLTo2DMethod: function (l, h) { var i = typeof window.performance < "u", r; try { new ImageData(1, 1), r = !0 } catch { r = !1 } var e = typeof ArrayBuffer < "u", o = typeof Uint8ClampedArray < "u"; if (i && r && e && o) { var c = t.util.createCanvasElement(), s = new ArrayBuffer(l * h * 4); if (t.forceGLPutImageData) { this.imageBuffer = s, this.copyGLTo2D = b; return } var f = { imageBuffer: s, destinationWidth: l, destinationHeight: h, targetCanvas: c }, d, p, m; c.width = l, c.height = h, d = window.performance.now(), C.call(f, this.gl, f), p = window.performance.now() - d, d = window.performance.now(), b.call(f, this.gl, f), m = window.performance.now() - d, p > m ? (this.imageBuffer = s, this.copyGLTo2D = b) : this.copyGLTo2D = C } }, createWebGLCanvas: function (l, h) { var i = t.util.createCanvasElement(); i.width = l, i.height = h; var r = { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 }, e = i.getContext("webgl", r); e || (e = i.getContext("experimental-webgl", r)), e && (e.clearColor(0, 0, 0, 0), this.canvas = i, this.gl = e) }, applyFilters: function (l, h, i, r, e, o) { var c = this.gl, s; o && (s = this.getCachedTexture(o, h)); var f = { originalWidth: h.width || h.originalWidth, originalHeight: h.height || h.originalHeight, sourceWidth: i, sourceHeight: r, destinationWidth: i, destinationHeight: r, context: c, sourceTexture: this.createTexture(c, i, r, !s && h), targetTexture: this.createTexture(c, i, r), originalTexture: s || this.createTexture(c, i, r, !s && h), passes: l.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: e }, d = c.createFramebuffer(); return c.bindFramebuffer(c.FRAMEBUFFER, d), l.forEach(function (p) { p && p.applyTo(f) }), _(f), this.copyGLTo2D(c, f), c.bindTexture(c.TEXTURE_2D, null), c.deleteTexture(f.sourceTexture), c.deleteTexture(f.targetTexture), c.deleteFramebuffer(d), e.getContext("2d").setTransform(1, 0, 0, 1, 0, 0), f }, dispose: function () { this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches() }, clearWebGLCaches: function () { this.programCache = {}, this.textureCache = {} }, createTexture: function (l, h, i, r, e) { var o = l.createTexture(); return l.bindTexture(l.TEXTURE_2D, o), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, e || l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, e || l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), r ? l.texImage2D(l.TEXTURE_2D, 0, l.RGBA, l.RGBA, l.UNSIGNED_BYTE, r) : l.texImage2D(l.TEXTURE_2D, 0, l.RGBA, h, i, 0, l.RGBA, l.UNSIGNED_BYTE, null), o }, getCachedTexture: function (l, h) { if (this.textureCache[l]) return this.textureCache[l]; var i = this.createTexture(this.gl, h.width, h.height, h); return this.textureCache[l] = i, i }, evictCachesForKey: function (l) { this.textureCache[l] && (this.gl.deleteTexture(this.textureCache[l]), delete this.textureCache[l]) }, copyGLTo2D: C, captureGPUInfo: function () { if (this.gpuInfo) return this.gpuInfo; var l = this.gl, h = { renderer: "", vendor: "" }; if (!l) return h; var i = l.getExtension("WEBGL_debug_renderer_info"); if (i) { var r = l.getParameter(i.UNMASKED_RENDERER_WEBGL), e = l.getParameter(i.UNMASKED_VENDOR_WEBGL); r && (h.renderer = r.toLowerCase()), e && (h.vendor = e.toLowerCase()) } return this.gpuInfo = h, h } }
}(); function _(u) { var n = u.targetCanvas, l = n.width, h = n.height, i = u.destinationWidth, r = u.destinationHeight; (l !== i || h !== r) && (n.width = i, n.height = r) } function C(u, n) { var l = u.canvas, h = n.targetCanvas, i = h.getContext("2d"); i.translate(0, h.height), i.scale(1, -1); var r = l.height - h.height; i.drawImage(l, 0, r, h.width, h.height, 0, 0, h.width, h.height) } function b(u, n) { var l = n.targetCanvas, h = l.getContext("2d"), i = n.destinationWidth, r = n.destinationHeight, e = i * r * 4, o = new Uint8Array(this.imageBuffer, 0, e), c = new Uint8ClampedArray(this.imageBuffer, 0, e); u.readPixels(0, 0, i, r, u.RGBA, u.UNSIGNED_BYTE, o); var s = new ImageData(c, i, r); h.putImageData(s, 0, 0) } (function () { var u = function () { }; t.Canvas2dFilterBackend = n; function n() { } n.prototype = { evictCachesForKey: u, dispose: u, clearWebGLCaches: u, resources: {}, applyFilters: function (l, h, i, r, e) { var o = e.getContext("2d"); o.drawImage(h, 0, 0, i, r); var c = o.getImageData(0, 0, i, r), s = o.getImageData(0, 0, i, r), f = { sourceWidth: i, sourceHeight: r, imageData: c, originalEl: h, originalImageData: s, canvasEl: e, ctx: o, filterBackend: this }; return l.forEach(function (d) { d.applyTo(f) }), (f.imageData.width !== i || f.imageData.height !== r) && (e.width = f.imageData.width, e.height = f.imageData.height), o.putImageData(f.imageData, 0, 0), f } } })(), t.Image = t.Image || {}, t.Image.filters = t.Image.filters || {}, t.Image.filters.BaseFilter = t.util.createClass({
    type: "BaseFilter", vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
void main() {
vTexCoord = aPosition;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`, fragmentSource: `precision highp float;
varying vec2 vTexCoord;
uniform sampler2D uTexture;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
}`, initialize: function (u) { u && this.setOptions(u) }, setOptions: function (u) { for (var n in u) this[n] = u[n] }, createProgram: function (u, n, l) { n = n || this.fragmentSource, l = l || this.vertexSource, t.webGlPrecision !== "highp" && (n = n.replace(/precision highp float/g, "precision " + t.webGlPrecision + " float")); var h = u.createShader(u.VERTEX_SHADER); if (u.shaderSource(h, l), u.compileShader(h), !u.getShaderParameter(h, u.COMPILE_STATUS)) throw new Error("Vertex shader compile error for " + this.type + ": " + u.getShaderInfoLog(h)); var i = u.createShader(u.FRAGMENT_SHADER); if (u.shaderSource(i, n), u.compileShader(i), !u.getShaderParameter(i, u.COMPILE_STATUS)) throw new Error("Fragment shader compile error for " + this.type + ": " + u.getShaderInfoLog(i)); var r = u.createProgram(); if (u.attachShader(r, h), u.attachShader(r, i), u.linkProgram(r), !u.getProgramParameter(r, u.LINK_STATUS)) throw new Error('Shader link error for "${this.type}" ' + u.getProgramInfoLog(r)); var e = this.getAttributeLocations(u, r), o = this.getUniformLocations(u, r) || {}; return o.uStepW = u.getUniformLocation(r, "uStepW"), o.uStepH = u.getUniformLocation(r, "uStepH"), { program: r, attributeLocations: e, uniformLocations: o } }, getAttributeLocations: function (u, n) { return { aPosition: u.getAttribLocation(n, "aPosition") } }, getUniformLocations: function () { return {} }, sendAttributeData: function (u, n, l) { var h = n.aPosition, i = u.createBuffer(); u.bindBuffer(u.ARRAY_BUFFER, i), u.enableVertexAttribArray(h), u.vertexAttribPointer(h, 2, u.FLOAT, !1, 0, 0), u.bufferData(u.ARRAY_BUFFER, l, u.STATIC_DRAW) }, _setupFrameBuffer: function (u) { var n = u.context, l, h; u.passes > 1 ? (l = u.destinationWidth, h = u.destinationHeight, (u.sourceWidth !== l || u.sourceHeight !== h) && (n.deleteTexture(u.targetTexture), u.targetTexture = u.filterBackend.createTexture(n, l, h)), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, u.targetTexture, 0)) : (n.bindFramebuffer(n.FRAMEBUFFER, null), n.finish()) }, _swapTextures: function (u) { u.passes--, u.pass++; var n = u.targetTexture; u.targetTexture = u.sourceTexture, u.sourceTexture = n }, isNeutralState: function () { var u = this.mainParameter, n = t.Image.filters[this.type].prototype; if (u) if (Array.isArray(n[u])) { for (var l = n[u].length; l--;)if (this[u][l] !== n[u][l]) return !1; return !0 } else return n[u] === this[u]; else return !1 }, applyTo: function (u) { u.webgl ? (this._setupFrameBuffer(u), this.applyToWebGL(u), this._swapTextures(u)) : this.applyTo2d(u) }, retrieveShader: function (u) { return u.programCache.hasOwnProperty(this.type) || (u.programCache[this.type] = this.createProgram(u.context)), u.programCache[this.type] }, applyToWebGL: function (u) { var n = u.context, l = this.retrieveShader(u); u.pass === 0 && u.originalTexture ? n.bindTexture(n.TEXTURE_2D, u.originalTexture) : n.bindTexture(n.TEXTURE_2D, u.sourceTexture), n.useProgram(l.program), this.sendAttributeData(n, l.attributeLocations, u.aPosition), n.uniform1f(l.uniformLocations.uStepW, 1 / u.sourceWidth), n.uniform1f(l.uniformLocations.uStepH, 1 / u.sourceHeight), this.sendUniformData(n, l.uniformLocations), n.viewport(0, 0, u.destinationWidth, u.destinationHeight), n.drawArrays(n.TRIANGLE_STRIP, 0, 4) }, bindAdditionalTexture: function (u, n, l) { u.activeTexture(l), u.bindTexture(u.TEXTURE_2D, n), u.activeTexture(u.TEXTURE0) }, unbindAdditionalTexture: function (u, n) { u.activeTexture(n), u.bindTexture(u.TEXTURE_2D, null), u.activeTexture(u.TEXTURE0) }, getMainParameter: function () { return this[this.mainParameter] }, setMainParameter: function (u) { this[this.mainParameter] = u }, sendUniformData: function () { }, createHelpLayer: function (u) { if (!u.helpLayer) { var n = document.createElement("canvas"); n.width = u.sourceWidth, n.height = u.sourceHeight, u.helpLayer = n } }, toObject: function () { var u = { type: this.type }, n = this.mainParameter; return n && (u[n] = this[n]), u }, toJSON: function () { return this.toObject() }
}), t.Image.filters.BaseFilter.fromObject = function (u, n) { var l = new t.Image.filters[u.type](u); return n && n(l), l }, function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.ColorMatrix = h(l.BaseFilter, {
        type: "ColorMatrix", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
uniform mat4 uColorMatrix;
uniform vec4 uConstants;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color *= uColorMatrix;
color += uConstants;
gl_FragColor = color;
}`, matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], mainParameter: "matrix", colorsOnly: !0, initialize: function (i) { this.callSuper("initialize", i), this.matrix = this.matrix.slice(0) }, applyTo2d: function (i) { var r = i.imageData, e = r.data, o = e.length, c = this.matrix, s, f, d, p, m, y = this.colorsOnly; for (m = 0; m < o; m += 4)s = e[m], f = e[m + 1], d = e[m + 2], y ? (e[m] = s * c[0] + f * c[1] + d * c[2] + c[4] * 255, e[m + 1] = s * c[5] + f * c[6] + d * c[7] + c[9] * 255, e[m + 2] = s * c[10] + f * c[11] + d * c[12] + c[14] * 255) : (p = e[m + 3], e[m] = s * c[0] + f * c[1] + d * c[2] + p * c[3] + c[4] * 255, e[m + 1] = s * c[5] + f * c[6] + d * c[7] + p * c[8] + c[9] * 255, e[m + 2] = s * c[10] + f * c[11] + d * c[12] + p * c[13] + c[14] * 255, e[m + 3] = s * c[15] + f * c[16] + d * c[17] + p * c[18] + c[19] * 255) }, getUniformLocations: function (i, r) { return { uColorMatrix: i.getUniformLocation(r, "uColorMatrix"), uConstants: i.getUniformLocation(r, "uConstants") } }, sendUniformData: function (i, r) { var e = this.matrix, o = [e[0], e[1], e[2], e[3], e[5], e[6], e[7], e[8], e[10], e[11], e[12], e[13], e[15], e[16], e[17], e[18]], c = [e[4], e[9], e[14], e[19]]; i.uniformMatrix4fv(r.uColorMatrix, !1, o), i.uniform4fv(r.uConstants, c) }
    }), n.Image.filters.ColorMatrix.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Brightness = h(l.BaseFilter, {
        type: "Brightness", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBrightness;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += uBrightness;
gl_FragColor = color;
}`, brightness: 0, mainParameter: "brightness", applyTo2d: function (i) { if (this.brightness !== 0) { var r = i.imageData, e = r.data, o, c = e.length, s = Math.round(this.brightness * 255); for (o = 0; o < c; o += 4)e[o] = e[o] + s, e[o + 1] = e[o + 1] + s, e[o + 2] = e[o + 2] + s } }, getUniformLocations: function (i, r) { return { uBrightness: i.getUniformLocation(r, "uBrightness") } }, sendUniformData: function (i, r) { i.uniform1f(r.uBrightness, this.brightness) }
    }), n.Image.filters.Brightness.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.object.extend, h = n.Image.filters, i = n.util.createClass; h.Convolute = i(h.BaseFilter, {
        type: "Convolute", opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0], fragmentSource: {
            Convolute_3_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_3_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`, Convolute_5_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_5_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`, Convolute_7_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_7_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`, Convolute_9_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
}
}
gl_FragColor = color;
}`, Convolute_9_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`}, retrieveShader: function (r) { var e = Math.sqrt(this.matrix.length), o = this.type + "_" + e + "_" + (this.opaque ? 1 : 0), c = this.fragmentSource[o]; return r.programCache.hasOwnProperty(o) || (r.programCache[o] = this.createProgram(r.context, c)), r.programCache[o] }, applyTo2d: function (r) { var e = r.imageData, o = e.data, c = this.matrix, s = Math.round(Math.sqrt(c.length)), f = Math.floor(s / 2), d = e.width, p = e.height, m = r.ctx.createImageData(d, p), y = m.data, x = this.opaque ? 1 : 0, P, D, Y, V, J, Q, rt, tt, it, ot, st, nt, w; for (st = 0; st < p; st++)for (ot = 0; ot < d; ot++) { for (J = (st * d + ot) * 4, P = 0, D = 0, Y = 0, V = 0, w = 0; w < s; w++)for (nt = 0; nt < s; nt++)rt = st + w - f, Q = ot + nt - f, !(rt < 0 || rt >= p || Q < 0 || Q >= d) && (tt = (rt * d + Q) * 4, it = c[w * s + nt], P += o[tt] * it, D += o[tt + 1] * it, Y += o[tt + 2] * it, x || (V += o[tt + 3] * it)); y[J] = P, y[J + 1] = D, y[J + 2] = Y, x ? y[J + 3] = o[J + 3] : y[J + 3] = V } r.imageData = m }, getUniformLocations: function (r, e) { return { uMatrix: r.getUniformLocation(e, "uMatrix"), uOpaque: r.getUniformLocation(e, "uOpaque"), uHalfSize: r.getUniformLocation(e, "uHalfSize"), uSize: r.getUniformLocation(e, "uSize") } }, sendUniformData: function (r, e) { r.uniform1fv(e.uMatrix, this.matrix) }, toObject: function () { return l(this.callSuper("toObject"), { opaque: this.opaque, matrix: this.matrix }) }
    }), n.Image.filters.Convolute.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Grayscale = h(l.BaseFilter, {
        type: "Grayscale", fragmentSource: {
            average: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float average = (color.r + color.b + color.g) / 3.0;
gl_FragColor = vec4(average, average, average, color.a);
}`, lightness: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
gl_FragColor = vec4(average, average, average, col.a);
}`, luminosity: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
gl_FragColor = vec4(average, average, average, col.a);
}`}, mode: "average", mainParameter: "mode", applyTo2d: function (i) { var r = i.imageData, e = r.data, o, c = e.length, s, f = this.mode; for (o = 0; o < c; o += 4)f === "average" ? s = (e[o] + e[o + 1] + e[o + 2]) / 3 : f === "lightness" ? s = (Math.min(e[o], e[o + 1], e[o + 2]) + Math.max(e[o], e[o + 1], e[o + 2])) / 2 : f === "luminosity" && (s = .21 * e[o] + .72 * e[o + 1] + .07 * e[o + 2]), e[o] = s, e[o + 1] = s, e[o + 2] = s }, retrieveShader: function (i) { var r = this.type + "_" + this.mode; if (!i.programCache.hasOwnProperty(r)) { var e = this.fragmentSource[this.mode]; i.programCache[r] = this.createProgram(i.context, e) } return i.programCache[r] }, getUniformLocations: function (i, r) { return { uMode: i.getUniformLocation(r, "uMode") } }, sendUniformData: function (i, r) { var e = 1; i.uniform1i(r.uMode, e) }, isNeutralState: function () { return !1 }
    }), n.Image.filters.Grayscale.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Invert = h(l.BaseFilter, {
        type: "Invert", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform int uInvert;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
if (uInvert == 1) {
gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
} else {
gl_FragColor = color;
}
}`, invert: !0, mainParameter: "invert", applyTo2d: function (i) { var r = i.imageData, e = r.data, o, c = e.length; for (o = 0; o < c; o += 4)e[o] = 255 - e[o], e[o + 1] = 255 - e[o + 1], e[o + 2] = 255 - e[o + 2] }, isNeutralState: function () { return !this.invert }, getUniformLocations: function (i, r) { return { uInvert: i.getUniformLocation(r, "uInvert") } }, sendUniformData: function (i, r) { i.uniform1i(r.uInvert, this.invert) }
    }), n.Image.filters.Invert.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.object.extend, h = n.Image.filters, i = n.util.createClass; h.Noise = i(h.BaseFilter, {
        type: "Noise", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uStepH;
uniform float uNoise;
uniform float uSeed;
varying vec2 vTexCoord;
float rand(vec2 co, float seed, float vScale) {
return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
}
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
gl_FragColor = color;
}`, mainParameter: "noise", noise: 0, applyTo2d: function (r) { if (this.noise !== 0) { var e = r.imageData, o = e.data, c, s = o.length, f = this.noise, d; for (c = 0, s = o.length; c < s; c += 4)d = (.5 - Math.random()) * f, o[c] += d, o[c + 1] += d, o[c + 2] += d } }, getUniformLocations: function (r, e) { return { uNoise: r.getUniformLocation(e, "uNoise"), uSeed: r.getUniformLocation(e, "uSeed") } }, sendUniformData: function (r, e) { r.uniform1f(e.uNoise, this.noise / 255), r.uniform1f(e.uSeed, Math.random()) }, toObject: function () { return l(this.callSuper("toObject"), { noise: this.noise }) }
    }), n.Image.filters.Noise.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Pixelate = h(l.BaseFilter, {
        type: "Pixelate", blocksize: 4, mainParameter: "blocksize", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBlocksize;
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
float blockW = uBlocksize * uStepW;
float blockH = uBlocksize * uStepW;
int posX = int(vTexCoord.x / blockW);
int posY = int(vTexCoord.y / blockH);
float fposX = float(posX);
float fposY = float(posY);
vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
vec4 color = texture2D(uTexture, squareCoords);
gl_FragColor = color;
}`, applyTo2d: function (i) { var r = i.imageData, e = r.data, o = r.height, c = r.width, s, f, d, p, m, y, x, P, D, Y, V; for (f = 0; f < o; f += this.blocksize)for (d = 0; d < c; d += this.blocksize)for (s = f * 4 * c + d * 4, p = e[s], m = e[s + 1], y = e[s + 2], x = e[s + 3], Y = Math.min(f + this.blocksize, o), V = Math.min(d + this.blocksize, c), P = f; P < Y; P++)for (D = d; D < V; D++)s = P * 4 * c + D * 4, e[s] = p, e[s + 1] = m, e[s + 2] = y, e[s + 3] = x }, isNeutralState: function () { return this.blocksize === 1 }, getUniformLocations: function (i, r) { return { uBlocksize: i.getUniformLocation(r, "uBlocksize"), uStepW: i.getUniformLocation(r, "uStepW"), uStepH: i.getUniformLocation(r, "uStepH") } }, sendUniformData: function (i, r) { i.uniform1f(r.uBlocksize, this.blocksize) }
    }), n.Image.filters.Pixelate.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.object.extend, h = n.Image.filters, i = n.util.createClass; h.RemoveColor = i(h.BaseFilter, {
        type: "RemoveColor", color: "#FFFFFF", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
gl_FragColor.a = 0.0;
}
}`, distance: .02, useAlpha: !1, applyTo2d: function (r) { var e = r.imageData, o = e.data, c, s = this.distance * 255, f, d, p, m = new n.Color(this.color).getSource(), y = [m[0] - s, m[1] - s, m[2] - s], x = [m[0] + s, m[1] + s, m[2] + s]; for (c = 0; c < o.length; c += 4)f = o[c], d = o[c + 1], p = o[c + 2], f > y[0] && d > y[1] && p > y[2] && f < x[0] && d < x[1] && p < x[2] && (o[c + 3] = 0) }, getUniformLocations: function (r, e) { return { uLow: r.getUniformLocation(e, "uLow"), uHigh: r.getUniformLocation(e, "uHigh") } }, sendUniformData: function (r, e) { var o = new n.Color(this.color).getSource(), c = parseFloat(this.distance), s = [0 + o[0] / 255 - c, 0 + o[1] / 255 - c, 0 + o[2] / 255 - c, 1], f = [o[0] / 255 + c, o[1] / 255 + c, o[2] / 255 + c, 1]; r.uniform4fv(e.uLow, s), r.uniform4fv(e.uHigh, f) }, toObject: function () { return l(this.callSuper("toObject"), { color: this.color, distance: this.distance }) }
    }), n.Image.filters.RemoveColor.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) { var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass, i = { Brownie: [.5997, .34553, -.27082, 0, .186, -.0377, .86095, .15059, 0, -.1449, .24113, -.07441, .44972, 0, -.02965, 0, 0, 0, 1, 0], Vintage: [.62793, .32021, -.03965, 0, .03784, .02578, .64411, .03259, 0, .02926, .0466, -.08512, .52416, 0, .02023, 0, 0, 0, 1, 0], Kodachrome: [1.12855, -.39673, -.03992, 0, .24991, -.16404, 1.08352, -.05498, 0, .09698, -.16786, -.56034, 1.60148, 0, .13972, 0, 0, 0, 1, 0], Technicolor: [1.91252, -.85453, -.09155, 0, .04624, -.30878, 1.76589, -.10601, 0, -.27589, -.2311, -.75018, 1.84759, 0, .12137, 0, 0, 0, 1, 0], Polaroid: [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], Sepia: [.393, .769, .189, 0, 0, .349, .686, .168, 0, 0, .272, .534, .131, 0, 0, 0, 0, 0, 1, 0], BlackWhite: [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0] }; for (var r in i) l[r] = h(l.ColorMatrix, { type: r, matrix: i[r], mainParameter: !1, colorsOnly: !0 }), n.Image.filters[r].fromObject = n.Image.filters.BaseFilter.fromObject }(a), function (u) {
    var n = u.fabric, l = n.Image.filters, h = n.util.createClass; l.BlendColor = h(l.BaseFilter, {
        type: "BlendColor", color: "#F95C63", mode: "multiply", alpha: 1, fragmentSource: {
            multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, diff: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `if (uColor.r < 0.5) {
gl_FragColor.r *= 2.0 * uColor.r;
} else {
gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
}
if (uColor.g < 0.5) {
gl_FragColor.g *= 2.0 * uColor.g;
} else {
gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
}
if (uColor.b < 0.5) {
gl_FragColor.b *= 2.0 * uColor.b;
} else {
gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
}
`, tint: `gl_FragColor.rgb *= (1.0 - uColor.a);
gl_FragColor.rgb += uColor.rgb;
`}, buildSource: function (i) {
            return `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uColor;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
gl_FragColor = color;
if (color.a > 0.0) {
`+ this.fragmentSource[i] + `}
}`}, retrieveShader: function (i) { var r = this.type + "_" + this.mode, e; return i.programCache.hasOwnProperty(r) || (e = this.buildSource(this.mode), i.programCache[r] = this.createProgram(i.context, e)), i.programCache[r] }, applyTo2d: function (i) { var r = i.imageData, e = r.data, o = e.length, c, s, f, d, p, m, y, x = 1 - this.alpha; y = new n.Color(this.color).getSource(), c = y[0] * this.alpha, s = y[1] * this.alpha, f = y[2] * this.alpha; for (var P = 0; P < o; P += 4)switch (d = e[P], p = e[P + 1], m = e[P + 2], this.mode) { case "multiply": e[P] = d * c / 255, e[P + 1] = p * s / 255, e[P + 2] = m * f / 255; break; case "screen": e[P] = 255 - (255 - d) * (255 - c) / 255, e[P + 1] = 255 - (255 - p) * (255 - s) / 255, e[P + 2] = 255 - (255 - m) * (255 - f) / 255; break; case "add": e[P] = d + c, e[P + 1] = p + s, e[P + 2] = m + f; break; case "diff": case "difference": e[P] = Math.abs(d - c), e[P + 1] = Math.abs(p - s), e[P + 2] = Math.abs(m - f); break; case "subtract": e[P] = d - c, e[P + 1] = p - s, e[P + 2] = m - f; break; case "darken": e[P] = Math.min(d, c), e[P + 1] = Math.min(p, s), e[P + 2] = Math.min(m, f); break; case "lighten": e[P] = Math.max(d, c), e[P + 1] = Math.max(p, s), e[P + 2] = Math.max(m, f); break; case "overlay": e[P] = c < 128 ? 2 * d * c / 255 : 255 - 2 * (255 - d) * (255 - c) / 255, e[P + 1] = s < 128 ? 2 * p * s / 255 : 255 - 2 * (255 - p) * (255 - s) / 255, e[P + 2] = f < 128 ? 2 * m * f / 255 : 255 - 2 * (255 - m) * (255 - f) / 255; break; case "exclusion": e[P] = c + d - 2 * c * d / 255, e[P + 1] = s + p - 2 * s * p / 255, e[P + 2] = f + m - 2 * f * m / 255; break; case "tint": e[P] = c + d * x, e[P + 1] = s + p * x, e[P + 2] = f + m * x } }, getUniformLocations: function (i, r) { return { uColor: i.getUniformLocation(r, "uColor") } }, sendUniformData: function (i, r) { var e = new n.Color(this.color).getSource(); e[0] = this.alpha * e[0] / 255, e[1] = this.alpha * e[1] / 255, e[2] = this.alpha * e[2] / 255, e[3] = this.alpha, i.uniform4fv(r.uColor, e) }, toObject: function () { return { type: this.type, color: this.color, mode: this.mode, alpha: this.alpha } }
    }), n.Image.filters.BlendColor.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric, l = n.Image.filters, h = n.util.createClass; l.BlendImage = h(l.BaseFilter, {
        type: "BlendImage", image: null, mode: "multiply", alpha: 1, vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
uniform mat3 uTransformMatrix;
void main() {
vTexCoord = aPosition;
vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`, fragmentSource: {
            multiply: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.rgba *= color2.rgba;
gl_FragColor = color;
}`, mask: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.a = color2.a;
gl_FragColor = color;
}`}, retrieveShader: function (i) { var r = this.type + "_" + this.mode, e = this.fragmentSource[this.mode]; return i.programCache.hasOwnProperty(r) || (i.programCache[r] = this.createProgram(i.context, e)), i.programCache[r] }, applyToWebGL: function (i) { var r = i.context, e = this.createTexture(i.filterBackend, this.image); this.bindAdditionalTexture(r, e, r.TEXTURE1), this.callSuper("applyToWebGL", i), this.unbindAdditionalTexture(r, r.TEXTURE1) }, createTexture: function (i, r) { return i.getCachedTexture(r.cacheKey, r._element) }, calculateMatrix: function () { var i = this.image, r = i._element.width, e = i._element.height; return [1 / i.scaleX, 0, 0, 0, 1 / i.scaleY, 0, -i.left / r, -i.top / e, 1] }, applyTo2d: function (i) { var r = i.imageData, e = i.filterBackend.resources, o = r.data, c = o.length, s = r.width, f = r.height, d, p, m, y, x, P, D, Y, V, J, Q = this.image, rt; e.blendImage || (e.blendImage = n.util.createCanvasElement()), V = e.blendImage, J = V.getContext("2d"), V.width !== s || V.height !== f ? (V.width = s, V.height = f) : J.clearRect(0, 0, s, f), J.setTransform(Q.scaleX, 0, 0, Q.scaleY, Q.left, Q.top), J.drawImage(Q._element, 0, 0, s, f), rt = J.getImageData(0, 0, s, f).data; for (var tt = 0; tt < c; tt += 4)switch (x = o[tt], P = o[tt + 1], D = o[tt + 2], Y = o[tt + 3], d = rt[tt], p = rt[tt + 1], m = rt[tt + 2], y = rt[tt + 3], this.mode) { case "multiply": o[tt] = x * d / 255, o[tt + 1] = P * p / 255, o[tt + 2] = D * m / 255, o[tt + 3] = Y * y / 255; break; case "mask": o[tt + 3] = y; break } }, getUniformLocations: function (i, r) { return { uTransformMatrix: i.getUniformLocation(r, "uTransformMatrix"), uImage: i.getUniformLocation(r, "uImage") } }, sendUniformData: function (i, r) { var e = this.calculateMatrix(); i.uniform1i(r.uImage, 1), i.uniformMatrix3fv(r.uTransformMatrix, !1, e) }, toObject: function () { return { type: this.type, image: this.image && this.image.toObject(), mode: this.mode, alpha: this.alpha } }
    }), n.Image.filters.BlendImage.fromObject = function (i, r) { n.Image.fromObject(i.image, function (e) { var o = n.util.object.clone(i); o.image = e, r(new n.Image.filters.BlendImage(o)) }) }
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = Math.pow, h = Math.floor, i = Math.sqrt, r = Math.abs, e = Math.round, o = Math.sin, c = Math.ceil, s = n.Image.filters, f = n.util.createClass; s.Resize = f(s.BaseFilter, {
        type: "Resize", resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3, getUniformLocations: function (d, p) { return { uDelta: d.getUniformLocation(p, "uDelta"), uTaps: d.getUniformLocation(p, "uTaps") } }, sendUniformData: function (d, p) { d.uniform2fv(p.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), d.uniform1fv(p.uTaps, this.taps) }, retrieveShader: function (d) { var p = this.getFilterWindow(), m = this.type + "_" + p; if (!d.programCache.hasOwnProperty(m)) { var y = this.generateShader(p); d.programCache[m] = this.createProgram(d.context, y) } return d.programCache[m] }, getFilterWindow: function () { var d = this.tempScale; return Math.ceil(this.lanczosLobes / d) }, getTaps: function () { for (var d = this.lanczosCreate(this.lanczosLobes), p = this.tempScale, m = this.getFilterWindow(), y = new Array(m), x = 1; x <= m; x++)y[x - 1] = d(x * p); return y }, generateShader: function (y) {
            for (var p = new Array(y), m = this.fragmentSourceTOP, y, x = 1; x <= y; x++)p[x - 1] = x + ".0 * uDelta"; return m += "uniform float uTaps[" + y + `];
`, m += `void main() {
`, m += `  vec4 color = texture2D(uTexture, vTexCoord);
`, m += `  float sum = 1.0;
`, p.forEach(function (P, D) {
                m += "  color += texture2D(uTexture, vTexCoord + " + P + ") * uTaps[" + D + `];
`, m += "  color += texture2D(uTexture, vTexCoord - " + P + ") * uTaps[" + D + `];
`, m += "  sum += 2.0 * uTaps[" + D + `];
`}), m += `  gl_FragColor = color / sum;
`, m += "}", m
        }, fragmentSourceTOP: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
`, applyTo: function (d) { d.webgl ? (d.passes++, this.width = d.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = d.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), d.destinationWidth = this.dW, this._setupFrameBuffer(d), this.applyToWebGL(d), this._swapTextures(d), d.sourceWidth = d.destinationWidth, this.height = d.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), d.destinationHeight = this.dH, this._setupFrameBuffer(d), this.applyToWebGL(d), this._swapTextures(d), d.sourceHeight = d.destinationHeight) : this.applyTo2d(d) }, isNeutralState: function () { return this.scaleX === 1 && this.scaleY === 1 }, lanczosCreate: function (d) { return function (p) { if (p >= d || p <= -d) return 0; if (p < 11920929e-14 && p > -11920929e-14) return 1; p *= Math.PI; var m = p / d; return o(p) / p * o(m) / m } }, applyTo2d: function (d) { var p = d.imageData, m = this.scaleX, y = this.scaleY; this.rcpScaleX = 1 / m, this.rcpScaleY = 1 / y; var x = p.width, P = p.height, D = e(x * m), Y = e(P * y), V; this.resizeType === "sliceHack" ? V = this.sliceByTwo(d, x, P, D, Y) : this.resizeType === "hermite" ? V = this.hermiteFastResize(d, x, P, D, Y) : this.resizeType === "bilinear" ? V = this.bilinearFiltering(d, x, P, D, Y) : this.resizeType === "lanczos" && (V = this.lanczosResize(d, x, P, D, Y)), d.imageData = V }, sliceByTwo: function (d, p, m, y, x) { var P = d.imageData, D = .5, Y = !1, V = !1, J = p * D, Q = m * D, rt = n.filterBackend.resources, tt, it, ot = 0, st = 0, nt = p, w = 0; for (rt.sliceByTwo || (rt.sliceByTwo = document.createElement("canvas")), tt = rt.sliceByTwo, (tt.width < p * 1.5 || tt.height < m) && (tt.width = p * 1.5, tt.height = m), it = tt.getContext("2d"), it.clearRect(0, 0, p * 1.5, m), it.putImageData(P, 0, 0), y = h(y), x = h(x); !Y || !V;)p = J, m = Q, y < h(J * D) ? J = h(J * D) : (J = y, Y = !0), x < h(Q * D) ? Q = h(Q * D) : (Q = x, V = !0), it.drawImage(tt, ot, st, p, m, nt, w, J, Q), ot = nt, st = w, w += Q; return it.getImageData(ot, st, y, x) }, lanczosResize: function (d, p, m, y, x) { function P(k) { var A, U, M, T, R, X, G, N, $, Z, O; for (w.x = (k + .5) * Q, F.x = h(w.x), A = 0; A < x; A++) { for (w.y = (A + .5) * rt, F.y = h(w.y), R = 0, X = 0, G = 0, N = 0, $ = 0, U = F.x - ot; U <= F.x + ot; U++)if (!(U < 0 || U >= p)) { Z = h(1e3 * r(U - w.x)), nt[Z] || (nt[Z] = {}); for (var S = F.y - st; S <= F.y + st; S++)S < 0 || S >= m || (O = h(1e3 * r(S - w.y)), nt[Z][O] || (nt[Z][O] = J(i(l(Z * tt, 2) + l(O * it, 2)) / 1e3)), M = nt[Z][O], M > 0 && (T = (S * p + U) * 4, R += M, X += M * D[T], G += M * D[T + 1], N += M * D[T + 2], $ += M * D[T + 3])) } T = (A * y + k) * 4, V[T] = X / R, V[T + 1] = G / R, V[T + 2] = N / R, V[T + 3] = $ / R } return ++k < y ? P(k) : Y } var D = d.imageData.data, Y = d.ctx.createImageData(y, x), V = Y.data, J = this.lanczosCreate(this.lanczosLobes), Q = this.rcpScaleX, rt = this.rcpScaleY, tt = 2 / this.rcpScaleX, it = 2 / this.rcpScaleY, ot = c(Q * this.lanczosLobes / 2), st = c(rt * this.lanczosLobes / 2), nt = {}, w = {}, F = {}; return P(0) }, bilinearFiltering: function (d, p, m, y, x) { var P, D, Y, V, J, Q, rt, tt, it, ot, st, nt, w = 0, F, k = this.rcpScaleX, A = this.rcpScaleY, U = 4 * (p - 1), M = d.imageData, T = M.data, R = d.ctx.createImageData(y, x), X = R.data; for (rt = 0; rt < x; rt++)for (tt = 0; tt < y; tt++)for (J = h(k * tt), Q = h(A * rt), it = k * tt - J, ot = A * rt - Q, F = 4 * (Q * p + J), st = 0; st < 4; st++)P = T[F + st], D = T[F + 4 + st], Y = T[F + U + st], V = T[F + U + 4 + st], nt = P * (1 - it) * (1 - ot) + D * it * (1 - ot) + Y * ot * (1 - it) + V * it * ot, X[w++] = nt; return R }, hermiteFastResize: function (d, p, m, y, x) { for (var P = this.rcpScaleX, D = this.rcpScaleY, Y = c(P / 2), V = c(D / 2), J = d.imageData, Q = J.data, rt = d.ctx.createImageData(y, x), tt = rt.data, it = 0; it < x; it++)for (var ot = 0; ot < y; ot++) { for (var st = (ot + it * y) * 4, nt = 0, w = 0, F = 0, k = 0, A = 0, U = 0, M = 0, T = (it + .5) * D, R = h(it * D); R < (it + 1) * D; R++)for (var X = r(T - (R + .5)) / V, G = (ot + .5) * P, N = X * X, $ = h(ot * P); $ < (ot + 1) * P; $++) { var Z = r(G - ($ + .5)) / Y, O = i(N + Z * Z); O > 1 && O < -1 || (nt = 2 * O * O * O - 3 * O * O + 1, nt > 0 && (Z = 4 * ($ + R * p), M += nt * Q[Z + 3], F += nt, Q[Z + 3] < 255 && (nt = nt * Q[Z + 3] / 250), k += nt * Q[Z], A += nt * Q[Z + 1], U += nt * Q[Z + 2], w += nt)) } tt[st] = k / w, tt[st + 1] = A / w, tt[st + 2] = U / w, tt[st + 3] = M / F } return rt }, toObject: function () { return { type: this.type, scaleX: this.scaleX, scaleY: this.scaleY, resizeType: this.resizeType, lanczosLobes: this.lanczosLobes } }
    }), n.Image.filters.Resize.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Contrast = h(l.BaseFilter, {
        type: "Contrast", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uContrast;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
gl_FragColor = color;
}`, contrast: 0, mainParameter: "contrast", applyTo2d: function (i) { if (this.contrast !== 0) { var r = i.imageData, e, c, o = r.data, c = o.length, s = Math.floor(this.contrast * 255), f = 259 * (s + 255) / (255 * (259 - s)); for (e = 0; e < c; e += 4)o[e] = f * (o[e] - 128) + 128, o[e + 1] = f * (o[e + 1] - 128) + 128, o[e + 2] = f * (o[e + 2] - 128) + 128 } }, getUniformLocations: function (i, r) { return { uContrast: i.getUniformLocation(r, "uContrast") } }, sendUniformData: function (i, r) { i.uniform1f(r.uContrast, this.contrast) }
    }), n.Image.filters.Contrast.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Saturation = h(l.BaseFilter, {
        type: "Saturation", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uSaturation;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float rgMax = max(color.r, color.g);
float rgbMax = max(rgMax, color.b);
color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
gl_FragColor = color;
}`, saturation: 0, mainParameter: "saturation", applyTo2d: function (i) { if (this.saturation !== 0) { var r = i.imageData, e = r.data, o = e.length, c = -this.saturation, s, f; for (s = 0; s < o; s += 4)f = Math.max(e[s], e[s + 1], e[s + 2]), e[s] += f !== e[s] ? (f - e[s]) * c : 0, e[s + 1] += f !== e[s + 1] ? (f - e[s + 1]) * c : 0, e[s + 2] += f !== e[s + 2] ? (f - e[s + 2]) * c : 0 } }, getUniformLocations: function (i, r) { return { uSaturation: i.getUniformLocation(r, "uSaturation") } }, sendUniformData: function (i, r) { i.uniform1f(r.uSaturation, -this.saturation) }
    }), n.Image.filters.Saturation.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Vibrance = h(l.BaseFilter, {
        type: "Vibrance", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uVibrance;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float max = max(color.r, max(color.g, color.b));
float avg = (color.r + color.g + color.b) / 3.0;
float amt = (abs(max - avg) * 2.0) * uVibrance;
color.r += max != color.r ? (max - color.r) * amt : 0.00;
color.g += max != color.g ? (max - color.g) * amt : 0.00;
color.b += max != color.b ? (max - color.b) * amt : 0.00;
gl_FragColor = color;
}`, vibrance: 0, mainParameter: "vibrance", applyTo2d: function (i) { if (this.vibrance !== 0) { var r = i.imageData, e = r.data, o = e.length, c = -this.vibrance, s, f, d, p; for (s = 0; s < o; s += 4)f = Math.max(e[s], e[s + 1], e[s + 2]), d = (e[s] + e[s + 1] + e[s + 2]) / 3, p = Math.abs(f - d) * 2 / 255 * c, e[s] += f !== e[s] ? (f - e[s]) * p : 0, e[s + 1] += f !== e[s + 1] ? (f - e[s + 1]) * p : 0, e[s + 2] += f !== e[s + 2] ? (f - e[s + 2]) * p : 0 } }, getUniformLocations: function (i, r) { return { uVibrance: i.getUniformLocation(r, "uVibrance") } }, sendUniformData: function (i, r) { i.uniform1f(r.uVibrance, -this.vibrance) }
    }), n.Image.filters.Vibrance.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Blur = h(l.BaseFilter, {
        type: "Blur", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
const float nSamples = 15.0;
vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
float random(vec3 scale) {
return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
}
void main() {
vec4 color = vec4(0.0);
float total = 0.0;
float offset = random(v3offset);
for (float t = -nSamples; t <= nSamples; t++) {
float percent = (t + offset - 0.5) / nSamples;
float weight = 1.0 - abs(percent);
color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;
total += weight;
}
gl_FragColor = color / total;
}`, blur: 0, mainParameter: "blur", applyTo: function (i) { i.webgl ? (this.aspectRatio = i.sourceWidth / i.sourceHeight, i.passes++, this._setupFrameBuffer(i), this.horizontal = !0, this.applyToWebGL(i), this._swapTextures(i), this._setupFrameBuffer(i), this.horizontal = !1, this.applyToWebGL(i), this._swapTextures(i)) : this.applyTo2d(i) }, applyTo2d: function (i) { i.imageData = this.simpleBlur(i) }, simpleBlur: function (i) { var r = i.filterBackend.resources, e, o, c = i.imageData.width, s = i.imageData.height; r.blurLayer1 || (r.blurLayer1 = n.util.createCanvasElement(), r.blurLayer2 = n.util.createCanvasElement()), e = r.blurLayer1, o = r.blurLayer2, (e.width !== c || e.height !== s) && (o.width = e.width = c, o.height = e.height = s); var f = e.getContext("2d"), d = o.getContext("2d"), p = 15, m, y, x, P, D = this.blur * .06 * .5; for (f.putImageData(i.imageData, 0, 0), d.clearRect(0, 0, c, s), P = -p; P <= p; P++)m = (Math.random() - .5) / 4, y = P / p, x = D * y * c + m, d.globalAlpha = 1 - Math.abs(y), d.drawImage(e, x, m), f.drawImage(o, 0, 0), d.globalAlpha = 1, d.clearRect(0, 0, o.width, o.height); for (P = -p; P <= p; P++)m = (Math.random() - .5) / 4, y = P / p, x = D * y * s + m, d.globalAlpha = 1 - Math.abs(y), d.drawImage(e, m, x), f.drawImage(o, 0, 0), d.globalAlpha = 1, d.clearRect(0, 0, o.width, o.height); i.ctx.drawImage(e, 0, 0); var Y = i.ctx.getImageData(0, 0, e.width, e.height); return f.globalAlpha = 1, f.clearRect(0, 0, e.width, e.height), Y }, getUniformLocations: function (i, r) { return { delta: i.getUniformLocation(r, "uDelta") } }, sendUniformData: function (i, r) { var e = this.chooseRightDelta(); i.uniform2fv(r.delta, e) }, chooseRightDelta: function () { var i = 1, r = [0, 0], e; return this.horizontal ? this.aspectRatio > 1 && (i = 1 / this.aspectRatio) : this.aspectRatio < 1 && (i = this.aspectRatio), e = i * this.blur * .12, this.horizontal ? r[0] = e : r[1] = e, r }
    }), l.Blur.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Gamma = h(l.BaseFilter, {
        type: "Gamma", fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec3 uGamma;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec3 correction = (1.0 / uGamma);
color.r = pow(color.r, correction.r);
color.g = pow(color.g, correction.g);
color.b = pow(color.b, correction.b);
gl_FragColor = color;
gl_FragColor.rgb *= color.a;
}`, gamma: [1, 1, 1], mainParameter: "gamma", initialize: function (i) { this.gamma = [1, 1, 1], l.BaseFilter.prototype.initialize.call(this, i) }, applyTo2d: function (i) { var r = i.imageData, e = r.data, o = this.gamma, c = e.length, s = 1 / o[0], f = 1 / o[1], d = 1 / o[2], p; for (this.rVals || (this.rVals = new Uint8Array(256), this.gVals = new Uint8Array(256), this.bVals = new Uint8Array(256)), p = 0, c = 256; p < c; p++)this.rVals[p] = Math.pow(p / 255, s) * 255, this.gVals[p] = Math.pow(p / 255, f) * 255, this.bVals[p] = Math.pow(p / 255, d) * 255; for (p = 0, c = e.length; p < c; p += 4)e[p] = this.rVals[e[p]], e[p + 1] = this.gVals[e[p + 1]], e[p + 2] = this.bVals[e[p + 2]] }, getUniformLocations: function (i, r) { return { uGamma: i.getUniformLocation(r, "uGamma") } }, sendUniformData: function (i, r) { i.uniform3fv(r.uGamma, this.gamma) }
    }), n.Image.filters.Gamma.fromObject = n.Image.filters.BaseFilter.fromObject
}(a), function (u) { var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.Composed = h(l.BaseFilter, { type: "Composed", subFilters: [], initialize: function (i) { this.callSuper("initialize", i), this.subFilters = this.subFilters.slice(0) }, applyTo: function (i) { i.passes += this.subFilters.length - 1, this.subFilters.forEach(function (r) { r.applyTo(i) }) }, toObject: function () { return n.util.object.extend(this.callSuper("toObject"), { subFilters: this.subFilters.map(function (i) { return i.toObject() }) }) }, isNeutralState: function () { return !this.subFilters.some(function (i) { return !i.isNeutralState() }) } }), n.Image.filters.Composed.fromObject = function (i, r) { var e = i.subFilters || [], o = e.map(function (s) { return new n.Image.filters[s.type](s) }), c = new n.Image.filters.Composed({ subFilters: o }); return r && r(c), c } }(a), function (u) { var n = u.fabric || (u.fabric = {}), l = n.Image.filters, h = n.util.createClass; l.HueRotation = h(l.ColorMatrix, { type: "HueRotation", rotation: 0, mainParameter: "rotation", calculateMatrix: function () { var i = this.rotation * Math.PI, r = n.util.cos(i), e = n.util.sin(i), o = 1 / 3, c = Math.sqrt(o) * e, s = 1 - r; this.matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.matrix[0] = r + s / 3, this.matrix[1] = o * s - c, this.matrix[2] = o * s + c, this.matrix[5] = o * s + c, this.matrix[6] = r + o * s, this.matrix[7] = o * s - c, this.matrix[10] = o * s - c, this.matrix[11] = o * s + c, this.matrix[12] = r + o * s }, isNeutralState: function (i) { return this.calculateMatrix(), l.BaseFilter.prototype.isNeutralState.call(this, i) }, applyTo: function (i) { this.calculateMatrix(), l.BaseFilter.prototype.applyTo.call(this, i) } }), n.Image.filters.HueRotation.fromObject = n.Image.filters.BaseFilter.fromObject }(a), function (u) {
    var n = u.fabric || (u.fabric = {}), l = n.util.object.clone; if (n.Text) { n.warn("fabric.Text is already defined"); return } var h = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(" "); n.Text = n.util.createClass(n.Object, {
        _dimensionAffectingProps: ["fontSize", "fontWeight", "fontFamily", "fontStyle", "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], _reNewline: /\r?\n/, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, type: "text", fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: "left", fontStyle: "normal", lineHeight: 1.16, superscript: { size: .6, baseline: -.35 }, subscript: { size: .6, baseline: .11 }, textBackgroundColor: "", stateProperties: n.Object.prototype.stateProperties.concat(h), cacheProperties: n.Object.prototype.cacheProperties.concat(h), stroke: null, shadow: null, path: null, pathStartOffset: 0, pathSide: "left", pathAlign: "baseline", _fontSizeFraction: .222, offsets: { underline: .1, linethrough: -.315, overline: -.88 }, _fontSizeMult: 1.13, charSpacing: 0, styles: null, _measuringContext: null, deltaY: 0, direction: "ltr", _styleProperties: ["stroke", "strokeWidth", "fill", "fontFamily", "fontSize", "fontWeight", "fontStyle", "underline", "overline", "linethrough", "deltaY", "textBackgroundColor"], __charBounds: [], CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2, initialize: function (i, r) { this.styles = r ? r.styles || {} : {}, this.text = i, this.__skipDimension = !0, this.callSuper("initialize", r), this.path && this.setPathInfo(), this.__skipDimension = !1, this.initDimensions(), this.setCoords(), this.setupState({ propertySet: "_dimensionAffectingProps" }) }, setPathInfo: function () { var i = this.path; i && (i.segmentsInfo = n.util.getPathSegmentsInfo(i.path)) }, getMeasuringContext: function () { return n._measuringContext || (n._measuringContext = this.canvas && this.canvas.contextCache || n.util.createCanvasElement().getContext("2d")), n._measuringContext }, _splitText: function () { var i = this._splitTextIntoLines(this.text); return this.textLines = i.lines, this._textLines = i.graphemeLines, this._unwrappedTextLines = i._unwrappedLines, this._text = i.graphemeText, i }, initDimensions: function () { this.__skipDimension || (this._splitText(), this._clearCache(), this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.saveState({ propertySet: "_dimensionAffectingProps" })) }, enlargeSpaces: function () { for (var i, r, e, o, c, s, f, d = 0, p = this._textLines.length; d < p; d++)if (!(this.textAlign !== "justify" && (d === p - 1 || this.isEndOfWrapping(d))) && (o = 0, c = this._textLines[d], r = this.getLineWidth(d), r < this.width && (f = this.textLines[d].match(this._reSpacesAndTabs)))) { e = f.length, i = (this.width - r) / e; for (var m = 0, y = c.length; m <= y; m++)s = this.__charBounds[d][m], this._reSpaceAndTab.test(c[m]) ? (s.width += i, s.kernedWidth += i, s.left += o, o += i) : s.left += o } }, isEndOfWrapping: function (i) { return i === this._textLines.length - 1 }, missingNewlineOffset: function () { return 1 }, toString: function () { return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>' }, _getCacheCanvasDimensions: function () { var i = this.callSuper("_getCacheCanvasDimensions"), r = this.fontSize; return i.width += r * i.zoomX, i.height += r * i.zoomY, i }, _render: function (i) { var r = this.path; r && !r.isNotVisible() && r._render(i), this._setTextStyles(i), this._renderTextLinesBackground(i), this._renderTextDecoration(i, "underline"), this._renderText(i), this._renderTextDecoration(i, "overline"), this._renderTextDecoration(i, "linethrough") }, _renderText: function (i) { this.paintFirst === "stroke" ? (this._renderTextStroke(i), this._renderTextFill(i)) : (this._renderTextFill(i), this._renderTextStroke(i)) }, _setTextStyles: function (i, r, e) { if (i.textBaseline = "alphabetical", this.path) switch (this.pathAlign) { case "center": i.textBaseline = "middle"; break; case "ascender": i.textBaseline = "top"; break; case "descender": i.textBaseline = "bottom"; break }i.font = this._getFontDeclaration(r, e) }, calcTextWidth: function () { for (var i = this.getLineWidth(0), r = 1, e = this._textLines.length; r < e; r++) { var o = this.getLineWidth(r); o > i && (i = o) } return i }, _renderTextLine: function (i, r, e, o, c, s) { this._renderChars(i, r, e, o, c, s) }, _renderTextLinesBackground: function (i) { if (!(!this.textBackgroundColor && !this.styleHas("textBackgroundColor"))) { for (var r, e, o = i.fillStyle, c, s, f = this._getLeftOffset(), d = this._getTopOffset(), p = 0, m = 0, y, x, P = this.path, D, Y = 0, V = this._textLines.length; Y < V; Y++) { if (r = this.getHeightOfLine(Y), !this.textBackgroundColor && !this.styleHas("textBackgroundColor", Y)) { d += r; continue } c = this._textLines[Y], e = this._getLineLeftOffset(Y), m = 0, p = 0, s = this.getValueOfPropertyAt(Y, 0, "textBackgroundColor"); for (var J = 0, Q = c.length; J < Q; J++)y = this.__charBounds[Y][J], x = this.getValueOfPropertyAt(Y, J, "textBackgroundColor"), P ? (i.save(), i.translate(y.renderLeft, y.renderTop), i.rotate(y.angle), i.fillStyle = x, x && i.fillRect(-y.width / 2, -r / this.lineHeight * (1 - this._fontSizeFraction), y.width, r / this.lineHeight), i.restore()) : x !== s ? (D = f + e + p, this.direction === "rtl" && (D = this.width - D - m), i.fillStyle = s, s && i.fillRect(D, d, m, r / this.lineHeight), p = y.left, m = y.width, s = x) : m += y.kernedWidth; x && !P && (D = f + e + p, this.direction === "rtl" && (D = this.width - D - m), i.fillStyle = x, i.fillRect(D, d, m, r / this.lineHeight)), d += r } i.fillStyle = o, this._removeShadow(i) } }, getFontCache: function (i) { var r = i.fontFamily.toLowerCase(); n.charWidthsCache[r] || (n.charWidthsCache[r] = {}); var e = n.charWidthsCache[r], o = i.fontStyle.toLowerCase() + "_" + (i.fontWeight + "").toLowerCase(); return e[o] || (e[o] = {}), e[o] }, _measureChar: function (i, r, e, o) { var c = this.getFontCache(r), s = this._getFontDeclaration(r), f = this._getFontDeclaration(o), d = e + i, p = s === f, m, y, x, P = r.fontSize / this.CACHE_FONT_SIZE, D; if (e && c[e] !== void 0 && (x = c[e]), c[i] !== void 0 && (D = m = c[i]), p && c[d] !== void 0 && (y = c[d], D = y - x), m === void 0 || x === void 0 || y === void 0) { var Y = this.getMeasuringContext(); this._setTextStyles(Y, r, !0) } return m === void 0 && (D = m = Y.measureText(i).width, c[i] = m), x === void 0 && p && e && (x = Y.measureText(e).width, c[e] = x), p && y === void 0 && (y = Y.measureText(d).width, c[d] = y, D = y - x), { width: m * P, kernedWidth: D * P } }, getHeightOfChar: function (i, r) { return this.getValueOfPropertyAt(i, r, "fontSize") }, measureLine: function (i) { var r = this._measureLine(i); return this.charSpacing !== 0 && (r.width -= this._getWidthOfCharSpacing()), r.width < 0 && (r.width = 0), r }, _measureLine: function (i) { var r = 0, e, o, c = this._textLines[i], s, f, d = 0, p = new Array(c.length), m = 0, y, x, P = this.path, D = this.pathSide === "right"; for (this.__charBounds[i] = p, e = 0; e < c.length; e++)o = c[e], f = this._getGraphemeBox(o, i, e, s), p[e] = f, r += f.kernedWidth, s = o; if (p[e] = { left: f ? f.left + f.width : 0, width: 0, kernedWidth: 0, height: this.fontSize }, P) { switch (x = P.segmentsInfo[P.segmentsInfo.length - 1].length, y = n.util.getPointOnPath(P.path, 0, P.segmentsInfo), y.x += P.pathOffset.x, y.y += P.pathOffset.y, this.textAlign) { case "left": m = D ? x - r : 0; break; case "center": m = (x - r) / 2; break; case "right": m = D ? 0 : x - r; break }for (m += this.pathStartOffset * (D ? -1 : 1), e = D ? c.length - 1 : 0; D ? e >= 0 : e < c.length; D ? e-- : e++)f = p[e], m > x ? m %= x : m < 0 && (m += x), this._setGraphemeOnPath(m, f, y), m += f.kernedWidth } return { width: r, numOfSpaces: d } }, _setGraphemeOnPath: function (i, r, e) { var o = i + r.kernedWidth / 2, c = this.path, s = n.util.getPointOnPath(c.path, o, c.segmentsInfo); r.renderLeft = s.x - e.x, r.renderTop = s.y - e.y, r.angle = s.angle + (this.pathSide === "right" ? Math.PI : 0) }, _getGraphemeBox: function (i, r, e, o, c) { var s = this.getCompleteStyleDeclaration(r, e), f = o ? this.getCompleteStyleDeclaration(r, e - 1) : {}, d = this._measureChar(i, s, o, f), p = d.kernedWidth, m = d.width, y; this.charSpacing !== 0 && (y = this._getWidthOfCharSpacing(), m += y, p += y); var x = { width: m, left: 0, height: s.fontSize, kernedWidth: p, deltaY: s.deltaY }; if (e > 0 && !c) { var P = this.__charBounds[r][e - 1]; x.left = P.left + P.width + d.kernedWidth - d.width } return x }, getHeightOfLine: function (i) { if (this.__lineHeights[i]) return this.__lineHeights[i]; for (var r = this._textLines[i], e = this.getHeightOfChar(i, 0), o = 1, c = r.length; o < c; o++)e = Math.max(this.getHeightOfChar(i, o), e); return this.__lineHeights[i] = e * this.lineHeight * this._fontSizeMult }, calcTextHeight: function () { for (var i, r = 0, e = 0, o = this._textLines.length; e < o; e++)i = this.getHeightOfLine(e), r += e === o - 1 ? i / this.lineHeight : i; return r }, _getLeftOffset: function () { return this.direction === "ltr" ? -this.width / 2 : this.width / 2 }, _getTopOffset: function () { return -this.height / 2 }, _renderTextCommon: function (i, r) { i.save(); for (var e = 0, o = this._getLeftOffset(), c = this._getTopOffset(), s = 0, f = this._textLines.length; s < f; s++) { var d = this.getHeightOfLine(s), p = d / this.lineHeight, m = this._getLineLeftOffset(s); this._renderTextLine(r, i, this._textLines[s], o + m, c + e + p, s), e += d } i.restore() }, _renderTextFill: function (i) { !this.fill && !this.styleHas("fill") || this._renderTextCommon(i, "fillText") }, _renderTextStroke: function (i) { (!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles() || (this.shadow && !this.shadow.affectStroke && this._removeShadow(i), i.save(), this._setLineDash(i, this.strokeDashArray), i.beginPath(), this._renderTextCommon(i, "strokeText"), i.closePath(), i.restore()) }, _renderChars: function (i, r, e, o, c, s) { var f = this.getHeightOfLine(s), d = this.textAlign.indexOf("justify") !== -1, p, m, y = "", x, P = 0, D, Y = this.path, V = !d && this.charSpacing === 0 && this.isEmptyStyles(s) && !Y, J = this.direction === "ltr", Q = this.direction === "ltr" ? 1 : -1, rt, tt = r.canvas.getAttribute("dir"); if (r.save(), tt !== this.direction && (r.canvas.setAttribute("dir", J ? "ltr" : "rtl"), r.direction = J ? "ltr" : "rtl", r.textAlign = J ? "left" : "right"), c -= f * this._fontSizeFraction / this.lineHeight, V) { this._renderChar(i, r, s, 0, e.join(""), o, c, f), r.restore(); return } for (var it = 0, ot = e.length - 1; it <= ot; it++)D = it === ot || this.charSpacing || Y, y += e[it], x = this.__charBounds[s][it], P === 0 ? (o += Q * (x.kernedWidth - x.width), P += x.width) : P += x.kernedWidth, d && !D && this._reSpaceAndTab.test(e[it]) && (D = !0), D || (p = p || this.getCompleteStyleDeclaration(s, it), m = this.getCompleteStyleDeclaration(s, it + 1), D = n.util.hasStyleChanged(p, m, !1)), D && (Y ? (r.save(), r.translate(x.renderLeft, x.renderTop), r.rotate(x.angle), this._renderChar(i, r, s, it, y, -P / 2, 0, f), r.restore()) : (rt = o, this._renderChar(i, r, s, it, y, rt, c, f)), y = "", p = m, o += Q * P, P = 0); r.restore() }, _applyPatternGradientTransformText: function (i) { var r = n.util.createCanvasElement(), e, o = this.width + this.strokeWidth, c = this.height + this.strokeWidth; return r.width = o, r.height = c, e = r.getContext("2d"), e.beginPath(), e.moveTo(0, 0), e.lineTo(o, 0), e.lineTo(o, c), e.lineTo(0, c), e.closePath(), e.translate(o / 2, c / 2), e.fillStyle = i.toLive(e), this._applyPatternGradientTransform(e, i), e.fill(), e.createPattern(r, "no-repeat") }, handleFiller: function (i, r, e) { var o, c; return e.toLive ? e.gradientUnits === "percentage" || e.gradientTransform || e.patternTransform ? (o = -this.width / 2, c = -this.height / 2, i.translate(o, c), i[r] = this._applyPatternGradientTransformText(e), { offsetX: o, offsetY: c }) : (i[r] = e.toLive(i, this), this._applyPatternGradientTransform(i, e)) : (i[r] = e, { offsetX: 0, offsetY: 0 }) }, _setStrokeStyles: function (i, r) { return i.lineWidth = r.strokeWidth, i.lineCap = this.strokeLineCap, i.lineDashOffset = this.strokeDashOffset, i.lineJoin = this.strokeLineJoin, i.miterLimit = this.strokeMiterLimit, this.handleFiller(i, "strokeStyle", r.stroke) }, _setFillStyles: function (i, r) { return this.handleFiller(i, "fillStyle", r.fill) }, _renderChar: function (i, r, e, o, c, s, f) { var d = this._getStyleDeclaration(e, o), p = this.getCompleteStyleDeclaration(e, o), m = i === "fillText" && p.fill, y = i === "strokeText" && p.stroke && p.strokeWidth, x, P; !y && !m || (r.save(), m && (x = this._setFillStyles(r, p)), y && (P = this._setStrokeStyles(r, p)), r.font = this._getFontDeclaration(p), d && d.textBackgroundColor && this._removeShadow(r), d && d.deltaY && (f += d.deltaY), m && r.fillText(c, s - x.offsetX, f - x.offsetY), y && r.strokeText(c, s - P.offsetX, f - P.offsetY), r.restore()) }, setSuperscript: function (i, r) { return this._setScript(i, r, this.superscript) }, setSubscript: function (i, r) { return this._setScript(i, r, this.subscript) }, _setScript: function (i, r, e) { var o = this.get2DCursorLocation(i, !0), c = this.getValueOfPropertyAt(o.lineIndex, o.charIndex, "fontSize"), s = this.getValueOfPropertyAt(o.lineIndex, o.charIndex, "deltaY"), f = { fontSize: c * e.size, deltaY: s + c * e.baseline }; return this.setSelectionStyles(f, i, r), this }, _getLineLeftOffset: function (i) { var r = this.getLineWidth(i), e = this.width - r, o = this.textAlign, c = this.direction, f, s = 0, f = this.isEndOfWrapping(i); return o === "justify" || o === "justify-center" && !f || o === "justify-right" && !f || o === "justify-left" && !f ? 0 : (o === "center" && (s = e / 2), o === "right" && (s = e), o === "justify-center" && (s = e / 2), o === "justify-right" && (s = e), c === "rtl" && (s -= e), s) }, _clearCache: function () { this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [] }, _shouldClearDimensionCache: function () { var i = this._forceClearCache; return i || (i = this.hasStateChanged("_dimensionAffectingProps")), i && (this.dirty = !0, this._forceClearCache = !1), i }, getLineWidth: function (i) { if (this.__lineWidths[i] !== void 0) return this.__lineWidths[i]; var r = this.measureLine(i), e = r.width; return this.__lineWidths[i] = e, e }, _getWidthOfCharSpacing: function () { return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0 }, getValueOfPropertyAt: function (i, r, e) { var o = this._getStyleDeclaration(i, r); return o && typeof o[e] < "u" ? o[e] : this[e] }, _renderTextDecoration: function (i, r) { if (!(!this[r] && !this.styleHas(r))) { for (var e, o, c, s, f, d, p, m, y = this._getLeftOffset(), x = this._getTopOffset(), P, D, Y, V, J, Q, rt, tt, it = this.path, ot = this._getWidthOfCharSpacing(), st = this.offsets[r], nt = 0, w = this._textLines.length; nt < w; nt++) { if (e = this.getHeightOfLine(nt), !this[r] && !this.styleHas(r, nt)) { x += e; continue } p = this._textLines[nt], Q = e / this.lineHeight, s = this._getLineLeftOffset(nt), D = 0, Y = 0, m = this.getValueOfPropertyAt(nt, 0, r), tt = this.getValueOfPropertyAt(nt, 0, "fill"), P = x + Q * (1 - this._fontSizeFraction), o = this.getHeightOfChar(nt, 0), f = this.getValueOfPropertyAt(nt, 0, "deltaY"); for (var F = 0, k = p.length; F < k; F++)if (V = this.__charBounds[nt][F], J = this.getValueOfPropertyAt(nt, F, r), rt = this.getValueOfPropertyAt(nt, F, "fill"), c = this.getHeightOfChar(nt, F), d = this.getValueOfPropertyAt(nt, F, "deltaY"), it && J && rt) i.save(), i.fillStyle = tt, i.translate(V.renderLeft, V.renderTop), i.rotate(V.angle), i.fillRect(-V.kernedWidth / 2, st * c + d, V.kernedWidth, this.fontSize / 15), i.restore(); else if ((J !== m || rt !== tt || c !== o || d !== f) && Y > 0) { var A = y + s + D; this.direction === "rtl" && (A = this.width - A - Y), m && tt && (i.fillStyle = tt, i.fillRect(A, P + st * o + f, Y, this.fontSize / 15)), D = V.left, Y = V.width, m = J, tt = rt, o = c, f = d } else Y += V.kernedWidth; var A = y + s + D; this.direction === "rtl" && (A = this.width - A - Y), i.fillStyle = rt, J && rt && i.fillRect(A, P + st * o + f, Y - ot, this.fontSize / 15), x += e } this._removeShadow(i) } }, _getFontDeclaration: function (i, r) { var e = i || this, o = this.fontFamily, c = n.Text.genericFonts.indexOf(o.toLowerCase()) > -1, s = o === void 0 || o.indexOf("'") > -1 || o.indexOf(",") > -1 || o.indexOf('"') > -1 || c ? e.fontFamily : '"' + e.fontFamily + '"'; return [n.isLikelyNode ? e.fontWeight : e.fontStyle, n.isLikelyNode ? e.fontStyle : e.fontWeight, r ? this.CACHE_FONT_SIZE + "px" : e.fontSize + "px", s].join(" ") }, render: function (i) { this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._shouldClearDimensionCache() && this.initDimensions(), this.callSuper("render", i))) }, _splitTextIntoLines: function (i) {
            for (var r = i.split(this._reNewline), e = new Array(r.length), o = [`
`], c = [], s = 0; s < r.length; s++)e[s] = n.util.string.graphemeSplit(r[s]), c = c.concat(e[s], o); return c.pop(), { _unwrappedLines: e, lines: r, graphemeText: c, graphemeLines: e }
        }, toObject: function (i) { var r = h.concat(i), e = this.callSuper("toObject", r); return e.styles = n.util.stylesToArray(this.styles, this.text), e.path && (e.path = this.path.toObject()), e }, set: function (i, r) { this.callSuper("set", i, r); var e = !1, o = !1; if (typeof i == "object") for (var c in i) c === "path" && this.setPathInfo(), e = e || this._dimensionAffectingProps.indexOf(c) !== -1, o = o || c === "path"; else e = this._dimensionAffectingProps.indexOf(i) !== -1, o = i === "path"; return o && this.setPathInfo(), e && (this.initDimensions(), this.setCoords()), this }, complexity: function () { return 1 }
    }), n.Text.ATTRIBUTE_NAMES = n.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")), n.Text.DEFAULT_SVG_FONT_SIZE = 16, n.Text.fromElement = function (i, r, e) { if (!i) return r(null); var o = n.parseAttributes(i, n.Text.ATTRIBUTE_NAMES), c = o.textAnchor || "left"; if (e = n.util.object.extend(e ? l(e) : {}, o), e.top = e.top || 0, e.left = e.left || 0, o.textDecoration) { var s = o.textDecoration; s.indexOf("underline") !== -1 && (e.underline = !0), s.indexOf("overline") !== -1 && (e.overline = !0), s.indexOf("line-through") !== -1 && (e.linethrough = !0), delete e.textDecoration } "dx" in o && (e.left += o.dx), "dy" in o && (e.top += o.dy), "fontSize" in e || (e.fontSize = n.Text.DEFAULT_SVG_FONT_SIZE); var f = ""; "textContent" in i ? f = i.textContent : "firstChild" in i && i.firstChild !== null && "data" in i.firstChild && i.firstChild.data !== null && (f = i.firstChild.data), f = f.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "); var d = e.strokeWidth; e.strokeWidth = 0; var p = new n.Text(f, e), m = p.getScaledHeight() / p.height, y = (p.height + p.strokeWidth) * p.lineHeight - p.height, x = y * m, P = p.getScaledHeight() + x, D = 0; c === "center" && (D = p.getScaledWidth() / 2), c === "right" && (D = p.getScaledWidth()), p.set({ left: p.left - D, top: p.top - (P - p.fontSize * (.07 + p._fontSizeFraction)) / p.lineHeight, strokeWidth: typeof d < "u" ? d : 1 }), r(p) }, n.Text.fromObject = function (i, r) { var e = l(i), o = i.path; return delete e.path, n.Object._fromObject("Text", e, function (c) { c.styles = n.util.stylesFromArray(i.styles, i.text), o ? n.Object._fromObject("Path", o, function (s) { c.set("path", s), r(c) }, "path") : r(c) }, "text") }, n.Text.genericFonts = ["sans-serif", "serif", "cursive", "fantasy", "monospace"], n.util.createAccessors && n.util.createAccessors(n.Text)
}(a), function () { t.util.object.extend(t.Text.prototype, { isEmptyStyles: function (u) { if (!this.styles || typeof u < "u" && !this.styles[u]) return !0; var n = typeof u > "u" ? this.styles : { line: this.styles[u] }; for (var l in n) for (var h in n[l]) for (var i in n[l][h]) return !1; return !0 }, styleHas: function (u, n) { if (!this.styles || !u || u === "" || typeof n < "u" && !this.styles[n]) return !1; var l = typeof n > "u" ? this.styles : { 0: this.styles[n] }; for (var h in l) for (var i in l[h]) if (typeof l[h][i][u] < "u") return !0; return !1 }, cleanStyle: function (u) { if (!this.styles || !u || u === "") return !1; var n = this.styles, l = 0, h, i, r = !0, e = 0, o; for (var c in n) { h = 0; for (var s in n[c]) { var o = n[c][s], f = o.hasOwnProperty(u); l++, f ? (i ? o[u] !== i && (r = !1) : i = o[u], o[u] === this[u] && delete o[u]) : r = !1, Object.keys(o).length !== 0 ? h++ : delete n[c][s] } h === 0 && delete n[c] } for (var d = 0; d < this._textLines.length; d++)e += this._textLines[d].length; r && l === e && (this[u] = i, this.removeStyle(u)) }, removeStyle: function (u) { if (!(!this.styles || !u || u === "")) { var n = this.styles, l, h, i; for (h in n) { l = n[h]; for (i in l) delete l[i][u], Object.keys(l[i]).length === 0 && delete l[i]; Object.keys(l).length === 0 && delete n[h] } } }, _extendStyles: function (u, n) { var l = this.get2DCursorLocation(u); this._getLineStyle(l.lineIndex) || this._setLineStyle(l.lineIndex), this._getStyleDeclaration(l.lineIndex, l.charIndex) || this._setStyleDeclaration(l.lineIndex, l.charIndex, {}), t.util.object.extend(this._getStyleDeclaration(l.lineIndex, l.charIndex), n) }, get2DCursorLocation: function (u, n) { typeof u > "u" && (u = this.selectionStart); for (var l = n ? this._unwrappedTextLines : this._textLines, h = l.length, i = 0; i < h; i++) { if (u <= l[i].length) return { lineIndex: i, charIndex: u }; u -= l[i].length + this.missingNewlineOffset(i) } return { lineIndex: i - 1, charIndex: l[i - 1].length < u ? l[i - 1].length : u } }, getSelectionStyles: function (u, n, l) { typeof u > "u" && (u = this.selectionStart || 0), typeof n > "u" && (n = this.selectionEnd || u); for (var h = [], i = u; i < n; i++)h.push(this.getStyleAtPosition(i, l)); return h }, getStyleAtPosition: function (u, n) { var l = this.get2DCursorLocation(u), h = n ? this.getCompleteStyleDeclaration(l.lineIndex, l.charIndex) : this._getStyleDeclaration(l.lineIndex, l.charIndex); return h || {} }, setSelectionStyles: function (u, n, l) { typeof n > "u" && (n = this.selectionStart || 0), typeof l > "u" && (l = this.selectionEnd || n); for (var h = n; h < l; h++)this._extendStyles(h, u); return this._forceClearCache = !0, this }, _getStyleDeclaration: function (u, n) { var l = this.styles && this.styles[u]; return l ? l[n] : null }, getCompleteStyleDeclaration: function (u, n) { for (var l = this._getStyleDeclaration(u, n) || {}, h = {}, i, r = 0; r < this._styleProperties.length; r++)i = this._styleProperties[r], h[i] = typeof l[i] > "u" ? this[i] : l[i]; return h }, _setStyleDeclaration: function (u, n, l) { this.styles[u][n] = l }, _deleteStyleDeclaration: function (u, n) { delete this.styles[u][n] }, _getLineStyle: function (u) { return !!this.styles[u] }, _setLineStyle: function (u) { this.styles[u] = {} }, _deleteLineStyle: function (u) { delete this.styles[u] } }) }(), function () { function u(n) { n.textDecoration && (n.textDecoration.indexOf("underline") > -1 && (n.underline = !0), n.textDecoration.indexOf("line-through") > -1 && (n.linethrough = !0), n.textDecoration.indexOf("overline") > -1 && (n.overline = !0), delete n.textDecoration) } t.IText = t.util.createClass(t.Text, t.Observable, { type: "i-text", selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, _reSpace: /\s|\n/, _currentCursorOpacity: 0, _selectionDirection: null, _abortCursorAnimation: !1, __widthOfSpace: [], inCompositionMode: !1, initialize: function (n, l) { this.callSuper("initialize", n, l), this.initBehavior() }, setSelectionStart: function (n) { n = Math.max(n, 0), this._updateAndFire("selectionStart", n) }, setSelectionEnd: function (n) { n = Math.min(n, this.text.length), this._updateAndFire("selectionEnd", n) }, _updateAndFire: function (n, l) { this[n] !== l && (this._fireSelectionChanged(), this[n] = l), this._updateTextarea() }, _fireSelectionChanged: function () { this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this }) }, initDimensions: function () { this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this.callSuper("initDimensions") }, render: function (n) { this.clearContextTop(), this.callSuper("render", n), this.cursorOffsetCache = {}, this.renderCursorOrSelection() }, _render: function (n) { this.callSuper("_render", n) }, clearContextTop: function (n) { if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) { var l = this.canvas.contextTop, h = this.canvas.viewportTransform; l.save(), l.transform(h[0], h[1], h[2], h[3], h[4], h[5]), this.transform(l), this._clearTextArea(l), n || l.restore() } }, renderCursorOrSelection: function () { if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) { var n = this._getCursorBoundaries(), l = this.canvas.contextTop; this.clearContextTop(!0), this.selectionStart === this.selectionEnd ? this.renderCursor(n, l) : this.renderSelection(n, l), l.restore() } }, _clearTextArea: function (n) { var l = this.width + 4, h = this.height + 4; n.clearRect(-l / 2, -h / 2, l, h) }, _getCursorBoundaries: function (n) { typeof n > "u" && (n = this.selectionStart); var l = this._getLeftOffset(), h = this._getTopOffset(), i = this._getCursorBoundariesOffsets(n); return { left: l, top: h, leftOffset: i.left, topOffset: i.top } }, _getCursorBoundariesOffsets: function (n) { if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) return this.cursorOffsetCache; var l, h, i, r = 0, e = 0, o, c = this.get2DCursorLocation(n); i = c.charIndex, h = c.lineIndex; for (var s = 0; s < h; s++)r += this.getHeightOfLine(s); l = this._getLineLeftOffset(h); var f = this.__charBounds[h][i]; return f && (e = f.left), this.charSpacing !== 0 && i === this._textLines[h].length && (e -= this._getWidthOfCharSpacing()), o = { top: r, left: l + (e > 0 ? e : 0) }, this.direction === "rtl" && (o.left *= -1), this.cursorOffsetCache = o, this.cursorOffsetCache }, renderCursor: function (n, l) { var h = this.get2DCursorLocation(), i = h.lineIndex, r = h.charIndex > 0 ? h.charIndex - 1 : 0, e = this.getValueOfPropertyAt(i, r, "fontSize"), o = this.scaleX * this.canvas.getZoom(), c = this.cursorWidth / o, s = n.topOffset, f = this.getValueOfPropertyAt(i, r, "deltaY"); s += (1 - this._fontSizeFraction) * this.getHeightOfLine(i) / this.lineHeight - e * (1 - this._fontSizeFraction), this.inCompositionMode && this.renderSelection(n, l), l.fillStyle = this.cursorColor || this.getValueOfPropertyAt(i, r, "fill"), l.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, l.fillRect(n.left + n.leftOffset - c / 2, s + n.top + f, c, e) }, renderSelection: function (n, l) { for (var h = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, i = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, r = this.textAlign.indexOf("justify") !== -1, e = this.get2DCursorLocation(h), o = this.get2DCursorLocation(i), c = e.lineIndex, s = o.lineIndex, f = e.charIndex < 0 ? 0 : e.charIndex, d = o.charIndex < 0 ? 0 : o.charIndex, p = c; p <= s; p++) { var m = this._getLineLeftOffset(p) || 0, y = this.getHeightOfLine(p), x = 0, P = 0, D = 0; if (p === c && (P = this.__charBounds[c][f].left), p >= c && p < s) D = r && !this.isEndOfWrapping(p) ? this.width : this.getLineWidth(p) || 5; else if (p === s) if (d === 0) D = this.__charBounds[s][d].left; else { var Y = this._getWidthOfCharSpacing(); D = this.__charBounds[s][d - 1].left + this.__charBounds[s][d - 1].width - Y } x = y, (this.lineHeight < 1 || p === s && this.lineHeight > 1) && (y /= this.lineHeight); var V = n.left + m + P, J = D - P, Q = y, rt = 0; this.inCompositionMode ? (l.fillStyle = this.compositionColor || "black", Q = 1, rt = y) : l.fillStyle = this.selectionColor, this.direction === "rtl" && (V = this.width - V - J), l.fillRect(V, n.top + n.topOffset + rt, J, Q), n.topOffset += x } }, getCurrentCharFontSize: function () { var n = this._getCurrentCharIndex(); return this.getValueOfPropertyAt(n.l, n.c, "fontSize") }, getCurrentCharColor: function () { var n = this._getCurrentCharIndex(); return this.getValueOfPropertyAt(n.l, n.c, "fill") }, _getCurrentCharIndex: function () { var n = this.get2DCursorLocation(this.selectionStart, !0), l = n.charIndex > 0 ? n.charIndex - 1 : 0; return { l: n.lineIndex, c: l } } }), t.IText.fromObject = function (n, l) { var h = t.util.stylesFromArray(n.styles, n.text), i = Object.assign({}, n, { styles: h }); if (u(i), i.styles) for (var r in i.styles) for (var e in i.styles[r]) u(i.styles[r][e]); t.Object._fromObject("IText", i, l, "text") } }(), function () {
    var u = t.util.object.clone; t.util.object.extend(t.IText.prototype, {
        initBehavior: function () { this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this) }, onDeselect: function () { this.isEditing && this.exitEditing(), this.selected = !1 }, initAddedHandler: function () { var n = this; this.on("added", function () { var l = n.canvas; l && (l._hasITextHandlers || (l._hasITextHandlers = !0, n._initCanvasHandlers(l)), l._iTextInstances = l._iTextInstances || [], l._iTextInstances.push(n)) }) }, initRemovedHandler: function () { var n = this; this.on("removed", function () { var l = n.canvas; l && (l._iTextInstances = l._iTextInstances || [], t.util.removeFromArray(l._iTextInstances, n), l._iTextInstances.length === 0 && (l._hasITextHandlers = !1, n._removeCanvasHandlers(l))) }) }, _initCanvasHandlers: function (n) { n._mouseUpITextHandler = function () { n._iTextInstances && n._iTextInstances.forEach(function (l) { l.__isMousedown = !1 }) }, n.on("mouse:up", n._mouseUpITextHandler) }, _removeCanvasHandlers: function (n) { n.off("mouse:up", n._mouseUpITextHandler) }, _tick: function () { this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete") }, _animateCursor: function (n, l, h, i) { var r; return r = { isAborted: !1, abort: function () { this.isAborted = !0 } }, n.animate("_currentCursorOpacity", l, { duration: h, onComplete: function () { r.isAborted || n[i]() }, onChange: function () { n.canvas && n.selectionStart === n.selectionEnd && n.renderCursorOrSelection() }, abort: function () { return r.isAborted } }), r }, _onTickComplete: function () { var n = this; this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout(function () { n._currentTickCompleteState = n._animateCursor(n, 0, this.cursorDuration / 2, "_tick") }, 100) }, initDelayedCursor: function (n) { var l = this, h = n ? 0 : this.cursorDelay; this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout(function () { l._tick() }, h) }, abortCursorAnimation: function () { var n = this._currentTickState || this._currentTickCompleteState, l = this.canvas; this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, n && l && l.clearContext(l.contextTop || l.contextContainer) }, selectAll: function () { return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this }, getSelectedText: function () { return this._text.slice(this.selectionStart, this.selectionEnd).join("") }, findWordBoundaryLeft: function (n) { var l = 0, h = n - 1; if (this._reSpace.test(this._text[h])) for (; this._reSpace.test(this._text[h]);)l++, h--; for (; /\S/.test(this._text[h]) && h > -1;)l++, h--; return n - l }, findWordBoundaryRight: function (n) { var l = 0, h = n; if (this._reSpace.test(this._text[h])) for (; this._reSpace.test(this._text[h]);)l++, h++; for (; /\S/.test(this._text[h]) && h < this._text.length;)l++, h++; return n + l }, findLineBoundaryLeft: function (n) { for (var l = 0, h = n - 1; !/\n/.test(this._text[h]) && h > -1;)l++, h--; return n - l }, findLineBoundaryRight: function (n) { for (var l = 0, h = n; !/\n/.test(this._text[h]) && h < this._text.length;)l++, h++; return n + l }, searchWordBoundary: function (n, l) { for (var h = this._text, i = this._reSpace.test(h[n]) ? n - 1 : n, r = h[i], e = t.reNonWord; !e.test(r) && i > 0 && i < h.length;)i += l, r = h[i]; return e.test(r) && (i += l === 1 ? 0 : 1), i }, selectWord: function (n) { n = n || this.selectionStart; var l = this.searchWordBoundary(n, -1), h = this.searchWordBoundary(n, 1); this.selectionStart = l, this.selectionEnd = h, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection() }, selectLine: function (n) { n = n || this.selectionStart; var l = this.findLineBoundaryLeft(n), h = this.findLineBoundaryRight(n); return this.selectionStart = l, this.selectionEnd = h, this._fireSelectionChanged(), this._updateTextarea(), this }, enterEditing: function (n) { if (!(this.isEditing || !this.editable)) return this.canvas && (this.canvas.calcOffset(), this.exitEditingOnOthers(this.canvas)), this.isEditing = !0, this.initHiddenTextarea(n), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered"), this._fireSelectionChanged(), this.canvas ? (this.canvas.fire("text:editing:entered", { target: this }), this.initMouseMoveHandler(), this.canvas.requestRenderAll(), this) : this }, exitEditingOnOthers: function (n) { n._iTextInstances && n._iTextInstances.forEach(function (l) { l.selected = !1, l.isEditing && l.exitEditing() }) }, initMouseMoveHandler: function () { this.canvas.on("mouse:move", this.mouseMoveHandler) }, mouseMoveHandler: function (n) { if (!(!this.__isMousedown || !this.isEditing)) { document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus(); var l = this.getSelectionStartFromPointer(n.e), h = this.selectionStart, i = this.selectionEnd; (l !== this.__selectionStartOnMouseDown || h === i) && (h === l || i === l) || (l > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = l) : (this.selectionStart = l, this.selectionEnd = this.__selectionStartOnMouseDown), (this.selectionStart !== h || this.selectionEnd !== i) && (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection())) } }, _setEditingProps: function () { this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0 }, fromStringToGraphemeSelection: function (n, l, h) { var i = h.slice(0, n), r = t.util.string.graphemeSplit(i).length; if (n === l) return { selectionStart: r, selectionEnd: r }; var e = h.slice(n, l), o = t.util.string.graphemeSplit(e).length; return { selectionStart: r, selectionEnd: r + o } }, fromGraphemeToStringSelection: function (n, l, h) { var i = h.slice(0, n), r = i.join("").length; if (n === l) return { selectionStart: r, selectionEnd: r }; var e = h.slice(n, l), o = e.join("").length; return { selectionStart: r, selectionEnd: r + o } }, _updateTextarea: function () { if (this.cursorOffsetCache = {}, !!this.hiddenTextarea) { if (!this.inCompositionMode) { var n = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text); this.hiddenTextarea.selectionStart = n.selectionStart, this.hiddenTextarea.selectionEnd = n.selectionEnd } this.updateTextareaPosition() } }, updateFromTextArea: function () { if (this.hiddenTextarea) { this.cursorOffsetCache = {}, this.text = this.hiddenTextarea.value, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()); var n = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value); this.selectionEnd = this.selectionStart = n.selectionEnd, this.inCompositionMode || (this.selectionStart = n.selectionStart), this.updateTextareaPosition() } }, updateTextareaPosition: function () { if (this.selectionStart === this.selectionEnd) { var n = this._calcTextareaPosition(); this.hiddenTextarea.style.left = n.left, this.hiddenTextarea.style.top = n.top } }, _calcTextareaPosition: function () { if (!this.canvas) return { x: 1, y: 1 }; var n = this.inCompositionMode ? this.compositionStart : this.selectionStart, l = this._getCursorBoundaries(n), h = this.get2DCursorLocation(n), i = h.lineIndex, r = h.charIndex, e = this.getValueOfPropertyAt(i, r, "fontSize") * this.lineHeight, o = l.leftOffset, c = this.calcTransformMatrix(), s = { x: l.left + o, y: l.top + l.topOffset + e }, f = this.canvas.getRetinaScaling(), d = this.canvas.upperCanvasEl, p = d.width / f, m = d.height / f, y = p - e, x = m - e, P = d.clientWidth / p, D = d.clientHeight / m; return s = t.util.transformPoint(s, c), s = t.util.transformPoint(s, this.canvas.viewportTransform), s.x *= P, s.y *= D, s.x < 0 && (s.x = 0), s.x > y && (s.x = y), s.y < 0 && (s.y = 0), s.y > x && (s.y = x), s.x += this.canvas._offset.left, s.y += this.canvas._offset.top, { left: s.x + "px", top: s.y + "px", fontSize: e + "px", charHeight: e } }, _saveEditingProps: function () { this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor } }, _restoreEditingProps: function () { this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor)) }, exitEditing: function () { var n = this._textBeforeEdit !== this.text, l = this.hiddenTextarea; return this.selected = !1, this.isEditing = !1, this.selectionEnd = this.selectionStart, l && (l.blur && l.blur(), l.parentNode && l.parentNode.removeChild(l)), this.hiddenTextarea = null, this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this.fire("editing:exited"), n && this.fire("modified"), this.canvas && (this.canvas.off("mouse:move", this.mouseMoveHandler), this.canvas.fire("text:editing:exited", { target: this }), n && this.canvas.fire("object:modified", { target: this })), this }, _removeExtraneousStyles: function () { for (var n in this.styles) this._textLines[n] || delete this.styles[n] }, removeStyleFromTo: function (n, l) { var h = this.get2DCursorLocation(n, !0), i = this.get2DCursorLocation(l, !0), r = h.lineIndex, e = h.charIndex, o = i.lineIndex, c = i.charIndex, s, f; if (r !== o) { if (this.styles[r]) for (s = e; s < this._unwrappedTextLines[r].length; s++)delete this.styles[r][s]; if (this.styles[o]) for (s = c; s < this._unwrappedTextLines[o].length; s++)f = this.styles[o][s], f && (this.styles[r] || (this.styles[r] = {}), this.styles[r][e + s - c] = f); for (s = r + 1; s <= o; s++)delete this.styles[s]; this.shiftLineStyles(o, r - o) } else if (this.styles[r]) { f = this.styles[r]; var d = c - e, p, m; for (s = e; s < c; s++)delete f[s]; for (m in this.styles[r]) p = parseInt(m, 10), p >= c && (f[p - d] = f[m], delete f[m]) } }, shiftLineStyles: function (n, l) { var h = u(this.styles); for (var i in this.styles) { var r = parseInt(i, 10); r > n && (this.styles[r + l] = h[r], h[r - l] || delete this.styles[r]) } }, restartCursorIfNeeded: function () { (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) && this.initDelayedCursor() }, insertNewlineStyleObject: function (n, l, h, i) { var r, e = {}, o = !1, c = this._unwrappedTextLines[n].length === l; h || (h = 1), this.shiftLineStyles(n, h), this.styles[n] && (r = this.styles[n][l === 0 ? l : l - 1]); for (var s in this.styles[n]) { var f = parseInt(s, 10); f >= l && (o = !0, e[f - l] = this.styles[n][s], c && l === 0 || delete this.styles[n][s]) } var d = !1; for (o && !c && (this.styles[n + h] = e, d = !0), d && h--; h > 0;)i && i[h - 1] ? this.styles[n + h] = { 0: u(i[h - 1]) } : r ? this.styles[n + h] = { 0: u(r) } : delete this.styles[n + h], h--; this._forceClearCache = !0 }, insertCharStyleObject: function (n, l, h, i) { this.styles || (this.styles = {}); var r = this.styles[n], e = r ? u(r) : {}; h || (h = 1); for (var o in e) { var c = parseInt(o, 10); c >= l && (r[c + h] = e[c], e[c - h] || delete r[c]) } if (this._forceClearCache = !0, i) { for (; h--;)Object.keys(i[h]).length && (this.styles[n] || (this.styles[n] = {}), this.styles[n][l + h] = u(i[h])); return } if (r) for (var s = r[l ? l - 1 : 1]; s && h--;)this.styles[n][l + h] = u(s) }, insertNewStyleBlock: function (n, l, h) {
            for (var i = this.get2DCursorLocation(l, !0), r = [0], e = 0, o = 0; o < n.length; o++)n[o] === `
`? (e++, r[e] = 0) : r[e]++; r[0] > 0 && (this.insertCharStyleObject(i.lineIndex, i.charIndex, r[0], h), h = h && h.slice(r[0] + 1)), e && this.insertNewlineStyleObject(i.lineIndex, i.charIndex + r[0], e); for (var o = 1; o < e; o++)r[o] > 0 ? this.insertCharStyleObject(i.lineIndex + o, 0, r[o], h) : h && this.styles[i.lineIndex + o] && h[0] && (this.styles[i.lineIndex + o][0] = h[0]), h = h && h.slice(r[o] + 1); r[o] > 0 && this.insertCharStyleObject(i.lineIndex + o, 0, r[o], h)
        }, setSelectionStartEndWithShift: function (n, l, h) { h <= n ? (l === n ? this._selectionDirection = "left" : this._selectionDirection === "right" && (this._selectionDirection = "left", this.selectionEnd = n), this.selectionStart = h) : h > n && h < l ? this._selectionDirection === "right" ? this.selectionEnd = h : this.selectionStart = h : (l === n ? this._selectionDirection = "right" : this._selectionDirection === "left" && (this._selectionDirection = "right", this.selectionStart = l), this.selectionEnd = h) }, setSelectionInBoundaries: function () { var n = this.text.length; this.selectionStart > n ? this.selectionStart = n : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > n ? this.selectionEnd = n : this.selectionEnd < 0 && (this.selectionEnd = 0) }
    })
}(), t.util.object.extend(t.IText.prototype, { initDoubleClickSimulation: function () { this.__lastClickTime = +new Date, this.__lastLastClickTime = +new Date, this.__lastPointer = {}, this.on("mousedown", this.onMouseDown) }, onMouseDown: function (u) { if (this.canvas) { this.__newClickTime = +new Date; var n = u.pointer; this.isTripleClick(n) && (this.fire("tripleclick", u), this._stopEvent(u.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = n, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected } }, isTripleClick: function (u) { return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === u.x && this.__lastPointer.y === u.y }, _stopEvent: function (u) { u.preventDefault && u.preventDefault(), u.stopPropagation && u.stopPropagation() }, initCursorSelectionHandlers: function () { this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks() }, doubleClickHandler: function (u) { this.isEditing && this.selectWord(this.getSelectionStartFromPointer(u.e)) }, tripleClickHandler: function (u) { this.isEditing && this.selectLine(this.getSelectionStartFromPointer(u.e)) }, initClicks: function () { this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler) }, _mouseDownHandler: function (u) { !this.canvas || !this.editable || u.e.button && u.e.button !== 1 || (this.__isMousedown = !0, this.selected && (this.inCompositionMode = !1, this.setCursorByClick(u.e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())) }, _mouseDownHandlerBefore: function (u) { !this.canvas || !this.editable || u.e.button && u.e.button !== 1 || (this.selected = this === this.canvas._activeObject) }, initMousedownHandler: function () { this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore) }, initMouseupHandler: function () { this.on("mouseup", this.mouseUpHandler) }, mouseUpHandler: function (u) { if (this.__isMousedown = !1, !(!this.editable || this.group || u.transform && u.transform.actionPerformed || u.e.button && u.e.button !== 1)) { if (this.canvas) { var n = this.canvas._activeObject; if (n && n !== this) return } this.__lastSelected && !this.__corner ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(u.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0 } }, setCursorByClick: function (u) { var n = this.getSelectionStartFromPointer(u), l = this.selectionStart, h = this.selectionEnd; u.shiftKey ? this.setSelectionStartEndWithShift(l, h, n) : (this.selectionStart = n, this.selectionEnd = n), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea()) }, getSelectionStartFromPointer: function (u) { for (var n = this.getLocalPointer(u), l = 0, h = 0, i = 0, r = 0, e = 0, o, c, s = 0, f = this._textLines.length; s < f && i <= n.y; s++)i += this.getHeightOfLine(s) * this.scaleY, e = s, s > 0 && (r += this._textLines[s - 1].length + this.missingNewlineOffset(s - 1)); o = this._getLineLeftOffset(e), h = o * this.scaleX, c = this._textLines[e], this.direction === "rtl" && (n.x = this.width * this.scaleX - n.x + h); for (var d = 0, p = c.length; d < p && (l = h, h += this.__charBounds[e][d].kernedWidth * this.scaleX, h <= n.x); d++)r++; return this._getNewSelectionStartFromOffset(n, l, h, r, p) }, _getNewSelectionStartFromOffset: function (u, n, l, h, i) { var r = u.x - n, e = l - u.x, o = e > r || e < 0 ? 0 : 1, c = h + o; return this.flipX && (c = i - c), c > this._text.length && (c = this._text.length), c } }), t.util.object.extend(t.IText.prototype, { initHiddenTextarea: function () { this.hiddenTextarea = t.document.createElement("textarea"), this.hiddenTextarea.setAttribute("autocapitalize", "off"), this.hiddenTextarea.setAttribute("autocorrect", "off"), this.hiddenTextarea.setAttribute("autocomplete", "off"), this.hiddenTextarea.setAttribute("spellcheck", "false"), this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""), this.hiddenTextarea.setAttribute("wrap", "off"); var u = this._calcTextareaPosition(); this.hiddenTextarea.style.cssText = "position: absolute; top: " + u.top + "; left: " + u.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: " + u.fontSize + ";", this.hiddenTextareaContainer ? this.hiddenTextareaContainer.appendChild(this.hiddenTextarea) : t.document.body.appendChild(this.hiddenTextarea), t.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this)), t.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this)), t.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this)), t.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)), t.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this)), t.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this)), t.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this)), t.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this)), t.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (t.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this)), this._clickHandlerInitialized = !0) }, keysMap: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorRight", 36: "moveCursorLeft", 37: "moveCursorLeft", 38: "moveCursorUp", 39: "moveCursorRight", 40: "moveCursorDown" }, keysMapRtl: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorLeft", 36: "moveCursorRight", 37: "moveCursorRight", 38: "moveCursorUp", 39: "moveCursorLeft", 40: "moveCursorDown" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" }, ctrlKeysMapDown: { 65: "selectAll" }, onClick: function () { this.hiddenTextarea && this.hiddenTextarea.focus() }, onKeyDown: function (u) { if (this.isEditing) { var n = this.direction === "rtl" ? this.keysMapRtl : this.keysMap; if (u.keyCode in n) this[n[u.keyCode]](u); else if (u.keyCode in this.ctrlKeysMapDown && (u.ctrlKey || u.metaKey)) this[this.ctrlKeysMapDown[u.keyCode]](u); else return; u.stopImmediatePropagation(), u.preventDefault(), u.keyCode >= 33 && u.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll() } }, onKeyUp: function (u) { if (!this.isEditing || this._copyDone || this.inCompositionMode) { this._copyDone = !1; return } if (u.keyCode in this.ctrlKeysMapUp && (u.ctrlKey || u.metaKey)) this[this.ctrlKeysMapUp[u.keyCode]](u); else return; u.stopImmediatePropagation(), u.preventDefault(), this.canvas && this.canvas.requestRenderAll() }, onInput: function (u) { var n = this.fromPaste; if (this.fromPaste = !1, u && u.stopPropagation(), !!this.isEditing) { var l = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, h = this._text.length, i = l.length, r, e, o = i - h, c = this.selectionStart, s = this.selectionEnd, f = c !== s, d, p, m; if (this.hiddenTextarea.value === "") { this.styles = {}, this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll()); return } var y = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), x = c > y.selectionStart; f ? (r = this._text.slice(c, s), o += s - c) : i < h && (x ? r = this._text.slice(s + o, s) : r = this._text.slice(c, c - o)), e = l.slice(y.selectionEnd - o, y.selectionEnd), r && r.length && (e.length && (d = this.getSelectionStyles(c, c + 1, !1), d = e.map(function () { return d[0] })), f ? (p = c, m = s) : x ? (p = s - r.length, m = s) : (p = s, m = s + r.length), this.removeStyleFromTo(p, m)), e.length && (n && e.join("") === t.copiedText && !t.disableStyleCopyPaste && (d = t.copiedTextStyle), this.insertNewStyleBlock(e, c, d)), this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll()) } }, onCompositionStart: function () { this.inCompositionMode = !0 }, onCompositionEnd: function () { this.inCompositionMode = !1 }, onCompositionUpdate: function (u) { this.compositionStart = u.target.selectionStart, this.compositionEnd = u.target.selectionEnd, this.updateTextareaPosition() }, copy: function () { this.selectionStart !== this.selectionEnd && (t.copiedText = this.getSelectedText(), t.disableStyleCopyPaste ? t.copiedTextStyle = null : t.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0) }, paste: function () { this.fromPaste = !0 }, _getClipboardData: function (u) { return u && u.clipboardData || t.window.clipboardData }, _getWidthBeforeCursor: function (u, n) { var l = this._getLineLeftOffset(u), h; return n > 0 && (h = this.__charBounds[u][n - 1], l += h.left + h.width), l }, getDownCursorOffset: function (u, n) { var l = this._getSelectionForOffset(u, n), h = this.get2DCursorLocation(l), i = h.lineIndex; if (i === this._textLines.length - 1 || u.metaKey || u.keyCode === 34) return this._text.length - l; var r = h.charIndex, e = this._getWidthBeforeCursor(i, r), o = this._getIndexOnLine(i + 1, e), c = this._textLines[i].slice(r); return c.length + o + 1 + this.missingNewlineOffset(i) }, _getSelectionForOffset: function (u, n) { return u.shiftKey && this.selectionStart !== this.selectionEnd && n ? this.selectionEnd : this.selectionStart }, getUpCursorOffset: function (u, n) { var l = this._getSelectionForOffset(u, n), h = this.get2DCursorLocation(l), i = h.lineIndex; if (i === 0 || u.metaKey || u.keyCode === 33) return -l; var r = h.charIndex, e = this._getWidthBeforeCursor(i, r), o = this._getIndexOnLine(i - 1, e), c = this._textLines[i].slice(0, r), s = this.missingNewlineOffset(i - 1); return -this._textLines[i - 1].length + o - c.length + (1 - s) }, _getIndexOnLine: function (u, n) { for (var l = this._textLines[u], h = this._getLineLeftOffset(u), i = h, r = 0, e, o, c = 0, s = l.length; c < s; c++)if (e = this.__charBounds[u][c].width, i += e, i > n) { o = !0; var f = i - e, d = i, p = Math.abs(f - n), m = Math.abs(d - n); r = m < p ? c : c - 1; break } return o || (r = l.length - 1), r }, moveCursorDown: function (u) { this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", u) }, moveCursorUp: function (u) { this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", u) }, _moveCursorUpOrDown: function (u, n) { var l = "get" + u + "CursorOffset", h = this[l](n, this._selectionDirection === "right"); n.shiftKey ? this.moveCursorWithShift(h) : this.moveCursorWithoutShift(h), h !== 0 && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorWithShift: function (u) { var n = this._selectionDirection === "left" ? this.selectionStart + u : this.selectionEnd + u; return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, n), u !== 0 }, moveCursorWithoutShift: function (u) { return u < 0 ? (this.selectionStart += u, this.selectionEnd = this.selectionStart) : (this.selectionEnd += u, this.selectionStart = this.selectionEnd), u !== 0 }, moveCursorLeft: function (u) { this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", u) }, _move: function (u, n, l) { var h; if (u.altKey) h = this["findWordBoundary" + l](this[n]); else if (u.metaKey || u.keyCode === 35 || u.keyCode === 36) h = this["findLineBoundary" + l](this[n]); else return this[n] += l === "Left" ? -1 : 1, !0; if (typeof h < "u" && this[n] !== h) return this[n] = h, !0 }, _moveLeft: function (u, n) { return this._move(u, n, "Left") }, _moveRight: function (u, n) { return this._move(u, n, "Right") }, moveCursorLeftWithoutShift: function (u) { var n = !0; return this._selectionDirection = "left", this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (n = this._moveLeft(u, "selectionStart")), this.selectionEnd = this.selectionStart, n }, moveCursorLeftWithShift: function (u) { if (this._selectionDirection === "right" && this.selectionStart !== this.selectionEnd) return this._moveLeft(u, "selectionEnd"); if (this.selectionStart !== 0) return this._selectionDirection = "left", this._moveLeft(u, "selectionStart") }, moveCursorRight: function (u) { this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", u) }, _moveCursorLeftOrRight: function (u, n) { var l = "moveCursor" + u + "With"; this._currentCursorOpacity = 1, n.shiftKey ? l += "Shift" : l += "outShift", this[l](n) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorRightWithShift: function (u) { if (this._selectionDirection === "left" && this.selectionStart !== this.selectionEnd) return this._moveRight(u, "selectionStart"); if (this.selectionEnd !== this._text.length) return this._selectionDirection = "right", this._moveRight(u, "selectionEnd") }, moveCursorRightWithoutShift: function (u) { var n = !0; return this._selectionDirection = "right", this.selectionStart === this.selectionEnd ? (n = this._moveRight(u, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, n }, removeChars: function (u, n) { typeof n > "u" && (n = u + 1), this.removeStyleFromTo(u, n), this._text.splice(u, n - u), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles() }, insertChars: function (u, n, l, h) { typeof h > "u" && (h = l), h > l && this.removeStyleFromTo(l, h); var i = t.util.string.graphemeSplit(u); this.insertNewStyleBlock(i, l, n), this._text = [].concat(this._text.slice(0, l), i, this._text.slice(h)), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles() } }), function () {
    var u = t.util.toFixed, n = /  +/g; t.util.object.extend(t.Text.prototype, {
        _toSVG: function () { var l = this._getSVGLeftTopOffsets(), h = this._getSVGTextAndBg(l.textTop, l.textLeft); return this._wrapSVGTextAndBg(h) }, toSVG: function (l) { return this._createBaseSVGMarkup(this._toSVG(), { reviver: l, noStyle: !0, withShadow: !0 }) }, _getSVGLeftTopOffsets: function () { return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) } }, _wrapSVGTextAndBg: function (l) {
            var h = !0, i = this.getSvgTextDecoration(this); return [l.textBgRects.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "", this.fontSize ? 'font-size="' + this.fontSize + '" ' : "", this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "", this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "", i ? 'text-decoration="' + i + '" ' : "", 'style="', this.getSvgStyles(h), '"', this.addPaintOrder(), " >", l.textSpans.join(""), `</text>
`]
        }, _getSVGTextAndBg: function (l, h) { var i = [], r = [], e = l, o; this._setSVGBg(r); for (var c = 0, s = this._textLines.length; c < s; c++)o = this._getLineLeftOffset(c), (this.textBackgroundColor || this.styleHas("textBackgroundColor", c)) && this._setSVGTextLineBg(r, c, h + o, e), this._setSVGTextLineText(i, c, h + o, e), e += this.getHeightOfLine(c); return { textSpans: i, textBgRects: r } }, _createTextCharSpan: function (l, h, i, r) { var e = l !== l.trim() || l.match(n), o = this.getSvgSpanStyles(h, e), c = o ? 'style="' + o + '"' : "", s = h.deltaY, f = "", d = t.Object.NUM_FRACTION_DIGITS; return s && (f = ' dy="' + u(s, d) + '" '), ['<tspan x="', u(i, d), '" y="', u(r, d), '" ', f, c, ">", t.util.string.escapeXml(l), "</tspan>"].join("") }, _setSVGTextLineText: function (l, h, i, r) { var e = this.getHeightOfLine(h), o = this.textAlign.indexOf("justify") !== -1, c, s, f = "", d, p, m = 0, y = this._textLines[h], x; r += e * (1 - this._fontSizeFraction) / this.lineHeight; for (var P = 0, D = y.length - 1; P <= D; P++)x = P === D || this.charSpacing, f += y[P], d = this.__charBounds[h][P], m === 0 ? (i += d.kernedWidth - d.width, m += d.width) : m += d.kernedWidth, o && !x && this._reSpaceAndTab.test(y[P]) && (x = !0), x || (c = c || this.getCompleteStyleDeclaration(h, P), s = this.getCompleteStyleDeclaration(h, P + 1), x = t.util.hasStyleChanged(c, s, !0)), x && (p = this._getStyleDeclaration(h, P) || {}, l.push(this._createTextCharSpan(f, p, i, r)), f = "", c = s, i += m, m = 0) }, _pushTextBgRect: function (l, h, i, r, e, o) {
            var c = t.Object.NUM_FRACTION_DIGITS; l.push("		<rect ", this._getFillAttributes(h), ' x="', u(i, c), '" y="', u(r, c), '" width="', u(e, c), '" height="', u(o, c), `"></rect>
`)
        }, _setSVGTextLineBg: function (l, h, i, r) { for (var e = this._textLines[h], o = this.getHeightOfLine(h) / this.lineHeight, c = 0, s = 0, f, d, p = this.getValueOfPropertyAt(h, 0, "textBackgroundColor"), m = 0, y = e.length; m < y; m++)f = this.__charBounds[h][m], d = this.getValueOfPropertyAt(h, m, "textBackgroundColor"), d !== p ? (p && this._pushTextBgRect(l, p, i + s, r, c, o), s = f.left, c = f.width, p = d) : c += f.kernedWidth; d && this._pushTextBgRect(l, d, i + s, r, c, o) }, _getFillAttributes: function (l) { var h = l && typeof l == "string" ? new t.Color(l) : ""; return !h || !h.getSource() || h.getAlpha() === 1 ? 'fill="' + l + '"' : 'opacity="' + h.getAlpha() + '" fill="' + h.setAlpha(1).toRgb() + '"' }, _getSVGLineTopOffset: function (l) { for (var h = 0, i = 0, r = 0; r < l; r++)h += this.getHeightOfLine(r); return i = this.getHeightOfLine(r), { lineTop: h, offset: (this._fontSizeMult - this._fontSizeFraction) * i / (this.lineHeight * this._fontSizeMult) } }, getSvgStyles: function (l) { var h = t.Object.prototype.getSvgStyles.call(this, l); return h + " white-space: pre;" }
    })
}(), function (u) {
    var n = u.fabric || (u.fabric = {}); n.Textbox = n.util.createClass(n.IText, n.Observable, {
        type: "textbox", minWidth: 20, dynamicMinWidth: 2, __cachedLines: null, lockScalingFlip: !0, noScaleCache: !1, _dimensionAffectingProps: n.Text.prototype._dimensionAffectingProps.concat("width"), _wordJoiners: /[ \t\r]/, splitByGrapheme: !1, initDimensions: function () { this.__skipDimension || (this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({ propertySet: "_dimensionAffectingProps" })) }, _generateStyleMap: function (l) {
            for (var h = 0, i = 0, r = 0, e = {}, o = 0; o < l.graphemeLines.length; o++)l.graphemeText[r] === `
`&& o > 0 ? (i = 0, r++, h++) : !this.splitByGrapheme && this._reSpaceAndTab.test(l.graphemeText[r]) && o > 0 && (i++, r++), e[o] = { line: h, offset: i }, r += l.graphemeLines[o].length, i += l.graphemeLines[o].length; return e
        }, styleHas: function (l, h) { if (this._styleMap && !this.isWrapping) { var i = this._styleMap[h]; i && (h = i.line) } return n.Text.prototype.styleHas.call(this, l, h) }, isEmptyStyles: function (l) { if (!this.styles) return !0; var h = 0, i = l + 1, r, e, o = !1, c = this._styleMap[l], s = this._styleMap[l + 1]; c && (l = c.line, h = c.offset), s && (i = s.line, o = i === l, r = s.offset), e = typeof l > "u" ? this.styles : { line: this.styles[l] }; for (var f in e) for (var d in e[f]) if (d >= h && (!o || d < r)) for (var p in e[f][d]) return !1; return !0 }, _getStyleDeclaration: function (l, h) { if (this._styleMap && !this.isWrapping) { var i = this._styleMap[l]; if (!i) return null; l = i.line, h = i.offset + h } return this.callSuper("_getStyleDeclaration", l, h) }, _setStyleDeclaration: function (l, h, i) { var r = this._styleMap[l]; l = r.line, h = r.offset + h, this.styles[l][h] = i }, _deleteStyleDeclaration: function (l, h) { var i = this._styleMap[l]; l = i.line, h = i.offset + h, delete this.styles[l][h] }, _getLineStyle: function (l) { var h = this._styleMap[l]; return !!this.styles[h.line] }, _setLineStyle: function (l) { var h = this._styleMap[l]; this.styles[h.line] = {} }, _wrapText: function (l, h) { var i = [], r; for (this.isWrapping = !0, r = 0; r < l.length; r++)i = i.concat(this._wrapLine(l[r], r, h)); return this.isWrapping = !1, i }, _measureWord: function (l, h, i) { var r = 0, e, o = !0; i = i || 0; for (var c = 0, s = l.length; c < s; c++) { var f = this._getGraphemeBox(l[c], h, c + i, e, o); r += f.kernedWidth, e = l[c] } return r }, _wrapLine: function (l, h, i, V) { var e = 0, o = this.splitByGrapheme, c = [], s = [], f = o ? n.util.string.graphemeSplit(l) : l.split(this._wordJoiners), d = "", p = 0, m = o ? "" : " ", y = 0, x = 0, P = 0, D = !0, Y = this._getWidthOfCharSpacing(), V = V || 0; f.length === 0 && f.push([]), i -= V; for (var J = 0; J < f.length; J++)d = o ? f[J] : n.util.string.graphemeSplit(f[J]), y = this._measureWord(d, h, p), p += d.length, e += x + y - Y, e > i && !D ? (c.push(s), s = [], e = y, D = !0) : e += Y, !D && !o && s.push(m), s = s.concat(d), x = o ? 0 : this._measureWord([m], h, p), p++, D = !1, y > P && (P = y); return J && c.push(s), P + V > this.dynamicMinWidth && (this.dynamicMinWidth = P - Y + V), c }, isEndOfWrapping: function (l) { return !this._styleMap[l + 1] || this._styleMap[l + 1].line !== this._styleMap[l].line }, missingNewlineOffset: function (l) { return this.splitByGrapheme ? this.isEndOfWrapping(l) ? 1 : 0 : 1 }, _splitTextIntoLines: function (l) { for (var h = n.Text.prototype._splitTextIntoLines.call(this, l), i = this._wrapText(h.lines, this.width), r = new Array(i.length), e = 0; e < i.length; e++)r[e] = i[e].join(""); return h.lines = r, h.graphemeLines = i, h }, getMinWidth: function () { return Math.max(this.minWidth, this.dynamicMinWidth) }, _removeExtraneousStyles: function () { var l = {}; for (var h in this._styleMap) this._textLines[h] && (l[this._styleMap[h].line] = 1); for (var h in this.styles) l[h] || delete this.styles[h] }, toObject: function (l) { return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(l)) }
    }), n.Textbox.fromObject = function (l, h) { var i = n.util.stylesFromArray(l.styles, l.text), r = Object.assign({}, l, { styles: i }); return n.Object._fromObject("Textbox", r, h, "text") }
}(a), function () { var u = t.controlsUtils, n = u.scaleSkewCursorStyleHandler, l = u.scaleCursorStyleHandler, h = u.scalingEqually, i = u.scalingYOrSkewingX, r = u.scalingXOrSkewingY, e = u.scaleOrSkewActionName, o = t.Object.prototype.controls; if (o.ml = new t.Control({ x: -.5, y: 0, cursorStyleHandler: n, actionHandler: r, getActionName: e }), o.mr = new t.Control({ x: .5, y: 0, cursorStyleHandler: n, actionHandler: r, getActionName: e }), o.mb = new t.Control({ x: 0, y: .5, cursorStyleHandler: n, actionHandler: i, getActionName: e }), o.mt = new t.Control({ x: 0, y: -.5, cursorStyleHandler: n, actionHandler: i, getActionName: e }), o.tl = new t.Control({ x: -.5, y: -.5, cursorStyleHandler: l, actionHandler: h }), o.tr = new t.Control({ x: .5, y: -.5, cursorStyleHandler: l, actionHandler: h }), o.bl = new t.Control({ x: -.5, y: .5, cursorStyleHandler: l, actionHandler: h }), o.br = new t.Control({ x: .5, y: .5, cursorStyleHandler: l, actionHandler: h }), o.mtr = new t.Control({ x: 0, y: -.5, actionHandler: u.rotationWithSnapping, cursorStyleHandler: u.rotationStyleHandler, offsetY: -40, withConnection: !0, actionName: "rotate" }), t.Textbox) { var c = t.Textbox.prototype.controls = {}; c.mtr = o.mtr, c.tr = o.tr, c.br = o.br, c.tl = o.tl, c.bl = o.bl, c.mt = o.mt, c.mb = o.mb, c.mr = new t.Control({ x: .5, y: 0, actionHandler: u.changeWidth, cursorStyleHandler: n, actionName: "resizing" }), c.ml = new t.Control({ x: -.5, y: 0, actionHandler: u.changeWidth, cursorStyleHandler: n, actionName: "resizing" }) } }()
})(Ct); var Hr = { exports: {} }; (function (a) { (function () { function t(c, s) { document.addEventListener ? c.addEventListener("scroll", s, !1) : c.attachEvent("scroll", s) } function g(c) { document.body ? c() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function s() { document.removeEventListener("DOMContentLoaded", s), c() }) : document.attachEvent("onreadystatechange", function s() { (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", s), c()) }) } function v(c) { this.g = document.createElement("div"), this.g.setAttribute("aria-hidden", "true"), this.g.appendChild(document.createTextNode(c)), this.h = document.createElement("span"), this.i = document.createElement("span"), this.m = document.createElement("span"), this.j = document.createElement("span"), this.l = -1, this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.h.appendChild(this.m), this.i.appendChild(this.j), this.g.appendChild(this.h), this.g.appendChild(this.i) } function _(c, s) { c.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + s + ";" } function C(c) { var s = c.g.offsetWidth, f = s + 100; return c.j.style.width = f + "px", c.i.scrollLeft = f, c.h.scrollLeft = c.h.scrollWidth + 100, c.l !== s ? (c.l = s, !0) : !1 } function b(c, s) { function f() { var p = d; C(p) && p.g.parentNode !== null && s(p.l) } var d = c; t(c.h, f), t(c.i, f), C(c) } function u(c, s, f) { s = s || {}, f = f || window, this.family = c, this.style = s.style || "normal", this.weight = s.weight || "normal", this.stretch = s.stretch || "normal", this.context = f } var n = null, l = null, h = null, i = null; function r(c) { return l === null && (e(c) && /Apple/.test(window.navigator.vendor) ? (c = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent), l = !!c && 603 > parseInt(c[1], 10)) : l = !1), l } function e(c) { return i === null && (i = !!c.document.fonts), i } function o(c, s) { var f = c.style, d = c.weight; if (h === null) { var p = document.createElement("div"); try { p.style.font = "condensed 100px sans-serif" } catch { } h = p.style.font !== "" } return [f, d, h ? c.stretch : "", "100px", s].join(" ") } u.prototype.load = function (c, s) { var f = this, d = c || "BESbswy", p = 0, m = s || 3e3, y = new Date().getTime(); return new Promise(function (x, P) { if (e(f.context) && !r(f.context)) { var D = new Promise(function (V, J) { function Q() { new Date().getTime() - y >= m ? J(Error("" + m + "ms timeout exceeded")) : f.context.document.fonts.load(o(f, '"' + f.family + '"'), d).then(function (rt) { 1 <= rt.length ? V() : setTimeout(Q, 25) }, J) } Q() }), Y = new Promise(function (V, J) { p = setTimeout(function () { J(Error("" + m + "ms timeout exceeded")) }, m) }); Promise.race([Y, D]).then(function () { clearTimeout(p), x(f) }, P) } else g(function () { function V() { var A; (A = it != -1 && ot != -1 || it != -1 && st != -1 || ot != -1 && st != -1) && ((A = it != ot && it != st && ot != st) || (n === null && (A = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), n = !!A && (536 > parseInt(A[1], 10) || parseInt(A[1], 10) === 536 && 11 >= parseInt(A[2], 10))), A = n && (it == nt && ot == nt && st == nt || it == w && ot == w && st == w || it == F && ot == F && st == F)), A = !A), A && (k.parentNode !== null && k.parentNode.removeChild(k), clearTimeout(p), x(f)) } function J() { if (new Date().getTime() - y >= m) k.parentNode !== null && k.parentNode.removeChild(k), P(Error("" + m + "ms timeout exceeded")); else { var A = f.context.document.hidden; (A === !0 || A === void 0) && (it = Q.g.offsetWidth, ot = rt.g.offsetWidth, st = tt.g.offsetWidth, V()), p = setTimeout(J, 50) } } var Q = new v(d), rt = new v(d), tt = new v(d), it = -1, ot = -1, st = -1, nt = -1, w = -1, F = -1, k = document.createElement("div"); k.dir = "ltr", _(Q, o(f, "sans-serif")), _(rt, o(f, "serif")), _(tt, o(f, "monospace")), k.appendChild(Q.g), k.appendChild(rt.g), k.appendChild(tt.g), f.context.document.body.appendChild(k), nt = Q.g.offsetWidth, w = rt.g.offsetWidth, F = tt.g.offsetWidth, J(), b(Q, function (A) { it = A, V() }), _(Q, o(f, '"' + f.family + '",sans-serif')), b(rt, function (A) { ot = A, V() }), _(rt, o(f, '"' + f.family + '",serif')), b(tt, function (A) { st = A, V() }), _(tt, o(f, '"' + f.family + '",monospace')) }) }) }, a.exports = u })() })(Hr); var Ra = Hr.exports; const Ba = Fa(Ra); var an = { exports: {} }, be = typeof Reflect == "object" ? Reflect : null, zn = be && typeof be.apply == "function" ? be.apply : function (t, g, v) { return Function.prototype.apply.call(t, g, v) }, Je; be && typeof be.ownKeys == "function" ? Je = be.ownKeys : Object.getOwnPropertySymbols ? Je = function (t) { return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t)) } : Je = function (t) { return Object.getOwnPropertyNames(t) }; function Wa(a) { console && console.warn && console.warn(a) } var zr = Number.isNaN || function (t) { return t !== t }; function vt() { vt.init.call(this) } an.exports = vt; an.exports.once = Ya; vt.EventEmitter = vt; vt.prototype._events = void 0; vt.prototype._eventsCount = 0; vt.prototype._maxListeners = void 0; var Yn = 10; function vi(a) { if (typeof a != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a) } Object.defineProperty(vt, "defaultMaxListeners", { enumerable: !0, get: function () { return Yn }, set: function (a) { if (typeof a != "number" || a < 0 || zr(a)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + "."); Yn = a } }); vt.init = function () { (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }; vt.prototype.setMaxListeners = function (t) { if (typeof t != "number" || t < 0 || zr(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + "."); return this._maxListeners = t, this }; function Yr(a) { return a._maxListeners === void 0 ? vt.defaultMaxListeners : a._maxListeners } vt.prototype.getMaxListeners = function () { return Yr(this) }; vt.prototype.emit = function (t) { for (var g = [], v = 1; v < arguments.length; v++)g.push(arguments[v]); var _ = t === "error", C = this._events; if (C !== void 0) _ = _ && C.error === void 0; else if (!_) return !1; if (_) { var b; if (g.length > 0 && (b = g[0]), b instanceof Error) throw b; var u = new Error("Unhandled error." + (b ? " (" + b.message + ")" : "")); throw u.context = b, u } var n = C[t]; if (n === void 0) return !1; if (typeof n == "function") zn(n, this, g); else for (var l = n.length, h = Kr(n, l), v = 0; v < l; ++v)zn(h[v], this, g); return !0 }; function Nr(a, t, g, v) { var _, C, b; if (vi(g), C = a._events, C === void 0 ? (C = a._events = Object.create(null), a._eventsCount = 0) : (C.newListener !== void 0 && (a.emit("newListener", t, g.listener ? g.listener : g), C = a._events), b = C[t]), b === void 0) b = C[t] = g, ++a._eventsCount; else if (typeof b == "function" ? b = C[t] = v ? [g, b] : [b, g] : v ? b.unshift(g) : b.push(g), _ = Yr(a), _ > 0 && b.length > _ && !b.warned) { b.warned = !0; var u = new Error("Possible EventEmitter memory leak detected. " + b.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit"); u.name = "MaxListenersExceededWarning", u.emitter = a, u.type = t, u.count = b.length, Wa(u) } return a } vt.prototype.addListener = function (t, g) { return Nr(this, t, g, !1) }; vt.prototype.on = vt.prototype.addListener; vt.prototype.prependListener = function (t, g) { return Nr(this, t, g, !0) }; function Xa() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function Ur(a, t, g) { var v = { fired: !1, wrapFn: void 0, target: a, type: t, listener: g }, _ = Xa.bind(v); return _.listener = g, v.wrapFn = _, _ } vt.prototype.once = function (t, g) { return vi(g), this.on(t, Ur(this, t, g)), this }; vt.prototype.prependOnceListener = function (t, g) { return vi(g), this.prependListener(t, Ur(this, t, g)), this }; vt.prototype.removeListener = function (t, g) { var v, _, C, b, u; if (vi(g), _ = this._events, _ === void 0) return this; if (v = _[t], v === void 0) return this; if (v === g || v.listener === g) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete _[t], _.removeListener && this.emit("removeListener", t, v.listener || g)); else if (typeof v != "function") { for (C = -1, b = v.length - 1; b >= 0; b--)if (v[b] === g || v[b].listener === g) { u = v[b].listener, C = b; break } if (C < 0) return this; C === 0 ? v.shift() : Ha(v, C), v.length === 1 && (_[t] = v[0]), _.removeListener !== void 0 && this.emit("removeListener", t, u || g) } return this }; vt.prototype.off = vt.prototype.removeListener; vt.prototype.removeAllListeners = function (t) { var g, v, _; if (v = this._events, v === void 0) return this; if (v.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : v[t] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete v[t]), this; if (arguments.length === 0) { var C = Object.keys(v), b; for (_ = 0; _ < C.length; ++_)b = C[_], b !== "removeListener" && this.removeAllListeners(b); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if (g = v[t], typeof g == "function") this.removeListener(t, g); else if (g !== void 0) for (_ = g.length - 1; _ >= 0; _--)this.removeListener(t, g[_]); return this }; function Vr(a, t, g) { var v = a._events; if (v === void 0) return []; var _ = v[t]; return _ === void 0 ? [] : typeof _ == "function" ? g ? [_.listener || _] : [_] : g ? za(_) : Kr(_, _.length) } vt.prototype.listeners = function (t) { return Vr(this, t, !0) }; vt.prototype.rawListeners = function (t) { return Vr(this, t, !1) }; vt.listenerCount = function (a, t) { return typeof a.listenerCount == "function" ? a.listenerCount(t) : Gr.call(a, t) }; vt.prototype.listenerCount = Gr; function Gr(a) { var t = this._events; if (t !== void 0) { var g = t[a]; if (typeof g == "function") return 1; if (g !== void 0) return g.length } return 0 } vt.prototype.eventNames = function () { return this._eventsCount > 0 ? Je(this._events) : [] }; function Kr(a, t) { for (var g = new Array(t), v = 0; v < t; ++v)g[v] = a[v]; return g } function Ha(a, t) { for (; t + 1 < a.length; t++)a[t] = a[t + 1]; a.pop() } function za(a) { for (var t = new Array(a.length), g = 0; g < t.length; ++g)t[g] = a[g].listener || a[g]; return t } function Ya(a, t) { return new Promise(function (g, v) { function _(b) { a.removeListener(t, C), v(b) } function C() { typeof a.removeListener == "function" && a.removeListener("error", _), g([].slice.call(arguments)) } qr(a, t, C, { once: !0 }), t !== "error" && Na(a, _, { once: !0 }) }) } function Na(a, t, g) { typeof a.on == "function" && qr(a, "error", t, g) } function qr(a, t, g, v) { if (typeof a.on == "function") v.once ? a.once(t, g) : a.on(t, g); else if (typeof a.addEventListener == "function") a.addEventListener(t, function _(C) { v.once && a.removeEventListener(t, _), g(C) }); else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a) } var Ua = an.exports; class Va extends Ua.EventEmitter { constructor(g) { super(); me(this, "init", () => { this.canvas = new Ct.fabric.Canvas(this.elementId, { preserveObjectStacking: !0, selection: !1 }), this.canvas.on("object:added", _ => { this.calculate(), this.objectAddedListener(_), this.emit("object-selected", this) }), this.canvas.on("object:removed", _ => { this.calculate() }), this.canvas.on("object:modified", _ => { this.objectMovedListener(_), this.calculate() }), this.canvas.on("selection:created", _ => { console.log("selected"), this.emit("object-selected", this) }), this.canvas.on("selection:updated", _ => { console.log("selected"), this.emit("object-selected", this) }), this.canvas.on("selection:cleared", _ => { console.log("cleared"), this.emit("object-cleared", this) }); let g = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='200 215 230 470' xml:space='preserve'%3E%3Ccircle style='fill:%23F44336;' cx='299.76' cy='439.067' r='218.516'/%3E%3Cg%3E%3Crect x='267.162' y='307.978' transform='matrix(0.7071 -0.7071 0.7071 0.7071 -222.6202 340.6915)' style='fill:white;' width='65.545' height='262.18'/%3E%3Crect x='266.988' y='308.153' transform='matrix(0.7071 0.7071 -0.7071 0.7071 398.3889 -83.3116)' style='fill:white;' width='65.544' height='262.179'/%3E%3C/g%3E%3C/svg%3E"; var v = document.createElement("img"); v.src = g, this.canvas.setWidth(800), this.canvas.setHeight(400), this.canvas.setZoom(this.zoomScale), this.canvas.preserveObjectStacking = !0, this.canvas.stopContextMenu = !0, this.canvas.on("object:scaling", _ => { _.target, this.checkBounds() }), this.canvas.on("object:moving", _ => { _.target, this.checkBounds() }), this.canvas.on("object:selected", function (_) { console.log("Objektet klickades p: ", _.target) }), Ct.fabric.Object.prototype.controls.deleteControl = new Ct.fabric.Control({ x: .5, y: -.5, offsetY: -16, offsetX: 16, cursorStyle: "pointer", mouseUpHandler: this.deleteObject, render: this.renderIcon(v), cornerSize: 24 }), this.updateCanvasSize() }); me(this, "onWindowResize", () => { this.canvas.setDimensions({ width: window.innerWidth * .7, height: window.innerHeight }) }); me(this, "addText", (g, v) => { let _ = this.getXY(); const C = { left: _.left, top: _.top, originX: "center", originY: "center", width: 200, fontSize: 36, fill: "#FFFFFF" }, b = Object.assign({}, C, v), u = new Ct.fabric.IText(g, b); this.canvas.add(u).setActiveObject(u), this.changeFont(v.font), setTimeout(() => { this.emit("object-selected", this), this.calculate() }, 100) }); me(this, "addSvg", (g, v = () => { }) => { Ct.fabric.loadSVGFromString(g, _ => { this.canvas.renderOnAddRemove = !1, Ct.fabric.loadSVGFromString(g, C => { let b = this.getXY(); this.canvas.renderOnAddRemove = !1; var u = new Ct.fabric.Group(C, { left: b.left, top: b.top, originX: "center", originY: "center" }); const n = 75, l = 75, h = n / u.width, i = l / u.height; u.set({ scaleX: h, scaleY: i }), this.canvas.add(u).setActiveObject(u), this.canvas.renderOnAddRemove = !0, this.canvas.renderAll() }), this.canvas.renderOnAddRemove = !0, this.canvas.renderAll(), this.emit("object-selected", this) }), setTimeout(() => { this.calculate() }, 100), typeof v == "function" && v() }); me(this, "changeFont", g => { new Ba(g, { weight: 500 }).load().then(() => { this.canvas.getActiveObject().set("fontFamily", g), this.canvas.requestRenderAll() }) }); this.elementId = g, this.canvas = null, this.totalHeight = 0, this.totalWidth = 0, this.totalSquare = 0, this.zoomScale = 1, this.verticalLine = null, this.horizLine = null, this.verticalText = null, this.horizText = null, this.maxOutZoom = .91, this.isMobile = !1, this.init(), window.addEventListener("resize", this.onWindowResize) } getMessurements() { return { height: Math.round(this.totalHeight), width: Math.round(this.totalWidth), square: Math.round(this.totalSquare) } } updateCanvasSize() { var g = window.innerWidth; g < 800 ? (this.canvas.setWidth(g), this.canvas.setHeight(g / 2), this.isMobile = !0) : (this.canvas.setWidth(800), this.canvas.setHeight(400)), this.canvas.renderAll() } checkBounds() { var g = this.canvas.getActiveObject(), v = this.canvas.viewportTransform; this.canvas.getZoom(); var _ = g.getBoundingRect(); (_.left <= 0 || _.top <= 0 || _.left + _.width >= this.canvas.width || _.top + _.height >= this.canvas.height) && (this.zoomOut(), this.canvas.setViewportTransform([this.zoomScale, 0, 0, this.zoomScale, v[4], v[5]])) } renderIcon(g) { return function (_, C, b, u, n) { var l = this.cornerSize; _.save(), _.translate(C, b), _.rotate(Ct.fabric.util.degreesToRadians(n.angle)), _.drawImage(g, -l / 2, -l / 2, l, l), _.restore() } } deleteObject(g, v) { var _ = v.target, C = _.canvas; C.remove(_), C.requestRenderAll() } userObjects() { let g = this; return this.canvas.getObjects().map(function (_) { if (!g.ignoredObject(_)) return Ct.fabric.util.object.clone(_) }).filter(Boolean) } getXY() { let g = new Ct.fabric.Group(this.userObjects()); var v = g.getBoundingRect(); g.destroy(); let _ = this.canvas.width / 2, C = this.canvas.height / 2; return this.userObjects().length && (C = v.top + v.height + 20, _ = v.left + v.width / 2), { top: C, left: _ } } handleLines() { let g = new Ct.fabric.Group(this.userObjects()); var v = g.getBoundingRect(); g.destroy(); let _ = `${Math.round(this.totalWidth)} cm`, C = `${Math.round(this.totalHeight)} cm`; if (this.horizLine && this.verticalLine) { this.verticalLine.set({ left: v.left - 10, top: v.top, height: v.height }), this.horizLine.set({ left: v.left, top: v.top - 10, width: v.width }), this.verticalText.set({ text: C, left: v.left - 25, top: v.top + v.height / 2, textAlign: "center", angle: -90, originX: "center" }), this.horizText.set({ text: _, left: v.left + v.width / 2, top: v.top - 25, textAlign: "center", originX: "center" }), this.canvas.renderAll(); return } this.verticalLine = new Ct.fabric.Line([v.left - 10, v.top, v.left - 10, v.top + v.height], { stroke: "black", strokeWidth: 1 }), this.verticalLine.set("id", "vertical-line"), this.horizLine = new Ct.fabric.Line([v.left, v.top - 10, v.left + v.width, v.top - 10], { stroke: "black", strokeWidth: 1 }), this.horizLine.set("id", "horizontal-line"), this.horizText = new Ct.fabric.Text(_, { left: v.left + v.width / 2, top: v.top - 25, textAlign: "center", originX: "center", fontSize: 12 }), this.horizText.set("id", "horizontal-text"), this.verticalText = new Ct.fabric.Text(C, { left: v.left - 25, top: v.top + v.height / 2, textAlign: "center", angle: -90, originX: "center", fontSize: 12 }), this.verticalText.set("id", "vertical-text"), this.canvas.add(this.horizText), this.canvas.add(this.verticalText), this.canvas.add(this.verticalLine), this.canvas.add(this.horizLine) } setZoom(g) { this.zoomScale = g, this.canvas.setZoom(this.zoomScale) } getZoom() { return this.zoomScale } zoomIn() { this.zoomScale += .1, this.canvas.setZoom(this.zoomScale) } zoomOut() { let g = this.maxOutZoom; this.isMobile && (g = .41), this.zoomScale > g && (this.zoomScale = this.zoomScale * .85, console.log(this.zoomScale), this.zoomScale < g && (this.zoomScale = g)), this.canvas.setZoom(this.zoomScale) } setColor(g) { var v = this.canvas.getActiveObject(); v && v.type === "group" ? v.forEachObject(function (_) { _.type === "path" && _.fill !== "" && _.fill !== "none" && (_.set({ fill: g }), _.setCoords()) }) : (v.set({ fill: g }), v.setCoords()), this.emit("object-selected", this), this.canvas.renderAll() } selectAll() { if (!(this.canvas.getObjects().length <= 1)) { this.canvas.discardActiveObject(); var g = new Ct.fabric.ActiveSelection(this.canvas.getObjects(), { canvas: this.canvas }); this.canvas.setActiveObject(g), this.canvas.deselectAll(), this.canvas.requestRenderAll() } } mmToPixels(g, v = 96) { return g * v / 25.4 } generateImage() { let g = new Ct.fabric.Group(this.userObjects()); g.set({ top: 0, left: 0 }); var v = new Ct.fabric.StaticCanvas; return v.setDimensions({ width: g.width + 100, height: g.height + 100 }), v.add(g), v.toSVG() } objectAddedListener(g) { g.target } objectMovedListener(g, v) { g.target } ignoredObject(g) { return !!["vertical-line", "horizontal-line", "vertical-text", "horizontal-text"].includes(g.get("id")) } calculate() { let g = new Ct.fabric.Group(this.userObjects()); this.totalWidth = Ct.fabric.util.toFixed(g.width * g.scaleX / Ct.fabric.devicePixelRatio / 96 * 25.4, 2), this.totalHeight = Ct.fabric.util.toFixed(g.height * g.scaleY / Ct.fabric.devicePixelRatio / 96 * 25.4, 2), this.totalSquare = this.totalWidth * this.totalHeight, this.canvas.remove(g), this.emit("updated", this), this.handleLines(), setTimeout(() => { }, 300) } getActiveObject() { return JSON.stringify(this.canvas.getActiveObject()) } } const ln = (a, t) => { const g = a.__vccOpts || a; for (const [v, _] of t) g[v] = _; return g }, Ga = { props: { modelValue: null }, data() { return { color: this.value, active: !1, colors: ["#FFFFFF", "#FFF200", "#000000", "#F900F5", "#FF9D00", "#14CE00", "#D30000", "#00FFFF", "#0080FF"] } }, computed: { _color: { get() { return this.modelValue }, set(a) { this.color = a, this.$emit("input", a), this.$emit("picked", a) } } }, methods: { changeColor(a) { this._color = a } }, mounted() { console.log(this.value) } }, Ka = { class: "tool-dropdown" }, qa = ["onClick"]; function $a(a, t, g, v, _, C) { return Tt(), Mt(Ft, null, [dt("div", Ka, [dt("div", { class: "tool-dropdown__trigger color-trigger", style: De({ background: C._color }), onClick: t[0] || (t[0] = b => _.active = !_.active) }, null, 4), _.active ? (Tt(), Mt("div", { key: 0, class: we(["tool-dropdown__items", { "is-active": _.active }]) }, [(Tt(!0), Mt(Ft, null, nn(_.colors, b => (Tt(), Mt("div", { class: "color-trigger", style: De({ background: b }), onClick: u => C.changeColor(b) }, null, 12, qa))), 256))], 2)) : ii("", !0)]), _.active ? (Tt(), Mt("div", { key: 0, class: "click-outsider", onClick: t[1] || (t[1] = b => _.active = !1) })) : ii("", !0)], 64) } const Ja = ln(Ga, [["render", $a]]), Za = "modulepreload", Qa = function (a) { return "/" + a }, Nn = {}, St = function (t, g, v) { if (!g || g.length === 0) return t(); const _ = document.getElementsByTagName("link"); return Promise.all(g.map(C => { if (C = Qa(C), C in Nn) return; Nn[C] = !0; const b = C.endsWith(".css"), u = b ? '[rel="stylesheet"]' : ""; if (!!v) for (let h = _.length - 1; h >= 0; h--) { const i = _[h]; if (i.href === C && (!b || i.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${C}"]${u}`)) return; const l = document.createElement("link"); if (l.rel = b ? "stylesheet" : Za, b || (l.as = "script", l.crossOrigin = ""), l.href = C, document.head.appendChild(l), b) return new Promise((h, i) => { l.addEventListener("load", h), l.addEventListener("error", () => i(new Error(`Unable to preload CSS for ${C}`))) }) })).then(() => t()) }, tl = { name: "icon-select", data() { return { icons: [], active: !1 } }, methods: { async getIcons() { const a = await Object.assign({ "../../public/icons/social/bear-smile-line.svg": () => St(() => import("./bear-smile-line-436120a7.js"), []), "../../public/icons/social/emotion-2-line.svg": () => St(() => import("./emotion-2-line-46e10ffc.js"), []), "../../public/icons/social/emotion-laugh-fill.svg": () => St(() => import("./emotion-laugh-fill-6bd9eb7c.js"), []), "../../public/icons/social/emotion-laugh-line.svg": () => St(() => import("./emotion-laugh-line-7d10713c.js"), []), "../../public/icons/social/facebook-box-fill.svg": () => St(() => import("./facebook-box-fill-ba5656b7.js"), []), "../../public/icons/social/facebook-circle-fill.svg": () => St(() => import("./facebook-circle-fill-ca940894.js"), []), "../../public/icons/social/instagram-fill.svg": () => St(() => import("./instagram-fill-e585dbc1.js"), []), "../../public/icons/social/instagram-line.svg": () => St(() => import("./instagram-line-b8b8c66b.js"), []), "../../public/icons/social/snapchat-fill.svg": () => St(() => import("./snapchat-fill-ab64d036.js"), []), "../../public/icons/social/snapchat-line.svg": () => St(() => import("./snapchat-line-66ffbead.js"), []), "../../public/icons/social/twitter-fill.svg": () => St(() => import("./twitter-fill-3f7546f3.js"), []), "../../public/icons/social/twitter-line.svg": () => St(() => import("./twitter-line-c55ef7fe.js"), []), "../../public/icons/social/vip-crown-2-fill.svg": () => St(() => import("./vip-crown-2-fill-320e58cc.js"), []), "../../public/icons/social/vip-crown-2-line.svg": () => St(() => import("./vip-crown-2-line-32023404.js"), []), "../../public/icons/social/vip-fill.svg": () => St(() => import("./vip-fill-affe8ed2.js"), []), "../../public/icons/social/vip-line.svg": () => St(() => import("./vip-line-2a773682.js"), []), "../../public/icons/social/youtube-fill.svg": () => St(() => import("./youtube-fill-b1bd688c.js"), []), "../../public/icons/social/youtube-line.svg": () => St(() => import("./youtube-line-8d92c1ed.js"), []) }); return Object.keys(a).map(t => "/icons/social/" + t.split("/").pop()) }, iconClicked(a) { this.active = !1, this.$emit("selected", a) } }, async mounted() { this.icons = await this.getIcons() } }, el = { class: "tool-dropdown" }, il = dt("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" }, [dt("g", null, [dt("path", { fill: "none", d: "M0 0h24v24H0z" }), dt("path", { d: "M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2zm0 9c-2 0-3.667.333-5 1a5 5 0 0 0 10 0c-1.333-.667-3-1-5-1zM8.5 7c-1.152 0-2.122.78-2.412 1.84L6.05 9h4.9A2.5 2.5 0 0 0 8.5 7zm7 0c-1.152 0-2.122.78-2.412 1.84L13.05 9h4.9a2.5 2.5 0 0 0-2.45-2z" })])], -1), nl = [il], rl = ["src", "onClick"]; function sl(a, t, g, v, _, C) { return Tt(), Mt("div", el, [dt("div", { class: "tool-dropdown__trigger", onClick: t[0] || (t[0] = b => _.active = !_.active) }, nl), dt("div", { class: we(["tool-dropdown__items", { "is-active": _.active }]) }, [(Tt(!0), Mt(Ft, null, nn(_.icons, b => (Tt(), Mt("img", { src: b, onClick: u => C.iconClicked(b) }, null, 8, rl))), 256))], 2), _.active ? (Tt(), Mt("div", { key: 0, class: "click-outsider", onClick: t[1] || (t[1] = b => _.active = !1) })) : ii("", !0)]) } const ol = ln(tl, [["render", sl]]), al = { components: { IconSelect: ol, ColorPick: Ja }, layout: "fullPage", data() { return { fonts: ["Bangers", "Bree Serif", "Changa One", "Chewy", "Concert One", "Courgette", "Itim", "Lilita One", "Pacifico", "Righteous", "Ultra", "Kaushan Script"], canvas: null, font: "Bangers", designer: null, messurements: null, zoom: .91, hasSelection: !1, activeObject: null, color: "#FFFFFF", sku: null, addingToCart: !1, errorMessage: null } }, computed: { _width() { return this.messurements ? this.messurements.width : 0 }, _height() { return this.messurements ? this.messurements.height : 0 }, _zoom: { get() { return this.zoom }, set(a) { return this.zoom = a, a > this.zoom ? this.designer.zoomIn() : this.designer.zoomOut() } }, _price() { if (!this.messurements) return ""; let a = 30, t = .1, g = a + this.messurements.square * t, v = 0; this.messurements.width >= 100 && (v = 15), this.messurements.width >= 115 && (v = 20), this.messurements.width >= 120 && (v = 30); let _ = g - g * (v / 100), C = Math.round(_); return this.messurements.width >= 90 && C < 199 ? 199 : C }, _activeObject() { return JSON.parse(this.activeObject) }, _font: { get() { return this._activeObject && this._activeObject.hasOwnProperty("fontFamily") ? this._activeObject.fontFamily : this.font }, set(a) { this.font = a } }, _color: { get() { return this._activeObject && this._activeObject.hasOwnProperty("fill") ? this._activeObject.fill : this.color }, set(a) { this.color = a } } }, methods: { exportImage() { this.designer.generateImage() }, addText() { this.designer.addText("Skriv din text hr", { font: this.font }) }, fontChange(a) { this.designer.changeFont(this.font) }, update() { this.messurements = this.designer.getMessurements() }, addIcon(a) { let t = this; var g = new XMLHttpRequest; g.open("GET", a, !0), g.onreadystatechange = function () { this.readyState === 4 && this.status === 200 && t.designer.addSvg(this.responseText, () => { }) }, g.send() }, setColor(a) { this.designer.setColor(a) }, init() { this.lockApp = !0; const a = window.location.search, t = new URLSearchParams(a); this.sku = t.get("sku"), this.vid = t.get("vid"), (!this.sku || !this.vid) && (this.errorMessage = "Missing SKU or VID"), this.designer.addText("Skriv din text hr", { font: this.font }) }, async addToCart() { try { let a = await this.designer.generateImage(), t = { sku: this.sku, vid: this.vid, price: this._price, svg: a, messurements: { height: this.messurements.height, width: this.messurements.width } }; console.log("sending", t), window.parent.postMessage({ event: "addToCart", product: t }, "*"), this.addingToCart = !1 } catch (a) { console.error(a), this.addingToCart = !1 } }, updateIframeHeight() { const a = document.documentElement.scrollHeight; console.log("Scrollheight: " + a), window.parent.postMessage({ event: "updateIframeHeight", height: a }, "*") } }, mounted() { this.designer = new Va("canvas"), this.designer.on("updated", () => { this.update() }), this.designer.on("object-selected", () => { this.hasSelection = !0, this.activeObject = this.designer.getActiveObject() }), this.designer.on("object-cleared", () => { this.hasSelection = !1, this.activeObject = null }), setTimeout(() => { this.init() }, 100) } }, ll = { key: 0, class: "designer" }, hl = { class: "designer__window" }, cl = { class: "designer__window__tools" }, ul = dt("span", null, " Typsnitt ", -1), fl = dt("span", null, " Text ", -1), dl = dt("span", null, " Frg ", -1), gl = dt("span", null, " Emoji ", -1), pl = dt("span", null, " Zoom ", -1), ml = { class: "zoom-tools" }, vl = dt("svg", { width: "800px", height: "800px", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [dt("path", { d: "M6.5 8.5C5.94772 8.5 5.5 8.94771 5.5 9.5V10.5C5.5 11.0523 5.94772 11.5 6.5 11.5H13.5C14.0523 11.5 14.5 11.0523 14.5 10.5V9.5C14.5 8.94772 14.0523 8.5 13.5 8.5H6.5Z", fill: "#000000" }), dt("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.5 10C0.5 4.75329 4.75329 0.5 10 0.5C15.2467 0.5 19.5 4.75329 19.5 10C19.5 12.082 18.8302 14.0076 17.6944 15.5731L22.4142 20.2929C22.8047 20.6834 22.8047 21.3166 22.4142 21.7071L21.7071 22.4142C21.3166 22.8047 20.6834 22.8047 20.2929 22.4142L15.5731 17.6944C14.0076 18.8302 12.082 19.5 10 19.5C4.75329 19.5 0.5 15.2467 0.5 10ZM10 3.5C6.41015 3.5 3.5 6.41015 3.5 10C3.5 13.5899 6.41015 16.5 10 16.5C13.5899 16.5 16.5 13.5899 16.5 10C16.5 6.41015 13.5899 3.5 10 3.5Z", fill: "#000000" })], -1), _l = [vl], yl = dt("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, [dt("path", { d: "M9.5 14.5C8.94772 14.5 8.5 14.0523 8.5 13.5V11.5H6.5C5.94772 11.5 5.5 11.0523 5.5 10.5V9.5C5.5 8.94772 5.94772 8.5 6.5 8.5H8.5V6.5C8.5 5.94772 8.94772 5.5 9.5 5.5H10.5C11.0523 5.5 11.5 5.94772 11.5 6.5V8.5H13.5C14.0523 8.5 14.5 8.94772 14.5 9.5V10.5C14.5 11.0523 14.0523 11.5 13.5 11.5H11.5V13.5C11.5 14.0523 11.0523 14.5 10.5 14.5H9.5Z", fill: "#000000" }), dt("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.5 10C0.5 4.75329 4.75329 0.5 10 0.5C15.2467 0.5 19.5 4.75329 19.5 10C19.5 12.082 18.8302 14.0076 17.6944 15.5731L22.4142 20.2929C22.8047 20.6834 22.8047 21.3166 22.4142 21.7071L21.7071 22.4142C21.3166 22.8047 20.6834 22.8047 20.2929 22.4142L15.5731 17.6944C14.0076 18.8302 12.082 19.5 10 19.5C4.75329 19.5 0.5 15.2467 0.5 10ZM10 3.5C6.41015 3.5 3.5 6.41015 3.5 10C3.5 13.5899 6.41015 16.5 10 16.5C13.5899 16.5 16.5 13.5899 16.5 10C16.5 6.41015 13.5899 3.5 10 3.5Z", fill: "#000000" })], -1), Cl = [yl], bl = { key: 0, class: "pricing" }, xl = { class: "size" }, wl = { class: "action" }, Sl = { class: "price" }, Tl = dt("span", null, "PRIS", -1), Ol = dt("div", { class: "designer__window__canvas" }, [dt("canvas", { id: "canvas" })], -1), El = { key: 1, class: "system-error" }; function Pl(a, t, g, v, _, C) { const b = xn("color-pick"), u = xn("icon-select"); return Tt(), Mt("main", null, [_.errorMessage ? (Tt(), Mt("div", El, Pe(_.errorMessage), 1)) : (Tt(), Mt("div", ll, [dt("div", hl, [dt("div", cl, [dt("div", null, [ul, To(dt("select", { "onUpdate:modelValue": t[0] || (t[0] = n => C._font = n), onChange: t[1] || (t[1] = (...n) => C.fontChange && C.fontChange(...n)) }, [(Tt(!0), Mt(Ft, null, nn(_.fonts, n => (Tt(), Mt("option", null, Pe(n), 1))), 256))], 544), [[Pa, C._font]])]), dt("div", null, [fl, dt("button", { onClick: t[2] || (t[2] = (...n) => C.addText && C.addText(...n)) }, "Lgg till text")]), dt("div", null, [dl, Vt(b, { onPicked: C.setColor, modelValue: C._color, "onUpdate:modelValue": t[3] || (t[3] = n => C._color = n) }, null, 8, ["onPicked", "modelValue"])]), dt("div", null, [gl, Vt(u, { onSelected: C.addIcon }, null, 8, ["onSelected"])]), dt("div", null, [pl, dt("div", ml, [dt("div", { class: "zoom-tools__tool", onClick: t[4] || (t[4] = (...n) => _.designer.zoomOut && _.designer.zoomOut(...n)) }, _l), dt("div", { class: "zoom-tools__tool", onClick: t[5] || (t[5] = (...n) => _.designer.zoomIn && _.designer.zoomIn(...n)) }, Cl)])])]), this.messurements ? (Tt(), Mt("div", bl, [dt("div", xl, [dt("div", null, " Mtt " + Pe(_.messurements.width) + " x " + Pe(_.messurements.height) + " cm ", 1)]), dt("div", wl, [dt("div", Sl, [Tl, Rr(" " + Pe(C._price) + " kr ", 1)]), dt("button", { class: we(["buy", { "is-loading:": _.addingToCart }]), onClick: t[6] || (t[6] = (...n) => C.addToCart && C.addToCart(...n)) }, "Lgg i varukorgen", 2)])])) : ii("", !0), Ol])]))]) } const Al = ln(al, [["render", Pl]]); ka(Al).mount("#nydekal");